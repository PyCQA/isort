{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository isort your imports, so you don't have to. isort is a Python utility / library to sort imports alphabetically, and automatically separated into sections and by type. It provides a command line utility, Python library and plugins for various editors to quickly sort all your imports. It requires Python 3.6+ to run but supports formatting Python 2 code too. Try isort now from your browser! Using black? See the isort and black compatiblity guide. isort has official support for pre-commit! Before isort: from my_lib import Object import os from my_lib import Object3 from my_lib import Object2 import sys from third_party import lib15 , lib1 , lib2 , lib3 , lib4 , lib5 , lib6 , lib7 , lib8 , lib9 , lib10 , lib11 , lib12 , lib13 , lib14 import sys from __future__ import absolute_import from third_party import lib3 print ( \"Hey\" ) print ( \"yo\" ) After isort: from __future__ import absolute_import import os import sys from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , lib6 , lib7 , lib8 , lib9 , lib10 , lib11 , lib12 , lib13 , lib14 , lib15 ) from my_lib import Object , Object2 , Object3 print ( \"Hey\" ) print ( \"yo\" ) Installing isort Installing isort is as simple as: pip install isort Install isort with requirements.txt support: pip install isort [ requirements_deprecated_finder ] Install isort with Pipfile support: pip install isort [ pipfile_deprecated_finder ] Install isort with both formats support: pip install isort [ requirements_deprecated_finder,pipfile_deprecated_finder ] Using isort From the command line : isort mypythonfile.py mypythonfile2.py or recursively: isort . which is equivalent to: isort **/*.py or to see the proposed changes without applying them: isort mypythonfile.py --diff Finally, to atomically run isort against a project, only applying changes if they don't introduce syntax errors do: isort --atomic . (Note: this is disabled by default as it keeps isort from being able to run against code written using a different version of Python) From within Python : import isort isort . file ( \"pythonfile.py\" ) or: import isort sorted_code = isort . code ( \"import b \\n import a \\n \" ) Installing isort's for your preferred text editor Several plugins have been written that enable to use isort from within a variety of text-editors. You can find a full list of them on the isort wiki . Additionally, I will enthusiastically accept pull requests that include plugins for other text editors and add documentation for them as I am notified. Multi line output modes You will notice above the \\\"multi_line_output\\\" setting. This setting defines how from imports wrap when they extend past the line_length limit and has 12 possible settings . Indentation To change the how constant indents appear - simply change the indent property with the following accepted formats: Number of spaces you would like. For example: 4 would cause standard 4 space indentation. Tab A verbatim string with quotes around it. For example: \" \" is equivalent to 4. For the import styles that use parentheses, you can control whether or not to include a trailing comma after the last import with the include_trailing_comma option (defaults to False ). Intelligently Balanced Multi-line Imports As of isort 3.1.0 support for balanced multi-line imports has been added. With this enabled isort will dynamically change the import length to the one that produces the most balanced grid, while staying below the maximum import length defined. Example: from __future__ import ( absolute_import , division , print_function , unicode_literals ) Will be produced instead of: from __future__ import ( absolute_import , division , print_function , unicode_literals ) To enable this set balanced_wrapping to True in your config or pass the -e option into the command line utility. Custom Sections and Ordering isort provides configuration options to change almost every aspect of how imports are organized, ordered, or grouped together in sections. Click here for an overview of all these options. Skip processing of imports (outside of configuration) To make isort ignore a single import simply add a comment at the end of the import line containing the text isort:skip : import module # isort:skip or: from xyz import ( abc , # isort:skip yo , hey ) To make isort skip an entire file simply add isort:skip_file to the module's doc string: \"\"\" my_module.py Best module ever isort:skip_file \"\"\" import b import a Adding an import to multiple files isort makes it easy to add an import statement across multiple files, while being assured it's correctly placed. To add an import to all files: isort -a \"from __future__ import print_function\" *.py To add an import only to files that already have imports: isort -a \"from __future__ import print_function\" --append-only *.py Removing an import from multiple files isort also makes it easy to remove an import from multiple files, without having to be concerned with how it was originally formatted. From the command line: isort --rm \"os.system\" *.py Using isort to verify code The --check-only option isort can also be used to verify that code is correctly formatted by running it with -c . Any files that contain incorrectly sorted and/or formatted imports will be outputted to stderr . isort **/*.py -c -v SUCCESS: /home/timothy/Projects/Open_Source/isort/isort_kate_plugin.py Everything Looks Good! ERROR: /home/timothy/Projects/Open_Source/isort/isort/isort.py Imports are incorrectly sorted. One great place this can be used is with a pre-commit git hook, such as this one by \\@acdha: https://gist.github.com/acdha/8717683 This can help to ensure a certain level of code quality throughout a project. Git hook isort provides a hook function that can be integrated into your Git pre-commit script to check Python code before committing. To cause the commit to fail if there are isort errors (strict mode), include the following in .git/hooks/pre-commit : #!/usr/bin/env python import sys from isort.hooks import git_hook sys . exit ( git_hook ( strict = True , modify = True , lazy = True , settings_file = \"\" )) If you just want to display warnings, but allow the commit to happen anyway, call git_hook without the strict parameter. If you want to display warnings, but not also fix the code, call git_hook without the modify parameter. The lazy argument is to support users who are \"lazy\" to add files individually to the index and tend to use git commit -a instead. Set it to True to ensure all tracked files are properly isorted, leave it out or set it to False to check only files added to your index. If you want to use a specific configuration file for the hook, you can pass its path to settings_file. If no path is specifically requested, git_hook will search for the configuration file starting at the directory containing the first staged file, as per git diff-index ordering, and going upward in the directory structure until a valid configuration file is found or MAX_CONFIG_SEARCH_DEPTH directories are checked. The settings_file parameter is used to support users who keep their configuration file in a directory that might not be a parent of all the other files. Setuptools integration Upon installation, isort enables a setuptools command that checks Python files declared by your project. Running python setup.py isort on the command line will check the files listed in your py_modules and packages . If any warning is found, the command will exit with an error code: $ python setup.py isort Also, to allow users to be able to use the command without having to install isort themselves, add isort to the setup_requires of your setup() like so: setup ( name = \"project\" , packages = [ \"project\" ], setup_requires = [ \"isort\" ] ) Spread the word Place this badge at the top of your repository to let others know your project uses isort. For README.md: [![Imports: isort](https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336)](https://pycqa.github.io/isort/) Or README.rst: .. image :: https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336 :target: https://pycqa.github.io/isort/ Security contact information To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure. Why isort? isort simply stands for import sort. It was originally called \"sortImports\" however I got tired of typing the extra characters and came to the realization camelCase is not pythonic. I wrote isort because in an organization I used to work in the manager came in one day and decided all code must have alphabetically sorted imports. The code base was huge - and he meant for us to do it by hand. However, being a programmer - I\\'m too lazy to spend 8 hours mindlessly performing a function, but not too lazy to spend 16 hours automating it. I was given permission to open source sortImports and here we are :) Get professionally supported isort with the Tidelift Subscription Professional support for isort is available as part of the Tidelift Subscription . Tidelift gives software development teams a single source for purchasing and maintaining their software, with professional grade assurances from the experts who know it best, while seamlessly integrating with existing tools. Thanks and I hope you find isort useful! ~Timothy Crosley","title":"Home"},{"location":"#installing-isort","text":"Installing isort is as simple as: pip install isort Install isort with requirements.txt support: pip install isort [ requirements_deprecated_finder ] Install isort with Pipfile support: pip install isort [ pipfile_deprecated_finder ] Install isort with both formats support: pip install isort [ requirements_deprecated_finder,pipfile_deprecated_finder ]","title":"Installing isort"},{"location":"#using-isort","text":"From the command line : isort mypythonfile.py mypythonfile2.py or recursively: isort . which is equivalent to: isort **/*.py or to see the proposed changes without applying them: isort mypythonfile.py --diff Finally, to atomically run isort against a project, only applying changes if they don't introduce syntax errors do: isort --atomic . (Note: this is disabled by default as it keeps isort from being able to run against code written using a different version of Python) From within Python : import isort isort . file ( \"pythonfile.py\" ) or: import isort sorted_code = isort . code ( \"import b \\n import a \\n \" )","title":"Using isort"},{"location":"#installing-isorts-for-your-preferred-text-editor","text":"Several plugins have been written that enable to use isort from within a variety of text-editors. You can find a full list of them on the isort wiki . Additionally, I will enthusiastically accept pull requests that include plugins for other text editors and add documentation for them as I am notified.","title":"Installing isort's for your preferred text editor"},{"location":"#multi-line-output-modes","text":"You will notice above the \\\"multi_line_output\\\" setting. This setting defines how from imports wrap when they extend past the line_length limit and has 12 possible settings .","title":"Multi line output modes"},{"location":"#indentation","text":"To change the how constant indents appear - simply change the indent property with the following accepted formats: Number of spaces you would like. For example: 4 would cause standard 4 space indentation. Tab A verbatim string with quotes around it. For example: \" \" is equivalent to 4. For the import styles that use parentheses, you can control whether or not to include a trailing comma after the last import with the include_trailing_comma option (defaults to False ).","title":"Indentation"},{"location":"#intelligently-balanced-multi-line-imports","text":"As of isort 3.1.0 support for balanced multi-line imports has been added. With this enabled isort will dynamically change the import length to the one that produces the most balanced grid, while staying below the maximum import length defined. Example: from __future__ import ( absolute_import , division , print_function , unicode_literals ) Will be produced instead of: from __future__ import ( absolute_import , division , print_function , unicode_literals ) To enable this set balanced_wrapping to True in your config or pass the -e option into the command line utility.","title":"Intelligently Balanced Multi-line Imports"},{"location":"#custom-sections-and-ordering","text":"isort provides configuration options to change almost every aspect of how imports are organized, ordered, or grouped together in sections. Click here for an overview of all these options.","title":"Custom Sections and Ordering"},{"location":"#skip-processing-of-imports-outside-of-configuration","text":"To make isort ignore a single import simply add a comment at the end of the import line containing the text isort:skip : import module # isort:skip or: from xyz import ( abc , # isort:skip yo , hey ) To make isort skip an entire file simply add isort:skip_file to the module's doc string: \"\"\" my_module.py Best module ever isort:skip_file \"\"\" import b import a","title":"Skip processing of imports (outside of configuration)"},{"location":"#adding-an-import-to-multiple-files","text":"isort makes it easy to add an import statement across multiple files, while being assured it's correctly placed. To add an import to all files: isort -a \"from __future__ import print_function\" *.py To add an import only to files that already have imports: isort -a \"from __future__ import print_function\" --append-only *.py","title":"Adding an import to multiple files"},{"location":"#removing-an-import-from-multiple-files","text":"isort also makes it easy to remove an import from multiple files, without having to be concerned with how it was originally formatted. From the command line: isort --rm \"os.system\" *.py","title":"Removing an import from multiple files"},{"location":"#using-isort-to-verify-code","text":"","title":"Using isort to verify code"},{"location":"#the-check-only-option","text":"isort can also be used to verify that code is correctly formatted by running it with -c . Any files that contain incorrectly sorted and/or formatted imports will be outputted to stderr . isort **/*.py -c -v SUCCESS: /home/timothy/Projects/Open_Source/isort/isort_kate_plugin.py Everything Looks Good! ERROR: /home/timothy/Projects/Open_Source/isort/isort/isort.py Imports are incorrectly sorted. One great place this can be used is with a pre-commit git hook, such as this one by \\@acdha: https://gist.github.com/acdha/8717683 This can help to ensure a certain level of code quality throughout a project.","title":"The --check-only option"},{"location":"#git-hook","text":"isort provides a hook function that can be integrated into your Git pre-commit script to check Python code before committing. To cause the commit to fail if there are isort errors (strict mode), include the following in .git/hooks/pre-commit : #!/usr/bin/env python import sys from isort.hooks import git_hook sys . exit ( git_hook ( strict = True , modify = True , lazy = True , settings_file = \"\" )) If you just want to display warnings, but allow the commit to happen anyway, call git_hook without the strict parameter. If you want to display warnings, but not also fix the code, call git_hook without the modify parameter. The lazy argument is to support users who are \"lazy\" to add files individually to the index and tend to use git commit -a instead. Set it to True to ensure all tracked files are properly isorted, leave it out or set it to False to check only files added to your index. If you want to use a specific configuration file for the hook, you can pass its path to settings_file. If no path is specifically requested, git_hook will search for the configuration file starting at the directory containing the first staged file, as per git diff-index ordering, and going upward in the directory structure until a valid configuration file is found or MAX_CONFIG_SEARCH_DEPTH directories are checked. The settings_file parameter is used to support users who keep their configuration file in a directory that might not be a parent of all the other files.","title":"Git hook"},{"location":"#setuptools-integration","text":"Upon installation, isort enables a setuptools command that checks Python files declared by your project. Running python setup.py isort on the command line will check the files listed in your py_modules and packages . If any warning is found, the command will exit with an error code: $ python setup.py isort Also, to allow users to be able to use the command without having to install isort themselves, add isort to the setup_requires of your setup() like so: setup ( name = \"project\" , packages = [ \"project\" ], setup_requires = [ \"isort\" ] )","title":"Setuptools integration"},{"location":"#spread-the-word","text":"Place this badge at the top of your repository to let others know your project uses isort. For README.md: [![Imports: isort](https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336)](https://pycqa.github.io/isort/) Or README.rst: .. image :: https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336 :target: https://pycqa.github.io/isort/","title":"Spread the word"},{"location":"#security-contact-information","text":"To report a security vulnerability, please use the Tidelift security contact . Tidelift will coordinate the fix and disclosure.","title":"Security contact information"},{"location":"#why-isort","text":"isort simply stands for import sort. It was originally called \"sortImports\" however I got tired of typing the extra characters and came to the realization camelCase is not pythonic. I wrote isort because in an organization I used to work in the manager came in one day and decided all code must have alphabetically sorted imports. The code base was huge - and he meant for us to do it by hand. However, being a programmer - I\\'m too lazy to spend 8 hours mindlessly performing a function, but not too lazy to spend 16 hours automating it. I was given permission to open source sortImports and here we are :) Get professionally supported isort with the Tidelift Subscription Professional support for isort is available as part of the Tidelift Subscription . Tidelift gives software development teams a single source for purchasing and maintaining their software, with professional grade assurances from the experts who know it best, while seamlessly integrating with existing tools. Thanks and I hope you find isort useful! ~Timothy Crosley","title":"Why isort?"},{"location":"CHANGELOG/","text":"Changelog NOTE: isort follows the semver versioning standard. Find out more about isort's release policy here . 5.8.0 TBD Fixed #1631: as import comments can in some cases be duplicated. Implemented #1648: Export MyPY type hints. Implemented #1641: Identified import statements now return runnable code. Implemented #1661: Added \"wemake\" profile. 5.7.0 December 30th 2020 Fixed #1612: In rare circumstances an extra comma is added after import and before comment. Fixed #1593: isort encounters bug in Python 3.6.0. Implemented #1596: Provide ways for extension formatting and file paths to be specified when using streaming input from CLI. Implemented #1583: Ability to output and diff within a single API call to isort.file . Implemented #1562, #1592 & #1593: Better more useful fatal error messages. Implemented #1575: Support for automatically fixing mixed indentation of import sections. Implemented #1582: Added a CLI option for skipping symlinks. Implemented #1603: Support for disabling float_to_top from the command line. Implemented #1604: Allow toggling section comments on and off for indented import sections. 5.6.4 October 12, 2020 Fixed #1556: Empty line added between imports that should be skipped. 5.6.3 October 11, 2020 Improved packaging of test files alongside source distribution (see: https://github.com/PyCQA/isort/pull/1555). 5.6.2 October 10, 2020 Fixed #1548: On rare occasions an unecessary empty line can be added when an import is marked as skipped. Fixed #1542: Bug in VERTICAL_PREFIX_FROM_MODULE_IMPORT wrap mode. Fixed #1552: Pylama test dependent on source layout. Goal Zero: (Tickets related to aspirational goal of achieving 0 regressions for remaining 5.0.0 lifespan): Zope added to integration test suite Additional testing of CLI (simulate unseekable streams) 5.6.1 [Hotfix] October 8, 2020 Fixed #1546: Unstable (non-idempotent) behavior with certain src trees. 5.6.0 October 7, 2020 Implemented #1433: Provide helpful feedback in case a custom config file is specified without a configuration. Implemented #1494: Default to sorting imports within .pxd files. Implemented #1502: Improved float-to-top behavior when there is an existing import section present at top-of-file. Implemented #1511: Support for easily seeing all files isort will be ran against using isort . --show-files . Implemented #1487: Improved handling of encoding errors. Improved handling of unsupported configuration option errors (see #1475). Fixed #1463: Better interactive documentation for future option. Fixed #1461: Quiet config option not respected by file API in some circumstances. Fixed #1482: pylama integration is not working correctly out-of-the-box. Fixed #1492: --check does not work with stdin source. Fixed #1499: isort gets confused by single line, multi-line style comments when using float-to-top. Fixed #1525: Some warnings can't be disabled with --quiet. Fixed #1523: in rare cases isort can ignore direct from import if as import is also on same line. Potentially breaking changes: Implemented #1540: Officially support Python 3.9 stdlib imports by default. Fixed #1443: Incorrect third vs first party categorization - namespace packages. Fixed #1486: \"Google\" profile is not quite Google style. Fixed \"PyCharm\" profile to always add 2 lines to be consistent with what PyCharm \"Optimize Imports\" does. Goal Zero: (Tickets related to aspirational goal of achieving 0 regressions for remaining 5.0.0 lifespan): Implemented #1472: Full testing of stdin CLI Options Added additional branch coverage. More projects added to integration test suite. 5.5.5 [Hotfix] October 7, 2020 Fixed #1539: in extremely rare cases isort 5.5.4 introduces syntax error by removing closing paren. 5.5.4 [Hotfix] September 29, 2020 Fixed #1507: in rare cases isort changes the content of multiline strings after a yield statement. Fixed #1505: Support case where known_SECTION points to a section not listed in sections. 5.5.3 [Hotfix] September 20, 2020 Fixed #1488: in rare cases isort can mangle yield from or raise from statements. 5.5.2 [Hotfix] September 9, 2020 Fixed #1469: --diff option is ignored when input is from stdin. 5.5.1 September 4, 2020 Fixed #1454: Ensure indented import sections with import heading and a preceding comment don't cause import sorting loops. Fixed #1453: isort error when float to top on almost empty file. Fixed #1456 and #1415: noqa comment moved to where flake8 cant see it. Fixed #1460: .svn missing from default ignore list. 5.5.0 September 3, 2020 Fixed #1398: isort: off comment doesn't work, if it's the top comment in the file. Fixed #1395: reverse_relative setting doesn't have any effect when combined with force_sort_within_sections. Fixed #1399: --skip can error in the case of projects that contain recursive symlinks. Fixed #1389: ensure_newline_before_comments doesn't work if comment is at top of section and sections don't have lines between them. Fixed #1396: comments in imports with \";\" can keep isort from recognizing import line. Fixed #1380: As imports removed when combine_star is set. Fixed #1382: --float-to-top has no effect if no import is already at the top. Fixed #1420: isort never settles on module docstring + add import. Fixed #1421: Error raised when repo contains circular symlinks. Fixed #1427: noqa comment is moved from star import to constant import. Fixed #1444 & 1445: Incorrect placement of import additions. Fixed #1447: isort5 throws error when stdin used on Windows with deprecated args. Implemented #1397: Added support for specifying config file when using git hook (thanks @diseraluca!). Implemented #1405: Added support for coloring diff output. Implemented #1434: New multi-line grid mode without parentheses. Goal Zero (Tickets related to aspirational goal of achieving 0 regressions for remaining 5.0.0 lifespan): Implemented #1392: Extensive profile testing. Implemented #1393: Proprety based testing applied to code snippets. Implemented #1391: Create automated integration test that includes full code base of largest OpenSource isort users. Potentially breaking changes: Fixed #1429: --check doesn't print to stderr as the documentation says. This means if you were looking for ERROR: messages for files that contain incorrect imports within stdout you will now need to look in stderr. 5.4.2 Aug 14, 2020 Fixed #1383: Known other does not work anymore with .editorconfig. Fixed: Regression in first known party path expansion. 5.4.1 [Hotfix] Aug 13, 2020 Fixed #1381: --combine-as loses # noqa in different circumstances. 5.4.0 Aug 12, 2020 Implemented #1373: support for length sort only of direct (AKA straight) imports. Fixed #1321: --combine-as loses # noqa. Fixed #1375: --dont-order-by-type CLI broken. 5.3.2 [Hotfix] Aug 7, 2020 Fixed incorrect warning code (W503->W0503). 5.3.1 Aug 7, 2020 Improve upgrade warnings to be less noisy and point to error codes for easy interoperability with Visual Studio Code (see: #1363). 5.3.0 Aug 4, 2020 Implemented ability to treat all or select comments as code (issue #1357) Implemented ability to use different configs for different file extensions (issue #1162) Implemented ability to specify the types of imports (issue #1181) Implemented ability to dedup import headings (issue #953) Added experimental support for sorting literals (issue #1358) Added experimental support for sorting and deduping groupings of assignments. Improved handling of deprecated single line variables for usage with Visual Studio Code (issue #1363) Improved handling of mixed newline forms within same source file. Improved error handling for known sections. Improved API consistency, returning a boolean value for all modification API calls to indicate if changes were made. Fixed #1366: spurious errors when combining skip with --gitignore. Fixed #1359: --skip-gitignore does not honor ignored symlink Internal Development: Initial hypothesmith powered test to help catch unexpected syntax parsing and output errors (thanks @Zac-HD!) 5.2.2 July 30, 2020 Fixed #1356: return status when arguments are passed in without files or a content stream. 5.2.1 July 28, 2020 Update precommit to default to filtering files that are defined in skip. Improved relative path detection for skip config usage. Added recursive symbolic link protection. Implemented #1177: Support for color output using --color . Implemented recursive symlink detection support. 5.2.0 July 27, 2020 Implemented #1335: Official API for diff capturing. Implemented #1331: Warn when sections don't match up. Implemented #1261: By popular demand, filter_files can now be set in the config option. Implemented #960: Support for respecting git ignore via \"--gitignore\" or \"skip_gitignore=True\". Implemented #727: Ability to only add imports if existing imports exist. Implemented #970: Support for custom sharable isort profiles. Implemented #1214: Added support for git_hook lazy option (Thanks @sztamas!) Implemented #941: Added an additional multi_line_output mode for more compact formatting (Thanks @sztamas!) Implemented #1020: Option for LOCALFOLDER. Implemented #1353: Added support for output formatting plugins. # isort: split can now be used at the end of an import line. Fixed #1339: Extra indent is not preserved when isort:skip is used in nested imports. Fixed #1348: --diff works incorrectly with files that have CRLF line endings. Improved code repositories usage of pylint tags (#1350). 5.1.4 July 19, 2020 Fixed issue #1333: Use of wrap_length raises an exception about it not being lower or equal to line_length. Fixed issue #1330: Ensure stdout can be stubbed dynamically for show_unified_diff function. 5.1.3 July 18, 2020 Fixed issue #1329: Fix comments duplicated when --fass option is set. 5.1.2 July 17, 2020 Fixed issue #1219 / #1326: Comments not wrapped for long lines Fixed issue #1156: Bug related to isort:skip usage followed by a multiline comment block 5.1.1 July 15, 2020 Fixed issue #1322: Occasionally two extra newlines before comment with -n & --fss . Fixed issue #1189: --diff broken when reading from standard input. 5.1.0 July 14, 2020 isort now throws an exception if an invalid settings path is given (issue #1174). Implemented support for automatic redundant alias removal (issue #1281). Implemented experimental support for floating all imports to the top of a file (issue #1228) Fixed #1178: support for semicolons in decorators. Fixed #1315: Extra newline before comment with -n + --fss. Fixed #1192: -k or --keep-direct-and-as-imports option has been deprecated as it is now always on. Formatting changes implied: Fixed #1280: rewrite of as imports changes the behavior of the imports. 5.0.9 July 11, 2020 Fixed #1301: Import headings in nested sections leads to check errors 5.0.8 July 11, 2020 Fixed #1277 & #1278: New line detection issues on Windows. Fixed #1294: Fix bundled git hook. 5.0.7 July 9, 2020 Fixed #1306: unexpected --diff behavior. Fixed #1279: Fixed NOQA comment regression. 5.0.6 July 8, 2020 Fixed #1302: comments and --trailing-comma can generate invalid code. Fixed #1293: extra new line in indented imports, when immediately followed by a comment. Fixed #1304: isort 5 no longer recognises sre_parse as a stdlib module. Fixed #1300: add_imports moves comments following import section. Fixed #1276: Fix a bug that creates only one line after triple quotes. 5.0.5 July 7, 2020 Fixed #1285: packaging issue with bundling tests via poetry. Fixed #1284: Regression when sorting .pyi files from CLI using black profile. Fixed #1275 & #1283: Blank line after docstring removed. Fixed #1298: CLI Help out of date with isort 5. Fixed #1290: Unecessary blank lines above nested imports when import comments turned on. Fixed #1297: Usage of --add-imports alongside --check is broken. Fixed #1289: Stream usage no longer auto picking up config file from current working directory. Fixed #1296: Force_single_line setting removes immediately following comment line. Fixed #1295: ensure_newline_before_comments doesnt work with force_sort_within_sections . Setting not_skip will no longer immediately fail but instead give user a warning and direct to upgrade docs. 5.0.4 July 6, 2020 Fixed #1264: a regression with comment handling and force_sort_within_sections config option Added warning for deprecated CLI flags and linked to upgrade guide. 5.0.3 - July 4, 2020 Fixed setup.py command incorrectly passing check=True as a configuration parameter (see: https://github.com/pycqa/isort/issues/1258) Fixed missing patch version Fixed issue #1253: Atomic fails when passed in not readable output stream 5.0.2 - July 4, 2020 Ensured black profile was complete, adding missing line_length definition. 5.0.1 - July 4, 2020 Fixed a runtime error in a vendored dependency (toml). 5.0.0 Penny - July 4, 2020 Breaking changes: isort now requires Python 3.6+ to run but continues to support formatting on ALL versions of python including Python 2 code. isort deprecates official support for Python 3.4, removing modules only in this release from known_standard_library: user Config files are no longer composed on-top of each-other. Instead the first config file found is used. Since there is no longer composition negative form settings (such as --dont-skip or it's config file variant not_skip ) are no longer required and have been removed. Two-letter shortened setting names (like ac for atomic ) now require two dashes to avoid ambiguity: --ac . For consistency with other tools -v now is shorthand for verbose and -V is shorthand for version. See Issue: #1067. length_sort_{section_name} config usage has been deprecated. Instead length_sort_sections list can be used to specify a list of sections that need to be length sorted. safety_excludes and unsafe have been deprecated Config now includes as default full set of safety directories defined by safety excludes. --recursive option has been removed. Directories passed in are now automatically sorted recursive. --apply option has been removed as it is the default behaviour. isort now does nothing, beyond giving instructions and exiting status code 0, when ran with no arguments. a new --interactive flag has been added to enable the old style behaviour. isort now works on contiguous sections of imports, instead of one whole file at a time. ~~isort now formats all nested \"as\" imports in the \"from\" form. import x.y as a becomes from x import y as a .~~ NOTE: This was undone in version 5.1.0 due to feedback it caused issues with some project conventions. keep_direct_and_as_imports option now defaults to True . appdirs is no longer supported. Unless manually specified, config should be project config only. toml is now installed as a vendorized module, meaning pyproject.toml based config is always supported. Completely new Python API, old version is removed and no longer accessible. New module placement logic and module fully replaces old finders. Old approach is still available via --old-finders . Internal: isort now utilizes mypy and typing to filter out typing related issues before deployment. isort now utilizes black internally to ensure more consistent formatting. profile support for common project types (black, django, google, etc) Much much more. There is some difficulty in fully capturing the extent of changes in this release - just because of how all encompassing the release is. See: Github Issues for more. 4.3.21 - June 25, 2019 - hot fix release Fixed issue #957 - Long aliases and use_parentheses generates invalid syntax 4.3.20 - May 14, 2019 - hot fix release Fixed issue #948 - Pipe redirection broken on Python2.7 4.3.19 - May 12, 2019 - hot fix release Fixed issue #942 - correctly handle pyi (Python Template Files) to match black output 4.3.18 - May 1, 2019 - hot fix release Fixed an issue with parsing files that contain unicode characters in Python 2 Fixed issue #924 - Pulling in pip internals causes depreciation warning Fixed issue #938 - Providing a way to filter explicitly passed in files via configuration settings ( --filter-files ) Improved interoperability with toml configuration files 4.3.17 - April 7, 2019 - hot fix release Fixed issue #905 & #919: Import section headers behaving strangely 4.3.16 - March 23, 2019 - hot fix release Fixed issue #909 - skip and skip-glob are not enforced when using settings-path. Fixed issue #907 - appdirs optional requirement does not correctly specify version Fixed issue #902 - Too broad warning about missing toml package Fixed issue #778 - remove user from known standard library as it's no longer in any supported Python version. 4.3.15 - March 10, 2019 - hot fix release Fixed a regression with handling streaming input from pipes (Issue #895) Fixed handling of \\x0c whitespace character (Issue #811) Improved CLI documentation 4.3.14 - March 9, 2019 - hot fix release Fixed a regression with /directory/ .py style patterns 4.3.13 - March 8, 2019 - hot fix release Fixed the inability to accurately determine import section when a mix of conda and virtual environments are used. Fixed some output being printed even when --quiet mode is enabled. Fixed issue #890 interoperability with PyCharm by allowing case sensitive non type grouped sorting. Fixed issue #889 under some circumstances isort will incorrectly add a new line at the beginning of a file. Fixed issue #885 many files not being skipped according to set skip settings. Fixed issue #842 streaming encoding improvements. 4.3.12 - March 6, 2019 - hot fix release Fix error caused when virtual environment not detected 4.3.11 - March 6, 2019 - hot fix release Fixed issue #876: confused by symlinks pointing to virtualenv gives FIRSTPARTY not THIRDPARTY Fixed issue #873: current version skips every file on travis Additional caching to reduce performance regression introduced in 4.3.5 4.3.10 - March 2, 2019 - hot fix release Fixed Windows incompatibilities (Issue #835) Fixed relative import sorting bug (Issue #417) Fixed \"no_lines_before\" to also be respected from previous empty sections. Fixed slow-down introduced by finders mechanism by adding a LRU cache (issue #848) Fixed issue #842 default encoding not-set in Python2 Restored Windows automated testing Added Mac automated testing 4.3.9 - February 25, 2019 - hot fix release Fixed a bug that led to an incompatibility with black: #831 4.3.8 - February 25, 2019 - hot fix release Fixed a bug that led to the recursive option not always been available from the command line. 4.3.7 - February 25, 2019 - hot fix release Expands the finder failsafe to occur on the creation of the finder objects. 4.3.6 - February 24, 2019 - hot fix release Fixes a fatal error that occurs if a single finder throws an exception. Important as we add more finders that utilize third party libraries. 4.3.5 - February 24, 2019 - last Python 2.7 Maintenance Release This is the final Python 2.x release of isort, and includes the following major changes: Potentially Interface Breaking: - The -r option for removing imports has been renamed -rm to avoid accidental deletions and confusion with the -rc recursive option. - __init__.py has been removed from the default ignore list. The default ignore list is now empty - with all items needing to be explicitly ignored. - Isort will now by default ignore .tox / venv folders in an effort to be \"safe\". You can disable this behaviour by setting the \"--unsafe\" flag, this is separate from any skip or not skip rules you may have in place. - Isort now allows for files missing closing newlines in whitespace check - distutils support has been removed to simplify setup.py New: - Official Python 3.7 Compatibility. - Support for using requirements files to auto determine third-paty section if pipreqs & requirementslib are installed. - Added support for using pyproject.toml if toml is installed. - Added support for XDG_HOME if appdirs is installed. - An option has been added to enable ignoring trailing comments ('ignore_comments') defaulting to False. - Added support to enable line length sorting for only specific sections - Added a correctly_sorted property on the SortsImport to enable more intuitive programmatic checking. Fixes: - Improved black compatibility. - Isort will now detect files in the CWD as first-party. - Fixed several cases where '-ns' or 'not_skip' was being incorrectly ignored. - Fixed sorting of relative path imports ('.', '..', '...', etc). - Fixed bugs caused by a failure to maintain order when loading iterables from config files. - Correctly handle CPython compiled imports and others that need EXT_SUFFIX to correctly identify. - Fixed handling of Symbolic Links to follow them when walking the path. - Fixed handling of relative known_paths. - Fixed lack of access to all wrap modes from the CLI. - Fixed handling of FIFO files. - Fixed a bug that could result in multiple imports being inserted on the same line. 4.3.4 - February 12, 2018 - hotfix release Fixed issue #671: isort is corrupting CRLF files 4.3.3 - Feburary 5, 2018 - hotfix release Fixed issue #665: Tabs turned into single spaces 4.3.2 - Feburary 4, 2018 - hotfix release Fixed issue #651: Add imports option is broken Fixed issue #662: An error generated by rewriting .imports to . imoprts 4.3.1 - Feburary 2, 2018 - hotfix release Fixed setup.py errors Fixed issue #654: Trailing comma count error Fixed issue #650: Wrong error message displayed 4.3.0 - January 31, 2018 Fixed #557: force_alphabetical_sort and force_sort_within_sections can now be utilized together without extra new lines Fix case-sensitive path existence check in Mac OS X Added --no-lines-before for more granular control over section output Fixed #493: Unwanted conversion to Windows line endings Fixed #590: Import as mucks with alphabetical sorting Implemented --version-number to retrieve just the version number without the isort logo Breaking changes Python 2.7+ only (dropped 2.6) allowing various code simplifications and improvements. 4.2.15 - June 6, 2017 - hotfix release IMPORTANT NOTE: This will be the last release with Python 2.6 support, subsequent releases will be 2.7+ only - Fixed certain one line imports not being successfully wrapped 4.2.14 - June 5, 2017 - hotfix release Fixed #559 & #565: Added missing standard library imports 4.2.13 - June 2, 2017 - hotfix release Fixed #553: Check only and --diff now work together again 4.2.12 - June 1, 2017 - hotfix release Fixed wheel distribution bug 4.2.11 - June 1, 2017 - hotfix release Fixed #546: Can't select y/n/c after latest update Fixed #545: Incorrectly moves future imports above encoding comments 4.2.9 - June 1, 2017 - hotfix release Fixed #428: Check only modifies sorting Fixed #540: Not correctly identifying stdlib modules 4.2.8 - May 31, 2017 Added --virtual-env switch command line option Added --enforce-whitespace option to go along with --check-only for more exact checks (issue #423) Fixed imports with a tailing '\\' and no space in-between getting removed (issue #425) Fixed issue #299: long lines occasionally not wrapped Fixed issue #432: No longer add import inside class when class starts at top of file after encoding comment Fixed issue #440: Added missing --use-parentheses option to command line tool and documentation Fixed issue #496: import* imports now get successfully identified and reformatted instead of deleted Fixed issue #491: Non ending parentheses withing single line comments no longer cause formatting issues Fixed issue #471: Imports that wrap the maximum line length and contain comments on the last line are no longer rendered incorrectly Fixed issue #436: Force sort within section no longer rearranges comments Fixed issue #473: Force_to_top and force_sort_within_sections now work together Fixed issue #484 & #472: Consistent output with imports of same spelling but different case Fixed issue #433: No longer incorrectly add an extra new-line when comment between imports and function definition Fixed issue #419: Path specification for skipped paths is not Unix/Windows inter-operable. Breaking Changes: Fixed issue #511: All command line options with an underscore, have had the underscore replaced with a dash for consistency. This effects: multi-line, add-import, remove-import, force-adds, --force-single-line-imports, and length-sort. Replaced the --enforce-whitespace option with --ignore-whitespace to restore original behavior of strict whitespace by default 4.2.5 Fixed an issue that caused modules to inccorectly be matched as thirdparty when they simply had src in the leading path, even if they weren't withing $VIRTUALENV/src #414 4.2.4 Fixed an issue that caused module that contained functions before doc strings, to incorrectly place imports Fixed regression in how force_alphabetical_sort was being interpretted (issue #409) Fixed stray print statement printing skipped files (issue #411) Added option for forcing imports into a single bucket: no_sections Added option for new lines between import types (from, straight): lines_between_sections 4.2.3 Fixed a large number of priority bugs - bug fix only release 4.2.2 Give an error message when isort is unable to determine where to place a module Allow imports to be sorted by module, independent of import_type, when force_sort_within_sections option is set Fixed an issue that caused Python files with 2 top comments not to be sorted 4.2.1 Hot fix release to fix code error when skipping globs 4.2.0 Added option \"NOQA\" Do not wrap lines, but add a noqa statement at the end Added support for running isort recursively, simply with a standalone isort command Added support to run isort library as a module Added compatibility for Python 3.5 Fixed performance issue (#338) when running on project with lots of skipped directories Fixed issue #328: extra new can occasionally occur when using alphabetical-only sort Fixed custom sections parsing from config file (unicode string -> list) Updated pylama extension to the correct entry point Skip files even when file_contents is provided if they are explicitly in skip list Removed always showing isort banner, keeping it for when the version is requested, verbose is used, or show_logo setting is set. 4.1.2 Fixed issue #323: Accidental default configuration change introduced 4.1.1 Added support for partial file match skips (thanks to @Amwam) Added support for --quiet option to only show errors when running isort Fixed issue #316: isort added new lines incorrectly when a top-of line comment is present 4.1.0 Started keeping a log of all changes between releases Added the isort logo to the command line interface Added example usage gif to README Implemented issue #292: skip setting now supports glob patterns Implemented issue #271: Add option to sort imports purely alphabetically Implemented issue #301: Readme is now natively in RST format, making it easier for Python tooling to pick up Implemented pylama isort extension Fixed issue #260: # encoding lines at the top of the file are now correctly supported Fixed issue #284: Sticky comments above first import are now supported Fixed issue #310: Ensure comments don't get duplicated when reformatting imports Fixed issue #289: Sections order not being respected Fixed issue #296: Made it more clear how to set arguments more then once 4.0.0 Removed all external dependencies","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"NOTE: isort follows the semver versioning standard. Find out more about isort's release policy here .","title":"Changelog"},{"location":"CHANGELOG/#580-tbd","text":"Fixed #1631: as import comments can in some cases be duplicated. Implemented #1648: Export MyPY type hints. Implemented #1641: Identified import statements now return runnable code. Implemented #1661: Added \"wemake\" profile.","title":"5.8.0 TBD"},{"location":"CHANGELOG/#570-december-30th-2020","text":"Fixed #1612: In rare circumstances an extra comma is added after import and before comment. Fixed #1593: isort encounters bug in Python 3.6.0. Implemented #1596: Provide ways for extension formatting and file paths to be specified when using streaming input from CLI. Implemented #1583: Ability to output and diff within a single API call to isort.file . Implemented #1562, #1592 & #1593: Better more useful fatal error messages. Implemented #1575: Support for automatically fixing mixed indentation of import sections. Implemented #1582: Added a CLI option for skipping symlinks. Implemented #1603: Support for disabling float_to_top from the command line. Implemented #1604: Allow toggling section comments on and off for indented import sections.","title":"5.7.0 December 30th 2020"},{"location":"CHANGELOG/#564-october-12-2020","text":"Fixed #1556: Empty line added between imports that should be skipped.","title":"5.6.4 October 12, 2020"},{"location":"CHANGELOG/#563-october-11-2020","text":"Improved packaging of test files alongside source distribution (see: https://github.com/PyCQA/isort/pull/1555).","title":"5.6.3 October 11, 2020"},{"location":"CHANGELOG/#562-october-10-2020","text":"Fixed #1548: On rare occasions an unecessary empty line can be added when an import is marked as skipped. Fixed #1542: Bug in VERTICAL_PREFIX_FROM_MODULE_IMPORT wrap mode. Fixed #1552: Pylama test dependent on source layout.","title":"5.6.2 October 10, 2020"},{"location":"CHANGELOG/#goal-zero-tickets-related-to-aspirational-goal-of-achieving-0-regressions-for-remaining-500-lifespan","text":"Zope added to integration test suite Additional testing of CLI (simulate unseekable streams)","title":"Goal Zero: (Tickets related to aspirational goal of achieving 0 regressions for remaining 5.0.0 lifespan):"},{"location":"CHANGELOG/#561-hotfix-october-8-2020","text":"Fixed #1546: Unstable (non-idempotent) behavior with certain src trees.","title":"5.6.1 [Hotfix] October 8, 2020"},{"location":"CHANGELOG/#560-october-7-2020","text":"Implemented #1433: Provide helpful feedback in case a custom config file is specified without a configuration. Implemented #1494: Default to sorting imports within .pxd files. Implemented #1502: Improved float-to-top behavior when there is an existing import section present at top-of-file. Implemented #1511: Support for easily seeing all files isort will be ran against using isort . --show-files . Implemented #1487: Improved handling of encoding errors. Improved handling of unsupported configuration option errors (see #1475). Fixed #1463: Better interactive documentation for future option. Fixed #1461: Quiet config option not respected by file API in some circumstances. Fixed #1482: pylama integration is not working correctly out-of-the-box. Fixed #1492: --check does not work with stdin source. Fixed #1499: isort gets confused by single line, multi-line style comments when using float-to-top. Fixed #1525: Some warnings can't be disabled with --quiet. Fixed #1523: in rare cases isort can ignore direct from import if as import is also on same line.","title":"5.6.0 October 7, 2020"},{"location":"CHANGELOG/#potentially-breaking-changes","text":"Implemented #1540: Officially support Python 3.9 stdlib imports by default. Fixed #1443: Incorrect third vs first party categorization - namespace packages. Fixed #1486: \"Google\" profile is not quite Google style. Fixed \"PyCharm\" profile to always add 2 lines to be consistent with what PyCharm \"Optimize Imports\" does.","title":"Potentially breaking changes:"},{"location":"CHANGELOG/#goal-zero-tickets-related-to-aspirational-goal-of-achieving-0-regressions-for-remaining-500-lifespan_1","text":"Implemented #1472: Full testing of stdin CLI Options Added additional branch coverage. More projects added to integration test suite.","title":"Goal Zero: (Tickets related to aspirational goal of achieving 0 regressions for remaining 5.0.0 lifespan):"},{"location":"CHANGELOG/#555-hotfix-october-7-2020","text":"Fixed #1539: in extremely rare cases isort 5.5.4 introduces syntax error by removing closing paren.","title":"5.5.5 [Hotfix] October 7, 2020"},{"location":"CHANGELOG/#554-hotfix-september-29-2020","text":"Fixed #1507: in rare cases isort changes the content of multiline strings after a yield statement. Fixed #1505: Support case where known_SECTION points to a section not listed in sections.","title":"5.5.4 [Hotfix] September 29, 2020"},{"location":"CHANGELOG/#553-hotfix-september-20-2020","text":"Fixed #1488: in rare cases isort can mangle yield from or raise from statements.","title":"5.5.3 [Hotfix] September 20, 2020"},{"location":"CHANGELOG/#552-hotfix-september-9-2020","text":"Fixed #1469: --diff option is ignored when input is from stdin.","title":"5.5.2 [Hotfix] September 9, 2020"},{"location":"CHANGELOG/#551-september-4-2020","text":"Fixed #1454: Ensure indented import sections with import heading and a preceding comment don't cause import sorting loops. Fixed #1453: isort error when float to top on almost empty file. Fixed #1456 and #1415: noqa comment moved to where flake8 cant see it. Fixed #1460: .svn missing from default ignore list.","title":"5.5.1 September 4, 2020"},{"location":"CHANGELOG/#550-september-3-2020","text":"Fixed #1398: isort: off comment doesn't work, if it's the top comment in the file. Fixed #1395: reverse_relative setting doesn't have any effect when combined with force_sort_within_sections. Fixed #1399: --skip can error in the case of projects that contain recursive symlinks. Fixed #1389: ensure_newline_before_comments doesn't work if comment is at top of section and sections don't have lines between them. Fixed #1396: comments in imports with \";\" can keep isort from recognizing import line. Fixed #1380: As imports removed when combine_star is set. Fixed #1382: --float-to-top has no effect if no import is already at the top. Fixed #1420: isort never settles on module docstring + add import. Fixed #1421: Error raised when repo contains circular symlinks. Fixed #1427: noqa comment is moved from star import to constant import. Fixed #1444 & 1445: Incorrect placement of import additions. Fixed #1447: isort5 throws error when stdin used on Windows with deprecated args. Implemented #1397: Added support for specifying config file when using git hook (thanks @diseraluca!). Implemented #1405: Added support for coloring diff output. Implemented #1434: New multi-line grid mode without parentheses.","title":"5.5.0 September 3, 2020"},{"location":"CHANGELOG/#goal-zero-tickets-related-to-aspirational-goal-of-achieving-0-regressions-for-remaining-500-lifespan_2","text":"Implemented #1392: Extensive profile testing. Implemented #1393: Proprety based testing applied to code snippets. Implemented #1391: Create automated integration test that includes full code base of largest OpenSource isort users.","title":"Goal Zero (Tickets related to aspirational goal of achieving 0 regressions for remaining 5.0.0 lifespan):"},{"location":"CHANGELOG/#potentially-breaking-changes_1","text":"Fixed #1429: --check doesn't print to stderr as the documentation says. This means if you were looking for ERROR: messages for files that contain incorrect imports within stdout you will now need to look in stderr.","title":"Potentially breaking changes:"},{"location":"CHANGELOG/#542-aug-14-2020","text":"Fixed #1383: Known other does not work anymore with .editorconfig. Fixed: Regression in first known party path expansion.","title":"5.4.2 Aug 14, 2020"},{"location":"CHANGELOG/#541-hotfix-aug-13-2020","text":"Fixed #1381: --combine-as loses # noqa in different circumstances.","title":"5.4.1 [Hotfix] Aug 13, 2020"},{"location":"CHANGELOG/#540-aug-12-2020","text":"Implemented #1373: support for length sort only of direct (AKA straight) imports. Fixed #1321: --combine-as loses # noqa. Fixed #1375: --dont-order-by-type CLI broken.","title":"5.4.0 Aug 12, 2020"},{"location":"CHANGELOG/#532-hotfix-aug-7-2020","text":"Fixed incorrect warning code (W503->W0503).","title":"5.3.2 [Hotfix] Aug 7, 2020"},{"location":"CHANGELOG/#531-aug-7-2020","text":"Improve upgrade warnings to be less noisy and point to error codes for easy interoperability with Visual Studio Code (see: #1363).","title":"5.3.1 Aug 7, 2020"},{"location":"CHANGELOG/#530-aug-4-2020","text":"Implemented ability to treat all or select comments as code (issue #1357) Implemented ability to use different configs for different file extensions (issue #1162) Implemented ability to specify the types of imports (issue #1181) Implemented ability to dedup import headings (issue #953) Added experimental support for sorting literals (issue #1358) Added experimental support for sorting and deduping groupings of assignments. Improved handling of deprecated single line variables for usage with Visual Studio Code (issue #1363) Improved handling of mixed newline forms within same source file. Improved error handling for known sections. Improved API consistency, returning a boolean value for all modification API calls to indicate if changes were made. Fixed #1366: spurious errors when combining skip with --gitignore. Fixed #1359: --skip-gitignore does not honor ignored symlink","title":"5.3.0 Aug 4, 2020"},{"location":"CHANGELOG/#internal-development","text":"Initial hypothesmith powered test to help catch unexpected syntax parsing and output errors (thanks @Zac-HD!)","title":"Internal Development:"},{"location":"CHANGELOG/#522-july-30-2020","text":"Fixed #1356: return status when arguments are passed in without files or a content stream.","title":"5.2.2 July 30, 2020"},{"location":"CHANGELOG/#521-july-28-2020","text":"Update precommit to default to filtering files that are defined in skip. Improved relative path detection for skip config usage. Added recursive symbolic link protection. Implemented #1177: Support for color output using --color . Implemented recursive symlink detection support.","title":"5.2.1 July 28, 2020"},{"location":"CHANGELOG/#520-july-27-2020","text":"Implemented #1335: Official API for diff capturing. Implemented #1331: Warn when sections don't match up. Implemented #1261: By popular demand, filter_files can now be set in the config option. Implemented #960: Support for respecting git ignore via \"--gitignore\" or \"skip_gitignore=True\". Implemented #727: Ability to only add imports if existing imports exist. Implemented #970: Support for custom sharable isort profiles. Implemented #1214: Added support for git_hook lazy option (Thanks @sztamas!) Implemented #941: Added an additional multi_line_output mode for more compact formatting (Thanks @sztamas!) Implemented #1020: Option for LOCALFOLDER. Implemented #1353: Added support for output formatting plugins. # isort: split can now be used at the end of an import line. Fixed #1339: Extra indent is not preserved when isort:skip is used in nested imports. Fixed #1348: --diff works incorrectly with files that have CRLF line endings. Improved code repositories usage of pylint tags (#1350).","title":"5.2.0 July 27, 2020"},{"location":"CHANGELOG/#514-july-19-2020","text":"Fixed issue #1333: Use of wrap_length raises an exception about it not being lower or equal to line_length. Fixed issue #1330: Ensure stdout can be stubbed dynamically for show_unified_diff function.","title":"5.1.4 July 19, 2020"},{"location":"CHANGELOG/#513-july-18-2020","text":"Fixed issue #1329: Fix comments duplicated when --fass option is set.","title":"5.1.3 July 18, 2020"},{"location":"CHANGELOG/#512-july-17-2020","text":"Fixed issue #1219 / #1326: Comments not wrapped for long lines Fixed issue #1156: Bug related to isort:skip usage followed by a multiline comment block","title":"5.1.2 July 17, 2020"},{"location":"CHANGELOG/#511-july-15-2020","text":"Fixed issue #1322: Occasionally two extra newlines before comment with -n & --fss . Fixed issue #1189: --diff broken when reading from standard input.","title":"5.1.1 July 15, 2020"},{"location":"CHANGELOG/#510-july-14-2020","text":"isort now throws an exception if an invalid settings path is given (issue #1174). Implemented support for automatic redundant alias removal (issue #1281). Implemented experimental support for floating all imports to the top of a file (issue #1228) Fixed #1178: support for semicolons in decorators. Fixed #1315: Extra newline before comment with -n + --fss. Fixed #1192: -k or --keep-direct-and-as-imports option has been deprecated as it is now always on.","title":"5.1.0 July 14, 2020"},{"location":"CHANGELOG/#formatting-changes-implied","text":"Fixed #1280: rewrite of as imports changes the behavior of the imports.","title":"Formatting changes implied:"},{"location":"CHANGELOG/#509-july-11-2020","text":"Fixed #1301: Import headings in nested sections leads to check errors","title":"5.0.9 July 11, 2020"},{"location":"CHANGELOG/#508-july-11-2020","text":"Fixed #1277 & #1278: New line detection issues on Windows. Fixed #1294: Fix bundled git hook.","title":"5.0.8 July 11, 2020"},{"location":"CHANGELOG/#507-july-9-2020","text":"Fixed #1306: unexpected --diff behavior. Fixed #1279: Fixed NOQA comment regression.","title":"5.0.7 July 9, 2020"},{"location":"CHANGELOG/#506-july-8-2020","text":"Fixed #1302: comments and --trailing-comma can generate invalid code. Fixed #1293: extra new line in indented imports, when immediately followed by a comment. Fixed #1304: isort 5 no longer recognises sre_parse as a stdlib module. Fixed #1300: add_imports moves comments following import section. Fixed #1276: Fix a bug that creates only one line after triple quotes.","title":"5.0.6 July 8, 2020"},{"location":"CHANGELOG/#505-july-7-2020","text":"Fixed #1285: packaging issue with bundling tests via poetry. Fixed #1284: Regression when sorting .pyi files from CLI using black profile. Fixed #1275 & #1283: Blank line after docstring removed. Fixed #1298: CLI Help out of date with isort 5. Fixed #1290: Unecessary blank lines above nested imports when import comments turned on. Fixed #1297: Usage of --add-imports alongside --check is broken. Fixed #1289: Stream usage no longer auto picking up config file from current working directory. Fixed #1296: Force_single_line setting removes immediately following comment line. Fixed #1295: ensure_newline_before_comments doesnt work with force_sort_within_sections . Setting not_skip will no longer immediately fail but instead give user a warning and direct to upgrade docs.","title":"5.0.5 July 7, 2020"},{"location":"CHANGELOG/#504-july-6-2020","text":"Fixed #1264: a regression with comment handling and force_sort_within_sections config option Added warning for deprecated CLI flags and linked to upgrade guide.","title":"5.0.4 July 6, 2020"},{"location":"CHANGELOG/#503-july-4-2020","text":"Fixed setup.py command incorrectly passing check=True as a configuration parameter (see: https://github.com/pycqa/isort/issues/1258) Fixed missing patch version Fixed issue #1253: Atomic fails when passed in not readable output stream","title":"5.0.3 - July 4, 2020"},{"location":"CHANGELOG/#502-july-4-2020","text":"Ensured black profile was complete, adding missing line_length definition.","title":"5.0.2 - July 4, 2020"},{"location":"CHANGELOG/#501-july-4-2020","text":"Fixed a runtime error in a vendored dependency (toml).","title":"5.0.1 - July 4, 2020"},{"location":"CHANGELOG/#500-penny-july-4-2020","text":"Breaking changes: isort now requires Python 3.6+ to run but continues to support formatting on ALL versions of python including Python 2 code. isort deprecates official support for Python 3.4, removing modules only in this release from known_standard_library: user Config files are no longer composed on-top of each-other. Instead the first config file found is used. Since there is no longer composition negative form settings (such as --dont-skip or it's config file variant not_skip ) are no longer required and have been removed. Two-letter shortened setting names (like ac for atomic ) now require two dashes to avoid ambiguity: --ac . For consistency with other tools -v now is shorthand for verbose and -V is shorthand for version. See Issue: #1067. length_sort_{section_name} config usage has been deprecated. Instead length_sort_sections list can be used to specify a list of sections that need to be length sorted. safety_excludes and unsafe have been deprecated Config now includes as default full set of safety directories defined by safety excludes. --recursive option has been removed. Directories passed in are now automatically sorted recursive. --apply option has been removed as it is the default behaviour. isort now does nothing, beyond giving instructions and exiting status code 0, when ran with no arguments. a new --interactive flag has been added to enable the old style behaviour. isort now works on contiguous sections of imports, instead of one whole file at a time. ~~isort now formats all nested \"as\" imports in the \"from\" form. import x.y as a becomes from x import y as a .~~ NOTE: This was undone in version 5.1.0 due to feedback it caused issues with some project conventions. keep_direct_and_as_imports option now defaults to True . appdirs is no longer supported. Unless manually specified, config should be project config only. toml is now installed as a vendorized module, meaning pyproject.toml based config is always supported. Completely new Python API, old version is removed and no longer accessible. New module placement logic and module fully replaces old finders. Old approach is still available via --old-finders . Internal: isort now utilizes mypy and typing to filter out typing related issues before deployment. isort now utilizes black internally to ensure more consistent formatting. profile support for common project types (black, django, google, etc) Much much more. There is some difficulty in fully capturing the extent of changes in this release - just because of how all encompassing the release is. See: Github Issues for more.","title":"5.0.0 Penny - July 4, 2020"},{"location":"CHANGELOG/#4321-june-25-2019-hot-fix-release","text":"Fixed issue #957 - Long aliases and use_parentheses generates invalid syntax","title":"4.3.21 - June 25, 2019 - hot fix release"},{"location":"CHANGELOG/#4320-may-14-2019-hot-fix-release","text":"Fixed issue #948 - Pipe redirection broken on Python2.7","title":"4.3.20 - May 14, 2019 - hot fix release"},{"location":"CHANGELOG/#4319-may-12-2019-hot-fix-release","text":"Fixed issue #942 - correctly handle pyi (Python Template Files) to match black output","title":"4.3.19 - May 12, 2019 - hot fix release"},{"location":"CHANGELOG/#4318-may-1-2019-hot-fix-release","text":"Fixed an issue with parsing files that contain unicode characters in Python 2 Fixed issue #924 - Pulling in pip internals causes depreciation warning Fixed issue #938 - Providing a way to filter explicitly passed in files via configuration settings ( --filter-files ) Improved interoperability with toml configuration files","title":"4.3.18 - May 1, 2019 - hot fix release"},{"location":"CHANGELOG/#4317-april-7-2019-hot-fix-release","text":"Fixed issue #905 & #919: Import section headers behaving strangely","title":"4.3.17 - April 7, 2019 - hot fix release"},{"location":"CHANGELOG/#4316-march-23-2019-hot-fix-release","text":"Fixed issue #909 - skip and skip-glob are not enforced when using settings-path. Fixed issue #907 - appdirs optional requirement does not correctly specify version Fixed issue #902 - Too broad warning about missing toml package Fixed issue #778 - remove user from known standard library as it's no longer in any supported Python version.","title":"4.3.16 - March 23, 2019 - hot fix release"},{"location":"CHANGELOG/#4315-march-10-2019-hot-fix-release","text":"Fixed a regression with handling streaming input from pipes (Issue #895) Fixed handling of \\x0c whitespace character (Issue #811) Improved CLI documentation","title":"4.3.15 - March 10, 2019 - hot fix release"},{"location":"CHANGELOG/#4314-march-9-2019-hot-fix-release","text":"Fixed a regression with /directory/ .py style patterns","title":"4.3.14 - March 9, 2019 - hot fix release"},{"location":"CHANGELOG/#4313-march-8-2019-hot-fix-release","text":"Fixed the inability to accurately determine import section when a mix of conda and virtual environments are used. Fixed some output being printed even when --quiet mode is enabled. Fixed issue #890 interoperability with PyCharm by allowing case sensitive non type grouped sorting. Fixed issue #889 under some circumstances isort will incorrectly add a new line at the beginning of a file. Fixed issue #885 many files not being skipped according to set skip settings. Fixed issue #842 streaming encoding improvements.","title":"4.3.13 - March 8, 2019 - hot fix release"},{"location":"CHANGELOG/#4312-march-6-2019-hot-fix-release","text":"Fix error caused when virtual environment not detected","title":"4.3.12 - March 6, 2019 - hot fix release"},{"location":"CHANGELOG/#4311-march-6-2019-hot-fix-release","text":"Fixed issue #876: confused by symlinks pointing to virtualenv gives FIRSTPARTY not THIRDPARTY Fixed issue #873: current version skips every file on travis Additional caching to reduce performance regression introduced in 4.3.5","title":"4.3.11 - March 6, 2019 - hot fix release"},{"location":"CHANGELOG/#4310-march-2-2019-hot-fix-release","text":"Fixed Windows incompatibilities (Issue #835) Fixed relative import sorting bug (Issue #417) Fixed \"no_lines_before\" to also be respected from previous empty sections. Fixed slow-down introduced by finders mechanism by adding a LRU cache (issue #848) Fixed issue #842 default encoding not-set in Python2 Restored Windows automated testing Added Mac automated testing","title":"4.3.10 - March 2, 2019 - hot fix release"},{"location":"CHANGELOG/#439-february-25-2019-hot-fix-release","text":"Fixed a bug that led to an incompatibility with black: #831","title":"4.3.9 - February 25, 2019 - hot fix release"},{"location":"CHANGELOG/#438-february-25-2019-hot-fix-release","text":"Fixed a bug that led to the recursive option not always been available from the command line.","title":"4.3.8 - February 25, 2019 - hot fix release"},{"location":"CHANGELOG/#437-february-25-2019-hot-fix-release","text":"Expands the finder failsafe to occur on the creation of the finder objects.","title":"4.3.7 - February 25, 2019 - hot fix release"},{"location":"CHANGELOG/#436-february-24-2019-hot-fix-release","text":"Fixes a fatal error that occurs if a single finder throws an exception. Important as we add more finders that utilize third party libraries.","title":"4.3.6 - February 24, 2019 - hot fix release"},{"location":"CHANGELOG/#435-february-24-2019-last-python-27-maintenance-release","text":"This is the final Python 2.x release of isort, and includes the following major changes: Potentially Interface Breaking: - The -r option for removing imports has been renamed -rm to avoid accidental deletions and confusion with the -rc recursive option. - __init__.py has been removed from the default ignore list. The default ignore list is now empty - with all items needing to be explicitly ignored. - Isort will now by default ignore .tox / venv folders in an effort to be \"safe\". You can disable this behaviour by setting the \"--unsafe\" flag, this is separate from any skip or not skip rules you may have in place. - Isort now allows for files missing closing newlines in whitespace check - distutils support has been removed to simplify setup.py New: - Official Python 3.7 Compatibility. - Support for using requirements files to auto determine third-paty section if pipreqs & requirementslib are installed. - Added support for using pyproject.toml if toml is installed. - Added support for XDG_HOME if appdirs is installed. - An option has been added to enable ignoring trailing comments ('ignore_comments') defaulting to False. - Added support to enable line length sorting for only specific sections - Added a correctly_sorted property on the SortsImport to enable more intuitive programmatic checking. Fixes: - Improved black compatibility. - Isort will now detect files in the CWD as first-party. - Fixed several cases where '-ns' or 'not_skip' was being incorrectly ignored. - Fixed sorting of relative path imports ('.', '..', '...', etc). - Fixed bugs caused by a failure to maintain order when loading iterables from config files. - Correctly handle CPython compiled imports and others that need EXT_SUFFIX to correctly identify. - Fixed handling of Symbolic Links to follow them when walking the path. - Fixed handling of relative known_paths. - Fixed lack of access to all wrap modes from the CLI. - Fixed handling of FIFO files. - Fixed a bug that could result in multiple imports being inserted on the same line.","title":"4.3.5 - February 24, 2019 - last Python 2.7 Maintenance Release"},{"location":"CHANGELOG/#434-february-12-2018-hotfix-release","text":"Fixed issue #671: isort is corrupting CRLF files","title":"4.3.4 - February 12, 2018 - hotfix release"},{"location":"CHANGELOG/#433-feburary-5-2018-hotfix-release","text":"Fixed issue #665: Tabs turned into single spaces","title":"4.3.3 - Feburary 5, 2018 - hotfix release"},{"location":"CHANGELOG/#432-feburary-4-2018-hotfix-release","text":"Fixed issue #651: Add imports option is broken Fixed issue #662: An error generated by rewriting .imports to . imoprts","title":"4.3.2 - Feburary 4, 2018 - hotfix release"},{"location":"CHANGELOG/#431-feburary-2-2018-hotfix-release","text":"Fixed setup.py errors Fixed issue #654: Trailing comma count error Fixed issue #650: Wrong error message displayed","title":"4.3.1 - Feburary 2, 2018 - hotfix release"},{"location":"CHANGELOG/#430-january-31-2018","text":"Fixed #557: force_alphabetical_sort and force_sort_within_sections can now be utilized together without extra new lines Fix case-sensitive path existence check in Mac OS X Added --no-lines-before for more granular control over section output Fixed #493: Unwanted conversion to Windows line endings Fixed #590: Import as mucks with alphabetical sorting Implemented --version-number to retrieve just the version number without the isort logo Breaking changes Python 2.7+ only (dropped 2.6) allowing various code simplifications and improvements.","title":"4.3.0 - January 31, 2018"},{"location":"CHANGELOG/#4215-june-6-2017-hotfix-release","text":"IMPORTANT NOTE: This will be the last release with Python 2.6 support, subsequent releases will be 2.7+ only - Fixed certain one line imports not being successfully wrapped","title":"4.2.15 - June 6, 2017 - hotfix release"},{"location":"CHANGELOG/#4214-june-5-2017-hotfix-release","text":"Fixed #559 & #565: Added missing standard library imports","title":"4.2.14 - June 5, 2017 - hotfix release"},{"location":"CHANGELOG/#4213-june-2-2017-hotfix-release","text":"Fixed #553: Check only and --diff now work together again","title":"4.2.13 - June 2, 2017 - hotfix release"},{"location":"CHANGELOG/#4212-june-1-2017-hotfix-release","text":"Fixed wheel distribution bug","title":"4.2.12 - June 1, 2017 - hotfix release"},{"location":"CHANGELOG/#4211-june-1-2017-hotfix-release","text":"Fixed #546: Can't select y/n/c after latest update Fixed #545: Incorrectly moves future imports above encoding comments","title":"4.2.11 - June 1, 2017 - hotfix release"},{"location":"CHANGELOG/#429-june-1-2017-hotfix-release","text":"Fixed #428: Check only modifies sorting Fixed #540: Not correctly identifying stdlib modules","title":"4.2.9 - June 1, 2017 - hotfix release"},{"location":"CHANGELOG/#428-may-31-2017","text":"Added --virtual-env switch command line option Added --enforce-whitespace option to go along with --check-only for more exact checks (issue #423) Fixed imports with a tailing '\\' and no space in-between getting removed (issue #425) Fixed issue #299: long lines occasionally not wrapped Fixed issue #432: No longer add import inside class when class starts at top of file after encoding comment Fixed issue #440: Added missing --use-parentheses option to command line tool and documentation Fixed issue #496: import* imports now get successfully identified and reformatted instead of deleted Fixed issue #491: Non ending parentheses withing single line comments no longer cause formatting issues Fixed issue #471: Imports that wrap the maximum line length and contain comments on the last line are no longer rendered incorrectly Fixed issue #436: Force sort within section no longer rearranges comments Fixed issue #473: Force_to_top and force_sort_within_sections now work together Fixed issue #484 & #472: Consistent output with imports of same spelling but different case Fixed issue #433: No longer incorrectly add an extra new-line when comment between imports and function definition Fixed issue #419: Path specification for skipped paths is not Unix/Windows inter-operable. Breaking Changes: Fixed issue #511: All command line options with an underscore, have had the underscore replaced with a dash for consistency. This effects: multi-line, add-import, remove-import, force-adds, --force-single-line-imports, and length-sort. Replaced the --enforce-whitespace option with --ignore-whitespace to restore original behavior of strict whitespace by default","title":"4.2.8 - May 31, 2017"},{"location":"CHANGELOG/#425","text":"Fixed an issue that caused modules to inccorectly be matched as thirdparty when they simply had src in the leading path, even if they weren't withing $VIRTUALENV/src #414","title":"4.2.5"},{"location":"CHANGELOG/#424","text":"Fixed an issue that caused module that contained functions before doc strings, to incorrectly place imports Fixed regression in how force_alphabetical_sort was being interpretted (issue #409) Fixed stray print statement printing skipped files (issue #411) Added option for forcing imports into a single bucket: no_sections Added option for new lines between import types (from, straight): lines_between_sections","title":"4.2.4"},{"location":"CHANGELOG/#423","text":"Fixed a large number of priority bugs - bug fix only release","title":"4.2.3"},{"location":"CHANGELOG/#422","text":"Give an error message when isort is unable to determine where to place a module Allow imports to be sorted by module, independent of import_type, when force_sort_within_sections option is set Fixed an issue that caused Python files with 2 top comments not to be sorted","title":"4.2.2"},{"location":"CHANGELOG/#421","text":"Hot fix release to fix code error when skipping globs","title":"4.2.1"},{"location":"CHANGELOG/#420","text":"Added option \"NOQA\" Do not wrap lines, but add a noqa statement at the end Added support for running isort recursively, simply with a standalone isort command Added support to run isort library as a module Added compatibility for Python 3.5 Fixed performance issue (#338) when running on project with lots of skipped directories Fixed issue #328: extra new can occasionally occur when using alphabetical-only sort Fixed custom sections parsing from config file (unicode string -> list) Updated pylama extension to the correct entry point Skip files even when file_contents is provided if they are explicitly in skip list Removed always showing isort banner, keeping it for when the version is requested, verbose is used, or show_logo setting is set.","title":"4.2.0"},{"location":"CHANGELOG/#412","text":"Fixed issue #323: Accidental default configuration change introduced","title":"4.1.2"},{"location":"CHANGELOG/#411","text":"Added support for partial file match skips (thanks to @Amwam) Added support for --quiet option to only show errors when running isort Fixed issue #316: isort added new lines incorrectly when a top-of line comment is present","title":"4.1.1"},{"location":"CHANGELOG/#410","text":"Started keeping a log of all changes between releases Added the isort logo to the command line interface Added example usage gif to README Implemented issue #292: skip setting now supports glob patterns Implemented issue #271: Add option to sort imports purely alphabetically Implemented issue #301: Readme is now natively in RST format, making it easier for Python tooling to pick up Implemented pylama isort extension Fixed issue #260: # encoding lines at the top of the file are now correctly supported Fixed issue #284: Sticky comments above first import are now supported Fixed issue #310: Ensure comments don't get duplicated when reformatting imports Fixed issue #289: Sections order not being respected Fixed issue #296: Made it more clear how to set arguments more then once","title":"4.1.0"},{"location":"CHANGELOG/#400","text":"Removed all external dependencies","title":"4.0.0"},{"location":"docs/configuration/action_comments/","text":"Action Comments The most basic way to configure the flow of isort within a single file is action comments. These comments are picked up and interpreted by the isort parser during parsing. isort: skip_file Tells isort to skip the entire file. Example: # !/bin/python3 # isort: skip_file import os import sys ... Warning This should be placed as high in the file as reasonably possible. Since isort uses a streaming architecture, it may have already completed some work before it reaches the comment. Usually, this is okay - but can be confusing if --diff or any interactive options are used from the command line. isort: skip If placed on the same line as (or within the continuation of a) an import statement, isort will not sort this import. More specifically, it prevents the import statement from being recognized by isort as an import. In consequence, this line will be treated as code and be pushed down to below the import section of the file. Example: import b import a # isort: skip <- this will now stay below b Note It is recommended to where possible use # isort: off and # isort: on or # isort: split instead as the behavior is more explicit and predictable. isort: off Turns isort parsing off. Every line after an # isort: off statement will be passed along unchanged until an # isort: on comment or the end of the file. Example: import e import f # isort: off import b import a isort: on Turns isort parsing back on. This only makes sense if an # isort: off comment exists higher in the file! This allows you to have blocks of unsorted imports, around otherwise sorted ones. Example: import e import f # isort: off import b import a # isort: on import c import d isort: split Tells isort the current sort section is finished, and all future imports belong to a new sort grouping. Example: import e import f # isort: split import a import b import c import d You can also use it inline to keep an import from having imports above or below it swap position: import c import b # isort: split import a Tip isort split is exactly the same as placing an # isort: on immediately below an # isort: off","title":"Action Comments"},{"location":"docs/configuration/action_comments/#action-comments","text":"The most basic way to configure the flow of isort within a single file is action comments. These comments are picked up and interpreted by the isort parser during parsing.","title":"Action Comments"},{"location":"docs/configuration/action_comments/#isort-skip_file","text":"Tells isort to skip the entire file. Example: # !/bin/python3 # isort: skip_file import os import sys ... Warning This should be placed as high in the file as reasonably possible. Since isort uses a streaming architecture, it may have already completed some work before it reaches the comment. Usually, this is okay - but can be confusing if --diff or any interactive options are used from the command line.","title":"isort: skip_file"},{"location":"docs/configuration/action_comments/#isort-skip","text":"If placed on the same line as (or within the continuation of a) an import statement, isort will not sort this import. More specifically, it prevents the import statement from being recognized by isort as an import. In consequence, this line will be treated as code and be pushed down to below the import section of the file. Example: import b import a # isort: skip <- this will now stay below b Note It is recommended to where possible use # isort: off and # isort: on or # isort: split instead as the behavior is more explicit and predictable.","title":"isort: skip"},{"location":"docs/configuration/action_comments/#isort-off","text":"Turns isort parsing off. Every line after an # isort: off statement will be passed along unchanged until an # isort: on comment or the end of the file. Example: import e import f # isort: off import b import a","title":"isort: off"},{"location":"docs/configuration/action_comments/#isort-on","text":"Turns isort parsing back on. This only makes sense if an # isort: off comment exists higher in the file! This allows you to have blocks of unsorted imports, around otherwise sorted ones. Example: import e import f # isort: off import b import a # isort: on import c import d","title":"isort: on"},{"location":"docs/configuration/action_comments/#isort-split","text":"Tells isort the current sort section is finished, and all future imports belong to a new sort grouping. Example: import e import f # isort: split import a import b import c import d You can also use it inline to keep an import from having imports above or below it swap position: import c import b # isort: split import a Tip isort split is exactly the same as placing an # isort: on immediately below an # isort: off","title":"isort: split"},{"location":"docs/configuration/black_compatibility/","text":"Compatibility with black Compatibility with black is very important to the isort project and comes baked in starting with version 5. All that's required to use isort alongside black is to set the isort profile to \"black\". Using a config file (such as .isort.cfg) For projects that officially use both isort and black, we recommend setting the black profile in a config file at the root of your project's repository. This way independent to how users call isort (pre-commit, CLI, or editor integration) the black profile will automatically be applied. For instance, your pyproject.toml file would look something like [tool.isort] profile = \"black\" multi_line_output = 3 Read More about supported config files . CLI To use the profile option when calling isort directly from the commandline simply add the --profile black argument: isort --profile black . A demo of how this would look like in your .travis.yml language : python python : - \"3.6\" - \"3.7\" - \"3.8\" install : - pip install -r requirements-dev.txt - pip install isort black - pip install coveralls script : - pytest my-package - isort --profile black my-package - black --check --diff my-package after_success : - coveralls See built-in profiles for more profiles. Integration with pre-commit You can also set the profile directly when integrating isort within pre-commit. - repo : https://github.com/pycqa/isort rev : 5.6.4 hooks : - id : isort args : [ \"--profile\" , \"black\" , \"--filter-files\" ]","title":"Black Compatibility"},{"location":"docs/configuration/black_compatibility/#compatibility-with-black","text":"Compatibility with black is very important to the isort project and comes baked in starting with version 5. All that's required to use isort alongside black is to set the isort profile to \"black\".","title":"Compatibility with black"},{"location":"docs/configuration/black_compatibility/#using-a-config-file-such-as-isortcfg","text":"For projects that officially use both isort and black, we recommend setting the black profile in a config file at the root of your project's repository. This way independent to how users call isort (pre-commit, CLI, or editor integration) the black profile will automatically be applied. For instance, your pyproject.toml file would look something like [tool.isort] profile = \"black\" multi_line_output = 3 Read More about supported config files .","title":"Using a config file (such as .isort.cfg)"},{"location":"docs/configuration/black_compatibility/#cli","text":"To use the profile option when calling isort directly from the commandline simply add the --profile black argument: isort --profile black . A demo of how this would look like in your .travis.yml language : python python : - \"3.6\" - \"3.7\" - \"3.8\" install : - pip install -r requirements-dev.txt - pip install isort black - pip install coveralls script : - pytest my-package - isort --profile black my-package - black --check --diff my-package after_success : - coveralls See built-in profiles for more profiles.","title":"CLI"},{"location":"docs/configuration/black_compatibility/#integration-with-pre-commit","text":"You can also set the profile directly when integrating isort within pre-commit. - repo : https://github.com/pycqa/isort rev : 5.6.4 hooks : - id : isort args : [ \"--profile\" , \"black\" , \"--filter-files\" ]","title":"Integration with pre-commit"},{"location":"docs/configuration/config_files/","text":"Supported Config Files isort supports various standard config formats to allow customizations to be integrated into any project quickly. When applying configurations, isort looks for the closest supported config file, in the order files are listed below. You can manually specify the settings file or path by setting --settings-path from the command-line. Otherwise, isort will traverse up to 25 parent directories until it finds a suitable config file. Note that isort will not leave a git or Mercurial repository (checking for a .git or .hg directory). As soon as it finds a file, it stops looking. The config file search is done relative to the current directory if isort . or a file stream is passed in, or relative to the first path passed in if multiple paths are passed in. isort never merges config files together due to the confusion it can cause. Tip You can always introspect the configuration settings isort determined, and find out which config file it picked up, by running isort . --show-config .isort.cfg [preferred format] The first place isort will look for settings is in dedicated .isort.cfg files. The advantage of using this kind of config file, is that it is explicitly for isort and follows a well understood format. The downside, is that it means one more config file in your project when you may already have several polluting your file hierarchy. An example a config from the isort project itself: [settings] profile = hug src_paths = isort,test pyproject.toml [preferred format] The second place isort will look, and an equally excellent choice to place your configuration, is within a pyproject.toml file. The advantage of using this config file, is that it is quickly becoming a standard place to configure all Python tools. This means other developers will know to look here and you will keep your projects root nice and tidy. The only disadvantage is that other tools you use might not yet support this format, negating the cleanliness. [tool.isort] profile = \"hug\" src_paths = [\"isort\", \"test\"] setup.cfg setup.cfg can be thought of as the precursor to pyproject.toml . While isort and newer tools are increasingly moving to pyproject.toml, if you rely on many tools that use this standard it can be a natural fit to put your isort config there as well. [isort] profile = hug src_paths = isort,test tox.ini tox is a tool commonly used in the Python community to specify multiple testing environments. Because isort verification is commonly ran as a testing step, some prefer to place the isort config inside of the tox.ini file. [isort] .editorconfig Finally, isort will look for a .editorconfig configuration with settings for Python source files. EditorConfig is a project to enable specifying a configuration for text editing behaviour once, allowing multiple command line tools and text editors to pick it up. Since isort cares about a lot of the same settings as a text-editor (like line-length) it makes sense for it to look within these files as well. root = true [ * . py ] profile = hug indent_style = space indent_size = 4 skip = build ,. tox , venv src_paths = isort , test Custom config files Optionally, you can also create a config file with a custom name, or directly point isort to a config file that falls lower in the priority order, by using --settings-file . This can be useful, for instance, if you want to have one configuration for .py files and another for .pyx - while keeping the config files at the root of your repository. Tip Custom config files should place their configuration options inside an [isort] section and never a generic [settings] section. This is because isort can't know for sure how other tools are utilizing the config file.","title":"Config Files"},{"location":"docs/configuration/config_files/#supported-config-files","text":"isort supports various standard config formats to allow customizations to be integrated into any project quickly. When applying configurations, isort looks for the closest supported config file, in the order files are listed below. You can manually specify the settings file or path by setting --settings-path from the command-line. Otherwise, isort will traverse up to 25 parent directories until it finds a suitable config file. Note that isort will not leave a git or Mercurial repository (checking for a .git or .hg directory). As soon as it finds a file, it stops looking. The config file search is done relative to the current directory if isort . or a file stream is passed in, or relative to the first path passed in if multiple paths are passed in. isort never merges config files together due to the confusion it can cause. Tip You can always introspect the configuration settings isort determined, and find out which config file it picked up, by running isort . --show-config","title":"Supported Config Files"},{"location":"docs/configuration/config_files/#isortcfg-preferred-format","text":"The first place isort will look for settings is in dedicated .isort.cfg files. The advantage of using this kind of config file, is that it is explicitly for isort and follows a well understood format. The downside, is that it means one more config file in your project when you may already have several polluting your file hierarchy. An example a config from the isort project itself: [settings] profile = hug src_paths = isort,test","title":".isort.cfg [preferred format]"},{"location":"docs/configuration/config_files/#pyprojecttoml-preferred-format","text":"The second place isort will look, and an equally excellent choice to place your configuration, is within a pyproject.toml file. The advantage of using this config file, is that it is quickly becoming a standard place to configure all Python tools. This means other developers will know to look here and you will keep your projects root nice and tidy. The only disadvantage is that other tools you use might not yet support this format, negating the cleanliness. [tool.isort] profile = \"hug\" src_paths = [\"isort\", \"test\"]","title":"pyproject.toml [preferred format]"},{"location":"docs/configuration/config_files/#setupcfg","text":"setup.cfg can be thought of as the precursor to pyproject.toml . While isort and newer tools are increasingly moving to pyproject.toml, if you rely on many tools that use this standard it can be a natural fit to put your isort config there as well. [isort] profile = hug src_paths = isort,test","title":"setup.cfg"},{"location":"docs/configuration/config_files/#toxini","text":"tox is a tool commonly used in the Python community to specify multiple testing environments. Because isort verification is commonly ran as a testing step, some prefer to place the isort config inside of the tox.ini file. [isort]","title":"tox.ini"},{"location":"docs/configuration/config_files/#editorconfig","text":"Finally, isort will look for a .editorconfig configuration with settings for Python source files. EditorConfig is a project to enable specifying a configuration for text editing behaviour once, allowing multiple command line tools and text editors to pick it up. Since isort cares about a lot of the same settings as a text-editor (like line-length) it makes sense for it to look within these files as well. root = true [ * . py ] profile = hug indent_style = space indent_size = 4 skip = build ,. tox , venv src_paths = isort , test","title":".editorconfig"},{"location":"docs/configuration/config_files/#custom-config-files","text":"Optionally, you can also create a config file with a custom name, or directly point isort to a config file that falls lower in the priority order, by using --settings-file . This can be useful, for instance, if you want to have one configuration for .py files and another for .pyx - while keeping the config files at the root of your repository. Tip Custom config files should place their configuration options inside an [isort] section and never a generic [settings] section. This is because isort can't know for sure how other tools are utilizing the config file.","title":"Custom config files"},{"location":"docs/configuration/custom_sections_and_ordering/","text":"Custom Sections and Ordering isort provides lots of features to enable configuring how it sections imports and how it sorts imports within those sections. You can change the section order with sections option from the default of: FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER to your preference (if defined, omitting a default section may cause errors): sections = FUTURE,STDLIB,FIRSTPARTY,THIRDPARTY,LOCALFOLDER You also can define your own sections and their order. Example: known_django = django known_pandas = pandas,numpy sections = FUTURE,STDLIB,DJANGO,THIRDPARTY,PANDAS,FIRSTPARTY,LOCALFOLDER would create two new sections with the specified known modules. The no_lines_before option will prevent the listed sections from being split from the previous section by an empty line. Example: sections = FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER no_lines_before = LOCALFOLDER would produce a section with both FIRSTPARTY and LOCALFOLDER modules combined. IMPORTANT NOTE : It is very important to know when setting known sections that the naming does not directly map for historical reasons. For custom settings, the only difference is capitalization ( known_custom=custom VS sections=CUSTOM,... ) for all others reference the following mapping: known_standard_library : STANDARD_LIBRARY extra_standard_library : STANDARD_LIBRARY # Like known standard library but appends instead of replacing known_future_library : FUTURE known_first_party : FIRSTPARTY known_third_party : THIRDPARTY known_local_folder : LOCALFOLDER This will likely be changed in isort 6.0.0+ in a backwards compatible way. Auto-comment import sections Some projects prefer to have import sections uniquely titled to aid in identifying the sections quickly when visually scanning. isort can automate this as well. To do this simply set the import_heading_{section_name} setting for each section you wish to have auto commented - to the desired comment. For Example: import_heading_stdlib = Standard Library import_heading_firstparty = My Stuff Would lead to output looking like the following: # Standard Library import os import sys import django.settings # My Stuff import myproject.test Ordering by import length isort also makes it easy to sort your imports by length, simply by setting the length_sort option to True . This will result in the following output style: from evn.util import ( Pool , Dict , Options , Constant , DecayDict , UnexpectedCodePath , ) It is also possible to opt-in to sorting imports by length for only specific sections by using length_sort_ followed by the section name as a configuration item, e.g.: length_sort_stdlib=1 Controlling how isort sections from imports By default isort places straight ( import y ) imports above from imports ( from x import y ): import b from a import a # This will always appear below because it is a from import. However, if you prefer to keep strict alphabetical sorting you can set force sort within sections to true. Resulting in: from a import a # This will now appear at top because a appears in the alphabet before b import b You can even tell isort to always place from imports on top, instead of the default of placing them on bottom, using from first . from b import b # If from first is set to True, all from imports will be placed before non-from imports. import a","title":"Custom Sections And Ordering"},{"location":"docs/configuration/custom_sections_and_ordering/#custom-sections-and-ordering","text":"isort provides lots of features to enable configuring how it sections imports and how it sorts imports within those sections. You can change the section order with sections option from the default of: FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER to your preference (if defined, omitting a default section may cause errors): sections = FUTURE,STDLIB,FIRSTPARTY,THIRDPARTY,LOCALFOLDER You also can define your own sections and their order. Example: known_django = django known_pandas = pandas,numpy sections = FUTURE,STDLIB,DJANGO,THIRDPARTY,PANDAS,FIRSTPARTY,LOCALFOLDER would create two new sections with the specified known modules. The no_lines_before option will prevent the listed sections from being split from the previous section by an empty line. Example: sections = FUTURE,STDLIB,THIRDPARTY,FIRSTPARTY,LOCALFOLDER no_lines_before = LOCALFOLDER would produce a section with both FIRSTPARTY and LOCALFOLDER modules combined. IMPORTANT NOTE : It is very important to know when setting known sections that the naming does not directly map for historical reasons. For custom settings, the only difference is capitalization ( known_custom=custom VS sections=CUSTOM,... ) for all others reference the following mapping: known_standard_library : STANDARD_LIBRARY extra_standard_library : STANDARD_LIBRARY # Like known standard library but appends instead of replacing known_future_library : FUTURE known_first_party : FIRSTPARTY known_third_party : THIRDPARTY known_local_folder : LOCALFOLDER This will likely be changed in isort 6.0.0+ in a backwards compatible way.","title":"Custom Sections and Ordering"},{"location":"docs/configuration/custom_sections_and_ordering/#auto-comment-import-sections","text":"Some projects prefer to have import sections uniquely titled to aid in identifying the sections quickly when visually scanning. isort can automate this as well. To do this simply set the import_heading_{section_name} setting for each section you wish to have auto commented - to the desired comment. For Example: import_heading_stdlib = Standard Library import_heading_firstparty = My Stuff Would lead to output looking like the following: # Standard Library import os import sys import django.settings # My Stuff import myproject.test","title":"Auto-comment import sections"},{"location":"docs/configuration/custom_sections_and_ordering/#ordering-by-import-length","text":"isort also makes it easy to sort your imports by length, simply by setting the length_sort option to True . This will result in the following output style: from evn.util import ( Pool , Dict , Options , Constant , DecayDict , UnexpectedCodePath , ) It is also possible to opt-in to sorting imports by length for only specific sections by using length_sort_ followed by the section name as a configuration item, e.g.: length_sort_stdlib=1","title":"Ordering by import length"},{"location":"docs/configuration/custom_sections_and_ordering/#controlling-how-isort-sections-from-imports","text":"By default isort places straight ( import y ) imports above from imports ( from x import y ): import b from a import a # This will always appear below because it is a from import. However, if you prefer to keep strict alphabetical sorting you can set force sort within sections to true. Resulting in: from a import a # This will now appear at top because a appears in the alphabet before b import b You can even tell isort to always place from imports on top, instead of the default of placing them on bottom, using from first . from b import b # If from first is set to True, all from imports will be placed before non-from imports. import a","title":"Controlling how isort sections from imports"},{"location":"docs/configuration/github_action/","text":"Github Action isort provides an official Github Action that can be used as part of a CI/CD workflow to ensure a project's imports are properly sorted. The action can be found on the Github Actions Marketplace . Usage The python-isort plugin is designed to be run in combination with the checkout and setup-python actions. By default, it will run recursively from the root of the repository being linted and will exit with an error if the code is not properly sorted. Inputs isortVersion Optional. Version of isort to use. Defaults to latest version of isort . sortPaths Optional. List of paths to sort, relative to your project root. Defaults to . configuration Optional. isort configuration options to pass to the isort CLI. Defaults to --check-only --diff . requirementsFiles Optional. Paths to python requirements files to install before running isort. If multiple requirements files are provided, they should be separated by a space. If custom package installation is required, dependencies should be installed in a separate step before using this action. Tip It is important that the project's dependencies be installed before running isort so that third-party libraries are properly sorted. Outputs isort-result Output of the isort CLI. Example usage name : Run isort on : - push jobs : build : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.8 - uses : jamescurtin/isort-action@master with : requirementsFiles : \"requirements.txt requirements-test.txt\"","title":"Github Action"},{"location":"docs/configuration/github_action/#github-action","text":"isort provides an official Github Action that can be used as part of a CI/CD workflow to ensure a project's imports are properly sorted. The action can be found on the Github Actions Marketplace .","title":"Github Action"},{"location":"docs/configuration/github_action/#usage","text":"The python-isort plugin is designed to be run in combination with the checkout and setup-python actions. By default, it will run recursively from the root of the repository being linted and will exit with an error if the code is not properly sorted.","title":"Usage"},{"location":"docs/configuration/github_action/#inputs","text":"","title":"Inputs"},{"location":"docs/configuration/github_action/#isortversion","text":"Optional. Version of isort to use. Defaults to latest version of isort .","title":"isortVersion"},{"location":"docs/configuration/github_action/#sortpaths","text":"Optional. List of paths to sort, relative to your project root. Defaults to .","title":"sortPaths"},{"location":"docs/configuration/github_action/#configuration","text":"Optional. isort configuration options to pass to the isort CLI. Defaults to --check-only --diff .","title":"configuration"},{"location":"docs/configuration/github_action/#requirementsfiles","text":"Optional. Paths to python requirements files to install before running isort. If multiple requirements files are provided, they should be separated by a space. If custom package installation is required, dependencies should be installed in a separate step before using this action. Tip It is important that the project's dependencies be installed before running isort so that third-party libraries are properly sorted.","title":"requirementsFiles"},{"location":"docs/configuration/github_action/#outputs","text":"","title":"Outputs"},{"location":"docs/configuration/github_action/#isort-result","text":"Output of the isort CLI.","title":"isort-result"},{"location":"docs/configuration/github_action/#example-usage","text":"name : Run isort on : - push jobs : build : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.8 - uses : jamescurtin/isort-action@master with : requirementsFiles : \"requirements.txt requirements-test.txt\"","title":"Example usage"},{"location":"docs/configuration/multi_line_output_modes/","text":"Multi Line Output Modes This config option defines how from imports wrap when they extend past the line_length limit and has 12 possible settings: 0 - Grid from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 1 - Vertical from third_party import ( lib1 , lib2 , lib3 lib4 , lib5 , ... ) 2 - Hanging Indent from third_party import \\ lib1 , lib2 , lib3 , \\ lib4 , lib5 , lib6 3 - Vertical Hanging Indent from third_party import ( lib1 , lib2 , lib3 , lib4 , ) 4 - Hanging Grid from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 5 - Hanging Grid Grouped from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... ) 6 - Hanging Grid Grouped Same as Mode 5. Deprecated. 7 - NOQA from third_party import lib1 , lib2 , lib3 , ... # NOQA Alternatively, you can set force_single_line to True ( -sl on the command line) and every import will appear on its own line: from third_party import lib1 from third_party import lib2 from third_party import lib3 ... 8 - Vertical Hanging Indent Bracket Same as Mode 3 - Vertical Hanging Indent but the closing parentheses on the last line is indented. from third_party import ( lib1 , lib2 , lib3 , lib4 , ) 9 - Vertical Prefix From Module Import Starts a new line with the same from MODULE import prefix when lines are longer than the line length limit. from third_party import lib1 , lib2 , lib3 from third_party import lib4 , lib5 , lib6 10 - Hanging Indent With Parentheses Same as Mode 2 - Hanging Indent but uses parentheses instead of backslash for wrapping long lines. from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , lib6 ) 11 - Backslash Grid Same as Mode 0 - Grid but uses backslashes instead of parentheses to group imports. from third_party import lib1 , lib2 , lib3 , \\ lib4 , lib5","title":"Multi Line Output Modes"},{"location":"docs/configuration/multi_line_output_modes/#multi-line-output-modes","text":"This config option defines how from imports wrap when they extend past the line_length limit and has 12 possible settings:","title":"Multi Line Output Modes"},{"location":"docs/configuration/multi_line_output_modes/#0-grid","text":"from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... )","title":"0 - Grid"},{"location":"docs/configuration/multi_line_output_modes/#1-vertical","text":"from third_party import ( lib1 , lib2 , lib3 lib4 , lib5 , ... )","title":"1 - Vertical"},{"location":"docs/configuration/multi_line_output_modes/#2-hanging-indent","text":"from third_party import \\ lib1 , lib2 , lib3 , \\ lib4 , lib5 , lib6","title":"2 - Hanging Indent"},{"location":"docs/configuration/multi_line_output_modes/#3-vertical-hanging-indent","text":"from third_party import ( lib1 , lib2 , lib3 , lib4 , )","title":"3 - Vertical Hanging Indent"},{"location":"docs/configuration/multi_line_output_modes/#4-hanging-grid","text":"from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... )","title":"4 - Hanging Grid"},{"location":"docs/configuration/multi_line_output_modes/#5-hanging-grid-grouped","text":"from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , ... )","title":"5 - Hanging Grid Grouped"},{"location":"docs/configuration/multi_line_output_modes/#6-hanging-grid-grouped","text":"Same as Mode 5. Deprecated.","title":"6 - Hanging Grid Grouped"},{"location":"docs/configuration/multi_line_output_modes/#7-noqa","text":"from third_party import lib1 , lib2 , lib3 , ... # NOQA Alternatively, you can set force_single_line to True ( -sl on the command line) and every import will appear on its own line: from third_party import lib1 from third_party import lib2 from third_party import lib3 ...","title":"7 - NOQA"},{"location":"docs/configuration/multi_line_output_modes/#8-vertical-hanging-indent-bracket","text":"Same as Mode 3 - Vertical Hanging Indent but the closing parentheses on the last line is indented. from third_party import ( lib1 , lib2 , lib3 , lib4 , )","title":"8 - Vertical Hanging Indent Bracket"},{"location":"docs/configuration/multi_line_output_modes/#9-vertical-prefix-from-module-import","text":"Starts a new line with the same from MODULE import prefix when lines are longer than the line length limit. from third_party import lib1 , lib2 , lib3 from third_party import lib4 , lib5 , lib6","title":"9 - Vertical Prefix From Module Import"},{"location":"docs/configuration/multi_line_output_modes/#10-hanging-indent-with-parentheses","text":"Same as Mode 2 - Hanging Indent but uses parentheses instead of backslash for wrapping long lines. from third_party import ( lib1 , lib2 , lib3 , lib4 , lib5 , lib6 )","title":"10 - Hanging Indent With Parentheses"},{"location":"docs/configuration/multi_line_output_modes/#11-backslash-grid","text":"Same as Mode 0 - Grid but uses backslashes instead of parentheses to group imports. from third_party import lib1 , lib2 , lib3 , \\ lib4 , lib5","title":"11 - Backslash Grid"},{"location":"docs/configuration/options/","text":"Configuration options for isort As a code formatter isort has opinions. However, it also allows you to have your own. If your opinions disagree with those of isort, isort will disagree but commit to your way of formatting. To enable this, isort exposes a plethora of options to specify how you want your imports sorted, organized, and formatted. Too busy to build your perfect isort configuration? For curated common configurations, see isort's built-in profiles . Python Version Tells isort to set the known standard library based on the specified Python version. Default is to assume any Python 3 version could be the target, and use a union of all stdlib modules across versions. If auto is specified, the version of the interpreter used to run isort (currently: 38) will be used. Type: String Default: py3 Python & Config File Name: py_version CLI Flags: --py --python-version Force To Top Force specific imports to the top of their appropriate section. Type: Frozenset Default: frozenset() Python & Config File Name: force_to_top CLI Flags: -t --top Skip Files that sort imports should skip over. If you want to skip multiple files you should specify twice: --skip file1 --skip file2. Type: Frozenset Default: ('.bzr', '.direnv', '.eggs', '.git', '.hg', '.mypy_cache', '.nox', '.pants.d', '.svn', '.tox', '.venv', '_build', 'buck-out', 'build', 'dist', 'node_modules', 'venv') Python & Config File Name: skip CLI Flags: -s --skip Skip Glob Files that sort imports should skip over. Type: Frozenset Default: frozenset() Python & Config File Name: skip_glob CLI Flags: --sg --skip-glob Skip Gitignore Treat project as a git repository and ignore files listed in .gitignore Type: Bool Default: False Python & Config File Name: skip_gitignore CLI Flags: --gitignore --skip-gitignore Line Length The max length of an import line (used for wrapping long imports). Type: Int Default: 79 Python & Config File Name: line_length CLI Flags: -l -w --line-length --line-width Wrap Length Specifies how long lines that are wrapped should be, if not set line_length is used. NOTE: wrap_length must be LOWER than or equal to line_length. Type: Int Default: 0 Python & Config File Name: wrap_length CLI Flags: --wl --wrap-length Line Ending Forces line endings to the specified value. If not set, values will be guessed per-file. Type: String Default: `` Python & Config File Name: line_ending CLI Flags: --le --line-ending Sections No Description Type: Tuple Default: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Python & Config File Name: sections CLI Flags: Not Supported No Sections Put all imports into the same section bucket Type: Bool Default: False Python & Config File Name: no_sections CLI Flags: --ds --no-sections Known Future Library Force isort to recognize a module as part of Python's internal future compatibility libraries. WARNING: this overrides the behavior of future handling and therefore can result in code that can't execute. If you're looking to add dependencies such as six a better option is to create a another section below --future using custom sections. See: https://github.com/PyCQA/isort#custom-sections-and-ordering and the discussion here: https://github.com/PyCQA/isort/issues/1463. Type: Frozenset Default: ('__future__',) Python & Config File Name: known_future_library CLI Flags: -f --future Known Third Party Force isort to recognize a module as being part of a third party library. Type: Frozenset Default: frozenset() Python & Config File Name: known_third_party CLI Flags: -o --thirdparty Known First Party Force isort to recognize a module as being part of the current python project. Type: Frozenset Default: frozenset() Python & Config File Name: known_first_party CLI Flags: -p --project Known Local Folder Force isort to recognize a module as being a local folder. Generally, this is reserved for relative imports (from . import module). Type: Frozenset Default: frozenset() Python & Config File Name: known_local_folder CLI Flags: --known-local-folder Known Standard Library Force isort to recognize a module as part of Python's standard library. Type: Frozenset Default: ('_dummy_thread', '_thread', 'abc', 'aifc', 'argparse', 'array', 'ast', 'asynchat', 'asyncio', 'asyncore', 'atexit', 'audioop', 'base64', 'bdb', 'binascii', 'binhex', 'bisect', 'builtins', 'bz2', 'cProfile', 'calendar', 'cgi', 'cgitb', 'chunk', 'cmath', 'cmd', 'code', 'codecs', 'codeop', 'collections', 'colorsys', 'compileall', 'concurrent', 'configparser', 'contextlib', 'contextvars', 'copy', 'copyreg', 'crypt', 'csv', 'ctypes', 'curses', 'dataclasses', 'datetime', 'dbm', 'decimal', 'difflib', 'dis', 'distutils', 'doctest', 'dummy_threading', 'email', 'encodings', 'ensurepip', 'enum', 'errno', 'faulthandler', 'fcntl', 'filecmp', 'fileinput', 'fnmatch', 'formatter', 'fpectl', 'fractions', 'ftplib', 'functools', 'gc', 'getopt', 'getpass', 'gettext', 'glob', 'graphlib', 'grp', 'gzip', 'hashlib', 'heapq', 'hmac', 'html', 'http', 'imaplib', 'imghdr', 'imp', 'importlib', 'inspect', 'io', 'ipaddress', 'itertools', 'json', 'keyword', 'lib2to3', 'linecache', 'locale', 'logging', 'lzma', 'macpath', 'mailbox', 'mailcap', 'marshal', 'math', 'mimetypes', 'mmap', 'modulefinder', 'msilib', 'msvcrt', 'multiprocessing', 'netrc', 'nis', 'nntplib', 'ntpath', 'numbers', 'operator', 'optparse', 'os', 'ossaudiodev', 'parser', 'pathlib', 'pdb', 'pickle', 'pickletools', 'pipes', 'pkgutil', 'platform', 'plistlib', 'poplib', 'posix', 'posixpath', 'pprint', 'profile', 'pstats', 'pty', 'pwd', 'py_compile', 'pyclbr', 'pydoc', 'queue', 'quopri', 'random', 're', 'readline', 'reprlib', 'resource', 'rlcompleter', 'runpy', 'sched', 'secrets', 'select', 'selectors', 'shelve', 'shlex', 'shutil', 'signal', 'site', 'smtpd', 'smtplib', 'sndhdr', 'socket', 'socketserver', 'spwd', 'sqlite3', 'sre', 'sre_compile', 'sre_constants', 'sre_parse', 'ssl', 'stat', 'statistics', 'string', 'stringprep', 'struct', 'subprocess', 'sunau', 'symbol', 'symtable', 'sys', 'sysconfig', 'syslog', 'tabnanny', 'tarfile', 'telnetlib', 'tempfile', 'termios', 'test', 'textwrap', 'threading', 'time', 'timeit', 'tkinter', 'token', 'tokenize', 'trace', 'traceback', 'tracemalloc', 'tty', 'turtle', 'turtledemo', 'types', 'typing', 'unicodedata', 'unittest', 'urllib', 'uu', 'uuid', 'venv', 'warnings', 'wave', 'weakref', 'webbrowser', 'winreg', 'winsound', 'wsgiref', 'xdrlib', 'xml', 'xmlrpc', 'zipapp', 'zipfile', 'zipimport', 'zlib', 'zoneinfo') Python & Config File Name: known_standard_library CLI Flags: -b --builtin Extra Standard Library Extra modules to be included in the list of ones in Python's standard library. Type: Frozenset Default: frozenset() Python & Config File Name: extra_standard_library CLI Flags: --extra-builtin Known Other No Description Type: Dict Default: {} Python & Config File Name: known_other CLI Flags: Not Supported Examples: Example .isort.cfg [settings] sections = FUTURE,STDLIB,THIRDPARTY,AIRFLOW,FIRSTPARTY,LOCALFOLDER known_airflow = airflow Example pyproject.toml [tool.isort] sections = ['FUTURE', 'STDLIB', 'THIRDPARTY', 'AIRFLOW', 'FIRSTPARTY', 'LOCALFOLDER'] known_airflow = ['airflow'] Multi Line Output Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, 5-vert-grid-grouped, 6-vert-grid-grouped-no-comma, 7-noqa, 8-vertical-hanging-indent-bracket, 9-vertical-prefix-from-module-import, 10-hanging-indent-with-parentheses). Type: Wrapmodes Default: WrapModes.GRID Python & Config File Name: multi_line_output CLI Flags: -m --multi-line Examples: Example .isort.cfg [settings] multi_line_output = 3 Example pyproject.toml [tool.isort] multi_line_output = 3 Forced Separate No Description Type: Tuple Default: () Python & Config File Name: forced_separate CLI Flags: Not Supported Indent String to place for indents defaults to \" \" (4 spaces). Type: String Default: Python & Config File Name: indent CLI Flags: -i --indent Comment Prefix No Description Type: String Default: # Python & Config File Name: comment_prefix CLI Flags: Not Supported Length Sort Sort imports by their string length. Type: Bool Default: False Python & Config File Name: length_sort CLI Flags: --ls --length-sort Length Sort Straight Sort straight imports by their string length. Similar to length_sort but applies only to straight imports and doesn't affect from imports. Type: Bool Default: False Python & Config File Name: length_sort_straight CLI Flags: --lss --length-sort-straight Length Sort Sections No Description Type: Frozenset Default: frozenset() Python & Config File Name: length_sort_sections CLI Flags: Not Supported Add Imports Adds the specified import line to all files, automatically determining correct placement. Type: Frozenset Default: frozenset() Python & Config File Name: add_imports CLI Flags: -a --add-import Remove Imports Removes the specified import from all files. Type: Frozenset Default: frozenset() Python & Config File Name: remove_imports CLI Flags: --rm --remove-import Append Only Only adds the imports specified in --add-import if the file contains existing imports. Type: Bool Default: False Python & Config File Name: append_only CLI Flags: --append --append-only Reverse Relative Reverse order of relative imports. Type: Bool Default: False Python & Config File Name: reverse_relative CLI Flags: --rr --reverse-relative Force Single Line Forces all from imports to appear on their own line Type: Bool Default: False Python & Config File Name: force_single_line CLI Flags: --sl --force-single-line-imports Single Line Exclusions One or more modules to exclude from the single line rule. Type: Tuple Default: () Python & Config File Name: single_line_exclusions CLI Flags: --nsl --single-line-exclusions Default Section Sets the default section for import options: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Type: String Default: THIRDPARTY Python & Config File Name: default_section CLI Flags: --sd --section-default Import Headings No Description Type: Dict Default: {} Python & Config File Name: import_headings CLI Flags: Not Supported Balanced Wrapping Balances wrapping to produce the most consistent line length possible Type: Bool Default: False Python & Config File Name: balanced_wrapping CLI Flags: -e --balanced Use Parentheses Use parentheses for line continuation on length limit instead of slashes. NOTE : This is separate from wrap modes, and only affects how individual lines that are too long get continued, not sections of multiple imports. Type: Bool Default: False Python & Config File Name: use_parentheses CLI Flags: --up --use-parentheses Order By Type Order imports by type, which is determined by case, in addition to alphabetically. NOTE : type here refers to the implied type from the import name capitalization. isort does not do type introspection for the imports. These \"types\" are simply: CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8 or a related coding standard and has many imports this is a good default, otherwise you likely will want to turn it off. From the CLI the --dont-order-by-type option will turn this off. Type: Bool Default: True Python & Config File Name: order_by_type CLI Flags: --ot --order-by-type Atomic Ensures the output doesn't save if the resulting file contains syntax errors. Type: Bool Default: False Python & Config File Name: atomic CLI Flags: --ac --atomic Lines After Imports No Description Type: Int Default: -1 Python & Config File Name: lines_after_imports CLI Flags: --lai --lines-after-imports Lines Between Sections No Description Type: Int Default: 1 Python & Config File Name: lines_between_sections CLI Flags: Not Supported Lines Between Types No Description Type: Int Default: 0 Python & Config File Name: lines_between_types CLI Flags: --lbt --lines-between-types Combine As Imports Combines as imports on the same line. Type: Bool Default: False Python & Config File Name: combine_as_imports CLI Flags: --ca --combine-as Combine Star Ensures that if a star import is present, nothing else is imported from that namespace. Type: Bool Default: False Python & Config File Name: combine_star CLI Flags: --cs --combine-star Include Trailing Comma Includes a trailing comma on multi line imports that include parentheses. Type: Bool Default: False Python & Config File Name: include_trailing_comma CLI Flags: --tc --trailing-comma From First Switches the typical ordering preference, showing from imports first then straight ones. Type: Bool Default: False Python & Config File Name: from_first CLI Flags: --ff --from-first Verbose Shows verbose output, such as when files are skipped or when a check is successful. Type: Bool Default: False Python & Config File Name: verbose CLI Flags: -v --verbose Quiet Shows extra quiet output, only errors are outputted. Type: Bool Default: False Python & Config File Name: quiet CLI Flags: -q --quiet Force Adds Forces import adds even if the original file is empty. Type: Bool Default: False Python & Config File Name: force_adds CLI Flags: --af --force-adds Force Alphabetical Sort Within Sections Force all imports to be sorted alphabetically within a section Type: Bool Default: False Python & Config File Name: force_alphabetical_sort_within_sections CLI Flags: --fass --force-alphabetical-sort-within-sections Force Alphabetical Sort Force all imports to be sorted as a single section Type: Bool Default: False Python & Config File Name: force_alphabetical_sort CLI Flags: --fas --force-alphabetical-sort Force Grid Wrap Force number of from imports (defaults to 2 when passed as CLI flag without value)to be grid wrapped regardless of line length. If 0 is passed in (the global default) only line length is considered. Type: Int Default: 0 Python & Config File Name: force_grid_wrap CLI Flags: --fgw --force-grid-wrap Force Sort Within Sections Don't sort straight-style imports (like import sys) before from-style imports (like from itertools import groupby). Instead, sort the imports by module, independent of import style. Type: Bool Default: False Python & Config File Name: force_sort_within_sections CLI Flags: --fss --force-sort-within-sections Lexicographical No Description Type: Bool Default: False Python & Config File Name: lexicographical CLI Flags: Not Supported Group By Package No Description Type: Bool Default: False Python & Config File Name: group_by_package CLI Flags: Not Supported Ignore Whitespace Tells isort to ignore whitespace differences when --check-only is being used. Type: Bool Default: False Python & Config File Name: ignore_whitespace CLI Flags: --ws --ignore-whitespace No Lines Before Sections which should not be split with previous by empty lines Type: Frozenset Default: frozenset() Python & Config File Name: no_lines_before CLI Flags: --nlb --no-lines-before No Inline Sort Leaves from imports with multiple imports 'as-is' (e.g. from foo import a, c ,b ). Type: Bool Default: False Python & Config File Name: no_inline_sort CLI Flags: --nis --no-inline-sort Ignore Comments No Description Type: Bool Default: False Python & Config File Name: ignore_comments CLI Flags: Not Supported Case Sensitive Tells isort to include casing when sorting module names Type: Bool Default: False Python & Config File Name: case_sensitive CLI Flags: --case-sensitive Sources No Description Type: Tuple Default: () Python & Config File Name: sources CLI Flags: Not Supported Virtual Env Virtual environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: virtual_env CLI Flags: --virtual-env Conda Env Conda environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: conda_env CLI Flags: --conda-env Ensure Newline Before Comments Inserts a blank line before a comment following an import. Type: Bool Default: False Python & Config File Name: ensure_newline_before_comments CLI Flags: -n --ensure-newline-before-comments Directory No Description Type: String Default: `` Python & Config File Name: directory CLI Flags: Not Supported Profile Base profile type to use for configuration. Profiles include: black, django, pycharm, google, open_stack, plone, attrs, hug. As well as any shared profiles. Type: String Default: `` Python & Config File Name: profile CLI Flags: --profile Honor Noqa Tells isort to honor noqa comments to enforce skipping those comments. Type: Bool Default: False Python & Config File Name: honor_noqa CLI Flags: --honor-noqa Src Paths Add an explicitly defined source path (modules within src paths have their imports automatically categorized as first_party). Type: Tuple Default: () Python & Config File Name: src_paths CLI Flags: --src --src-path Old Finders Use the old deprecated finder logic that relies on environment introspection magic. Type: Bool Default: False Python & Config File Name: old_finders CLI Flags: --old-finders --magic-placement Remove Redundant Aliases Tells isort to remove redundant aliases from imports, such as import os as os . This defaults to False simply because some projects use these seemingly useless aliases to signify intent and change behaviour. Type: Bool Default: False Python & Config File Name: remove_redundant_aliases CLI Flags: --remove-redundant-aliases Float To Top Causes all non-indented imports to float to the top of the file having its imports sorted (immediately below the top of file comment). This can be an excellent shortcut for collecting imports every once in a while when you place them in the middle of a file to avoid context switching. NOTE : It currently doesn't work with cimports and introduces some extra over-head and a performance penalty. Type: Bool Default: False Python & Config File Name: float_to_top CLI Flags: --float-to-top Filter Files Tells isort to filter files even when they are explicitly passed in as part of the CLI command. Type: Bool Default: False Python & Config File Name: filter_files CLI Flags: --filter-files Formatter Specifies the name of a formatting plugin to use when producing output. Type: String Default: `` Python & Config File Name: formatter CLI Flags: --formatter Formatting Function No Description Type: Nonetype Default: None Python & Config File Name: formatting_function CLI Flags: Not Supported Color Output Tells isort to use color in terminal output. Type: Bool Default: False Python & Config File Name: color_output CLI Flags: --color Treat Comments As Code Tells isort to treat the specified single line comment(s) as if they are code. Type: Frozenset Default: frozenset() Python & Config File Name: treat_comments_as_code CLI Flags: --treat-comment-as-code Treat All Comments As Code Tells isort to treat all single line comments as if they are code. Type: Bool Default: False Python & Config File Name: treat_all_comments_as_code CLI Flags: --treat-all-comment-as-code Supported Extensions Specifies what extensions isort can be ran against. Type: Frozenset Default: ('pxd', 'py', 'pyi', 'pyx') Python & Config File Name: supported_extensions CLI Flags: --ext --extension --supported-extension Blocked Extensions Specifies what extensions isort can never be ran against. Type: Frozenset Default: ('pex',) Python & Config File Name: blocked_extensions CLI Flags: --blocked-extension Constants No Description Type: Frozenset Default: frozenset() Python & Config File Name: constants CLI Flags: Not Supported Classes No Description Type: Frozenset Default: frozenset() Python & Config File Name: classes CLI Flags: Not Supported Variables No Description Type: Frozenset Default: frozenset() Python & Config File Name: variables CLI Flags: Not Supported Dedup Headings Tells isort to only show an identical custom import heading comment once, even if there are multiple sections with the comment set. Type: Bool Default: False Python & Config File Name: dedup_headings CLI Flags: --dedup-headings Only Sections Causes imports to be sorted only based on their sections like STDLIB,THIRDPARTY etc. Imports are unaltered and keep their relative positions within the different sections. Type: Bool Default: False Python & Config File Name: only_sections CLI Flags: --only-sections --os Only Modified Suppresses verbose output for non-modified files. Type: Bool Default: False Python & Config File Name: only_modified CLI Flags: --only-modified --om Combine Straight Imports Combines all the bare straight imports of the same section in a single line. Won't work with sections which have 'as' imports Type: Bool Default: False Python & Config File Name: combine_straight_imports CLI Flags: --combine-straight-imports --csi Auto Identify Namespace Packages No Description Type: Bool Default: True Python & Config File Name: auto_identify_namespace_packages CLI Flags: Not Supported Namespace Packages No Description Type: Frozenset Default: frozenset() Python & Config File Name: namespace_packages CLI Flags: Not Supported Follow Links No Description Type: Bool Default: True Python & Config File Name: follow_links CLI Flags: Not Supported Indented Import Headings No Description Type: Bool Default: True Python & Config File Name: indented_import_headings CLI Flags: Not Supported Show Version Displays the currently installed version of isort. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -V --version Examples: Example cli usage isort --version Version Number Returns just the current version number without the logo Type: String Default: ==SUPPRESS== Python & Config File Name: Not Supported CLI Flags: --vn --version-number Write To Stdout Force resulting output to stdout, instead of in-place. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -d --stdout Show Config See isort's determined config, as well as sources of config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-config Show Files See the files isort will be ran against with the current config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-files Show Diff Prints a diff of all the changes isort would make to a file, instead of changing it in place Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --df --diff Check Checks the file for unsorted / unformatted imports and prints them to the command line without modifying the file. Returns 0 when nothing would change and returns 1 when the file would be reformatted. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -c --check-only --check Settings Path Explicitly set the settings path or file instead of auto determining based on file location. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --sp --settings-path --settings-file --settings Jobs Number of files to process in parallel. Type: Int Default: None Python & Config File Name: Not Supported CLI Flags: -j --jobs Ask To Apply Tells isort to apply changes interactively. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --interactive Files One or more Python source files that need their imports sorted. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: Dont Follow Links Tells isort not to follow symlinks that are encountered when running recursively. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dont-follow-links Filename Provide the filename associated with a stream. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --filename Dont Float To Top Forces --float-to-top setting off. See --float-to-top for more information. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dont-float-to-top Dont Order By Type Don't order imports by type, which is determined by case, in addition to alphabetically. NOTE : type here refers to the implied type from the import name capitalization. isort does not do type introspection for the imports. These \"types\" are simply: CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8 or a related coding standard and has many imports this is a good default. You can turn this on from the CLI using --order-by-type . Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dt --dont-order-by-type Ext Format Tells isort to format the given files according to an extensions formatting rules. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --ext-format Show Files See the files isort will be ran against with the current config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-files Deprecated Flags ==SUPPRESS== Type: String Default: None Python & Config File Name: Not Supported CLI Flags: -k --keep-direct-and-as","title":"Options"},{"location":"docs/configuration/options/#configuration-options-for-isort","text":"As a code formatter isort has opinions. However, it also allows you to have your own. If your opinions disagree with those of isort, isort will disagree but commit to your way of formatting. To enable this, isort exposes a plethora of options to specify how you want your imports sorted, organized, and formatted. Too busy to build your perfect isort configuration? For curated common configurations, see isort's built-in profiles .","title":"Configuration options for isort"},{"location":"docs/configuration/options/#python-version","text":"Tells isort to set the known standard library based on the specified Python version. Default is to assume any Python 3 version could be the target, and use a union of all stdlib modules across versions. If auto is specified, the version of the interpreter used to run isort (currently: 38) will be used. Type: String Default: py3 Python & Config File Name: py_version CLI Flags: --py --python-version","title":"Python Version"},{"location":"docs/configuration/options/#force-to-top","text":"Force specific imports to the top of their appropriate section. Type: Frozenset Default: frozenset() Python & Config File Name: force_to_top CLI Flags: -t --top","title":"Force To Top"},{"location":"docs/configuration/options/#skip","text":"Files that sort imports should skip over. If you want to skip multiple files you should specify twice: --skip file1 --skip file2. Type: Frozenset Default: ('.bzr', '.direnv', '.eggs', '.git', '.hg', '.mypy_cache', '.nox', '.pants.d', '.svn', '.tox', '.venv', '_build', 'buck-out', 'build', 'dist', 'node_modules', 'venv') Python & Config File Name: skip CLI Flags: -s --skip","title":"Skip"},{"location":"docs/configuration/options/#skip-glob","text":"Files that sort imports should skip over. Type: Frozenset Default: frozenset() Python & Config File Name: skip_glob CLI Flags: --sg --skip-glob","title":"Skip Glob"},{"location":"docs/configuration/options/#skip-gitignore","text":"Treat project as a git repository and ignore files listed in .gitignore Type: Bool Default: False Python & Config File Name: skip_gitignore CLI Flags: --gitignore --skip-gitignore","title":"Skip Gitignore"},{"location":"docs/configuration/options/#line-length","text":"The max length of an import line (used for wrapping long imports). Type: Int Default: 79 Python & Config File Name: line_length CLI Flags: -l -w --line-length --line-width","title":"Line Length"},{"location":"docs/configuration/options/#wrap-length","text":"Specifies how long lines that are wrapped should be, if not set line_length is used. NOTE: wrap_length must be LOWER than or equal to line_length. Type: Int Default: 0 Python & Config File Name: wrap_length CLI Flags: --wl --wrap-length","title":"Wrap Length"},{"location":"docs/configuration/options/#line-ending","text":"Forces line endings to the specified value. If not set, values will be guessed per-file. Type: String Default: `` Python & Config File Name: line_ending CLI Flags: --le --line-ending","title":"Line Ending"},{"location":"docs/configuration/options/#sections","text":"No Description Type: Tuple Default: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Python & Config File Name: sections CLI Flags: Not Supported","title":"Sections"},{"location":"docs/configuration/options/#no-sections","text":"Put all imports into the same section bucket Type: Bool Default: False Python & Config File Name: no_sections CLI Flags: --ds --no-sections","title":"No Sections"},{"location":"docs/configuration/options/#known-future-library","text":"Force isort to recognize a module as part of Python's internal future compatibility libraries. WARNING: this overrides the behavior of future handling and therefore can result in code that can't execute. If you're looking to add dependencies such as six a better option is to create a another section below --future using custom sections. See: https://github.com/PyCQA/isort#custom-sections-and-ordering and the discussion here: https://github.com/PyCQA/isort/issues/1463. Type: Frozenset Default: ('__future__',) Python & Config File Name: known_future_library CLI Flags: -f --future","title":"Known Future Library"},{"location":"docs/configuration/options/#known-third-party","text":"Force isort to recognize a module as being part of a third party library. Type: Frozenset Default: frozenset() Python & Config File Name: known_third_party CLI Flags: -o --thirdparty","title":"Known Third Party"},{"location":"docs/configuration/options/#known-first-party","text":"Force isort to recognize a module as being part of the current python project. Type: Frozenset Default: frozenset() Python & Config File Name: known_first_party CLI Flags: -p --project","title":"Known First Party"},{"location":"docs/configuration/options/#known-local-folder","text":"Force isort to recognize a module as being a local folder. Generally, this is reserved for relative imports (from . import module). Type: Frozenset Default: frozenset() Python & Config File Name: known_local_folder CLI Flags: --known-local-folder","title":"Known Local Folder"},{"location":"docs/configuration/options/#known-standard-library","text":"Force isort to recognize a module as part of Python's standard library. Type: Frozenset Default: ('_dummy_thread', '_thread', 'abc', 'aifc', 'argparse', 'array', 'ast', 'asynchat', 'asyncio', 'asyncore', 'atexit', 'audioop', 'base64', 'bdb', 'binascii', 'binhex', 'bisect', 'builtins', 'bz2', 'cProfile', 'calendar', 'cgi', 'cgitb', 'chunk', 'cmath', 'cmd', 'code', 'codecs', 'codeop', 'collections', 'colorsys', 'compileall', 'concurrent', 'configparser', 'contextlib', 'contextvars', 'copy', 'copyreg', 'crypt', 'csv', 'ctypes', 'curses', 'dataclasses', 'datetime', 'dbm', 'decimal', 'difflib', 'dis', 'distutils', 'doctest', 'dummy_threading', 'email', 'encodings', 'ensurepip', 'enum', 'errno', 'faulthandler', 'fcntl', 'filecmp', 'fileinput', 'fnmatch', 'formatter', 'fpectl', 'fractions', 'ftplib', 'functools', 'gc', 'getopt', 'getpass', 'gettext', 'glob', 'graphlib', 'grp', 'gzip', 'hashlib', 'heapq', 'hmac', 'html', 'http', 'imaplib', 'imghdr', 'imp', 'importlib', 'inspect', 'io', 'ipaddress', 'itertools', 'json', 'keyword', 'lib2to3', 'linecache', 'locale', 'logging', 'lzma', 'macpath', 'mailbox', 'mailcap', 'marshal', 'math', 'mimetypes', 'mmap', 'modulefinder', 'msilib', 'msvcrt', 'multiprocessing', 'netrc', 'nis', 'nntplib', 'ntpath', 'numbers', 'operator', 'optparse', 'os', 'ossaudiodev', 'parser', 'pathlib', 'pdb', 'pickle', 'pickletools', 'pipes', 'pkgutil', 'platform', 'plistlib', 'poplib', 'posix', 'posixpath', 'pprint', 'profile', 'pstats', 'pty', 'pwd', 'py_compile', 'pyclbr', 'pydoc', 'queue', 'quopri', 'random', 're', 'readline', 'reprlib', 'resource', 'rlcompleter', 'runpy', 'sched', 'secrets', 'select', 'selectors', 'shelve', 'shlex', 'shutil', 'signal', 'site', 'smtpd', 'smtplib', 'sndhdr', 'socket', 'socketserver', 'spwd', 'sqlite3', 'sre', 'sre_compile', 'sre_constants', 'sre_parse', 'ssl', 'stat', 'statistics', 'string', 'stringprep', 'struct', 'subprocess', 'sunau', 'symbol', 'symtable', 'sys', 'sysconfig', 'syslog', 'tabnanny', 'tarfile', 'telnetlib', 'tempfile', 'termios', 'test', 'textwrap', 'threading', 'time', 'timeit', 'tkinter', 'token', 'tokenize', 'trace', 'traceback', 'tracemalloc', 'tty', 'turtle', 'turtledemo', 'types', 'typing', 'unicodedata', 'unittest', 'urllib', 'uu', 'uuid', 'venv', 'warnings', 'wave', 'weakref', 'webbrowser', 'winreg', 'winsound', 'wsgiref', 'xdrlib', 'xml', 'xmlrpc', 'zipapp', 'zipfile', 'zipimport', 'zlib', 'zoneinfo') Python & Config File Name: known_standard_library CLI Flags: -b --builtin","title":"Known Standard Library"},{"location":"docs/configuration/options/#extra-standard-library","text":"Extra modules to be included in the list of ones in Python's standard library. Type: Frozenset Default: frozenset() Python & Config File Name: extra_standard_library CLI Flags: --extra-builtin","title":"Extra Standard Library"},{"location":"docs/configuration/options/#known-other","text":"No Description Type: Dict Default: {} Python & Config File Name: known_other CLI Flags: Not Supported Examples:","title":"Known Other"},{"location":"docs/configuration/options/#example-isortcfg","text":"[settings] sections = FUTURE,STDLIB,THIRDPARTY,AIRFLOW,FIRSTPARTY,LOCALFOLDER known_airflow = airflow","title":"Example .isort.cfg"},{"location":"docs/configuration/options/#example-pyprojecttoml","text":"[tool.isort] sections = ['FUTURE', 'STDLIB', 'THIRDPARTY', 'AIRFLOW', 'FIRSTPARTY', 'LOCALFOLDER'] known_airflow = ['airflow']","title":"Example pyproject.toml"},{"location":"docs/configuration/options/#multi-line-output","text":"Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, 5-vert-grid-grouped, 6-vert-grid-grouped-no-comma, 7-noqa, 8-vertical-hanging-indent-bracket, 9-vertical-prefix-from-module-import, 10-hanging-indent-with-parentheses). Type: Wrapmodes Default: WrapModes.GRID Python & Config File Name: multi_line_output CLI Flags: -m --multi-line Examples:","title":"Multi Line Output"},{"location":"docs/configuration/options/#example-isortcfg_1","text":"[settings] multi_line_output = 3","title":"Example .isort.cfg"},{"location":"docs/configuration/options/#example-pyprojecttoml_1","text":"[tool.isort] multi_line_output = 3","title":"Example pyproject.toml"},{"location":"docs/configuration/options/#forced-separate","text":"No Description Type: Tuple Default: () Python & Config File Name: forced_separate CLI Flags: Not Supported","title":"Forced Separate"},{"location":"docs/configuration/options/#indent","text":"String to place for indents defaults to \" \" (4 spaces). Type: String Default: Python & Config File Name: indent CLI Flags: -i --indent","title":"Indent"},{"location":"docs/configuration/options/#comment-prefix","text":"No Description Type: String Default: # Python & Config File Name: comment_prefix CLI Flags: Not Supported","title":"Comment Prefix"},{"location":"docs/configuration/options/#length-sort","text":"Sort imports by their string length. Type: Bool Default: False Python & Config File Name: length_sort CLI Flags: --ls --length-sort","title":"Length Sort"},{"location":"docs/configuration/options/#length-sort-straight","text":"Sort straight imports by their string length. Similar to length_sort but applies only to straight imports and doesn't affect from imports. Type: Bool Default: False Python & Config File Name: length_sort_straight CLI Flags: --lss --length-sort-straight","title":"Length Sort Straight"},{"location":"docs/configuration/options/#length-sort-sections","text":"No Description Type: Frozenset Default: frozenset() Python & Config File Name: length_sort_sections CLI Flags: Not Supported","title":"Length Sort Sections"},{"location":"docs/configuration/options/#add-imports","text":"Adds the specified import line to all files, automatically determining correct placement. Type: Frozenset Default: frozenset() Python & Config File Name: add_imports CLI Flags: -a --add-import","title":"Add Imports"},{"location":"docs/configuration/options/#remove-imports","text":"Removes the specified import from all files. Type: Frozenset Default: frozenset() Python & Config File Name: remove_imports CLI Flags: --rm --remove-import","title":"Remove Imports"},{"location":"docs/configuration/options/#append-only","text":"Only adds the imports specified in --add-import if the file contains existing imports. Type: Bool Default: False Python & Config File Name: append_only CLI Flags: --append --append-only","title":"Append Only"},{"location":"docs/configuration/options/#reverse-relative","text":"Reverse order of relative imports. Type: Bool Default: False Python & Config File Name: reverse_relative CLI Flags: --rr --reverse-relative","title":"Reverse Relative"},{"location":"docs/configuration/options/#force-single-line","text":"Forces all from imports to appear on their own line Type: Bool Default: False Python & Config File Name: force_single_line CLI Flags: --sl --force-single-line-imports","title":"Force Single Line"},{"location":"docs/configuration/options/#single-line-exclusions","text":"One or more modules to exclude from the single line rule. Type: Tuple Default: () Python & Config File Name: single_line_exclusions CLI Flags: --nsl --single-line-exclusions","title":"Single Line Exclusions"},{"location":"docs/configuration/options/#default-section","text":"Sets the default section for import options: ('FUTURE', 'STDLIB', 'THIRDPARTY', 'FIRSTPARTY', 'LOCALFOLDER') Type: String Default: THIRDPARTY Python & Config File Name: default_section CLI Flags: --sd --section-default","title":"Default Section"},{"location":"docs/configuration/options/#import-headings","text":"No Description Type: Dict Default: {} Python & Config File Name: import_headings CLI Flags: Not Supported","title":"Import Headings"},{"location":"docs/configuration/options/#balanced-wrapping","text":"Balances wrapping to produce the most consistent line length possible Type: Bool Default: False Python & Config File Name: balanced_wrapping CLI Flags: -e --balanced","title":"Balanced Wrapping"},{"location":"docs/configuration/options/#use-parentheses","text":"Use parentheses for line continuation on length limit instead of slashes. NOTE : This is separate from wrap modes, and only affects how individual lines that are too long get continued, not sections of multiple imports. Type: Bool Default: False Python & Config File Name: use_parentheses CLI Flags: --up --use-parentheses","title":"Use Parentheses"},{"location":"docs/configuration/options/#order-by-type","text":"Order imports by type, which is determined by case, in addition to alphabetically. NOTE : type here refers to the implied type from the import name capitalization. isort does not do type introspection for the imports. These \"types\" are simply: CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8 or a related coding standard and has many imports this is a good default, otherwise you likely will want to turn it off. From the CLI the --dont-order-by-type option will turn this off. Type: Bool Default: True Python & Config File Name: order_by_type CLI Flags: --ot --order-by-type","title":"Order By Type"},{"location":"docs/configuration/options/#atomic","text":"Ensures the output doesn't save if the resulting file contains syntax errors. Type: Bool Default: False Python & Config File Name: atomic CLI Flags: --ac --atomic","title":"Atomic"},{"location":"docs/configuration/options/#lines-after-imports","text":"No Description Type: Int Default: -1 Python & Config File Name: lines_after_imports CLI Flags: --lai --lines-after-imports","title":"Lines After Imports"},{"location":"docs/configuration/options/#lines-between-sections","text":"No Description Type: Int Default: 1 Python & Config File Name: lines_between_sections CLI Flags: Not Supported","title":"Lines Between Sections"},{"location":"docs/configuration/options/#lines-between-types","text":"No Description Type: Int Default: 0 Python & Config File Name: lines_between_types CLI Flags: --lbt --lines-between-types","title":"Lines Between Types"},{"location":"docs/configuration/options/#combine-as-imports","text":"Combines as imports on the same line. Type: Bool Default: False Python & Config File Name: combine_as_imports CLI Flags: --ca --combine-as","title":"Combine As Imports"},{"location":"docs/configuration/options/#combine-star","text":"Ensures that if a star import is present, nothing else is imported from that namespace. Type: Bool Default: False Python & Config File Name: combine_star CLI Flags: --cs --combine-star","title":"Combine Star"},{"location":"docs/configuration/options/#include-trailing-comma","text":"Includes a trailing comma on multi line imports that include parentheses. Type: Bool Default: False Python & Config File Name: include_trailing_comma CLI Flags: --tc --trailing-comma","title":"Include Trailing Comma"},{"location":"docs/configuration/options/#from-first","text":"Switches the typical ordering preference, showing from imports first then straight ones. Type: Bool Default: False Python & Config File Name: from_first CLI Flags: --ff --from-first","title":"From First"},{"location":"docs/configuration/options/#verbose","text":"Shows verbose output, such as when files are skipped or when a check is successful. Type: Bool Default: False Python & Config File Name: verbose CLI Flags: -v --verbose","title":"Verbose"},{"location":"docs/configuration/options/#quiet","text":"Shows extra quiet output, only errors are outputted. Type: Bool Default: False Python & Config File Name: quiet CLI Flags: -q --quiet","title":"Quiet"},{"location":"docs/configuration/options/#force-adds","text":"Forces import adds even if the original file is empty. Type: Bool Default: False Python & Config File Name: force_adds CLI Flags: --af --force-adds","title":"Force Adds"},{"location":"docs/configuration/options/#force-alphabetical-sort-within-sections","text":"Force all imports to be sorted alphabetically within a section Type: Bool Default: False Python & Config File Name: force_alphabetical_sort_within_sections CLI Flags: --fass --force-alphabetical-sort-within-sections","title":"Force Alphabetical Sort Within Sections"},{"location":"docs/configuration/options/#force-alphabetical-sort","text":"Force all imports to be sorted as a single section Type: Bool Default: False Python & Config File Name: force_alphabetical_sort CLI Flags: --fas --force-alphabetical-sort","title":"Force Alphabetical Sort"},{"location":"docs/configuration/options/#force-grid-wrap","text":"Force number of from imports (defaults to 2 when passed as CLI flag without value)to be grid wrapped regardless of line length. If 0 is passed in (the global default) only line length is considered. Type: Int Default: 0 Python & Config File Name: force_grid_wrap CLI Flags: --fgw --force-grid-wrap","title":"Force Grid Wrap"},{"location":"docs/configuration/options/#force-sort-within-sections","text":"Don't sort straight-style imports (like import sys) before from-style imports (like from itertools import groupby). Instead, sort the imports by module, independent of import style. Type: Bool Default: False Python & Config File Name: force_sort_within_sections CLI Flags: --fss --force-sort-within-sections","title":"Force Sort Within Sections"},{"location":"docs/configuration/options/#lexicographical","text":"No Description Type: Bool Default: False Python & Config File Name: lexicographical CLI Flags: Not Supported","title":"Lexicographical"},{"location":"docs/configuration/options/#group-by-package","text":"No Description Type: Bool Default: False Python & Config File Name: group_by_package CLI Flags: Not Supported","title":"Group By Package"},{"location":"docs/configuration/options/#ignore-whitespace","text":"Tells isort to ignore whitespace differences when --check-only is being used. Type: Bool Default: False Python & Config File Name: ignore_whitespace CLI Flags: --ws --ignore-whitespace","title":"Ignore Whitespace"},{"location":"docs/configuration/options/#no-lines-before","text":"Sections which should not be split with previous by empty lines Type: Frozenset Default: frozenset() Python & Config File Name: no_lines_before CLI Flags: --nlb --no-lines-before","title":"No Lines Before"},{"location":"docs/configuration/options/#no-inline-sort","text":"Leaves from imports with multiple imports 'as-is' (e.g. from foo import a, c ,b ). Type: Bool Default: False Python & Config File Name: no_inline_sort CLI Flags: --nis --no-inline-sort","title":"No Inline Sort"},{"location":"docs/configuration/options/#ignore-comments","text":"No Description Type: Bool Default: False Python & Config File Name: ignore_comments CLI Flags: Not Supported","title":"Ignore Comments"},{"location":"docs/configuration/options/#case-sensitive","text":"Tells isort to include casing when sorting module names Type: Bool Default: False Python & Config File Name: case_sensitive CLI Flags: --case-sensitive","title":"Case Sensitive"},{"location":"docs/configuration/options/#sources","text":"No Description Type: Tuple Default: () Python & Config File Name: sources CLI Flags: Not Supported","title":"Sources"},{"location":"docs/configuration/options/#virtual-env","text":"Virtual environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: virtual_env CLI Flags: --virtual-env","title":"Virtual Env"},{"location":"docs/configuration/options/#conda-env","text":"Conda environment to use for determining whether a package is third-party Type: String Default: `` Python & Config File Name: conda_env CLI Flags: --conda-env","title":"Conda Env"},{"location":"docs/configuration/options/#ensure-newline-before-comments","text":"Inserts a blank line before a comment following an import. Type: Bool Default: False Python & Config File Name: ensure_newline_before_comments CLI Flags: -n --ensure-newline-before-comments","title":"Ensure Newline Before Comments"},{"location":"docs/configuration/options/#directory","text":"No Description Type: String Default: `` Python & Config File Name: directory CLI Flags: Not Supported","title":"Directory"},{"location":"docs/configuration/options/#profile","text":"Base profile type to use for configuration. Profiles include: black, django, pycharm, google, open_stack, plone, attrs, hug. As well as any shared profiles. Type: String Default: `` Python & Config File Name: profile CLI Flags: --profile","title":"Profile"},{"location":"docs/configuration/options/#honor-noqa","text":"Tells isort to honor noqa comments to enforce skipping those comments. Type: Bool Default: False Python & Config File Name: honor_noqa CLI Flags: --honor-noqa","title":"Honor Noqa"},{"location":"docs/configuration/options/#src-paths","text":"Add an explicitly defined source path (modules within src paths have their imports automatically categorized as first_party). Type: Tuple Default: () Python & Config File Name: src_paths CLI Flags: --src --src-path","title":"Src Paths"},{"location":"docs/configuration/options/#old-finders","text":"Use the old deprecated finder logic that relies on environment introspection magic. Type: Bool Default: False Python & Config File Name: old_finders CLI Flags: --old-finders --magic-placement","title":"Old Finders"},{"location":"docs/configuration/options/#remove-redundant-aliases","text":"Tells isort to remove redundant aliases from imports, such as import os as os . This defaults to False simply because some projects use these seemingly useless aliases to signify intent and change behaviour. Type: Bool Default: False Python & Config File Name: remove_redundant_aliases CLI Flags: --remove-redundant-aliases","title":"Remove Redundant Aliases"},{"location":"docs/configuration/options/#float-to-top","text":"Causes all non-indented imports to float to the top of the file having its imports sorted (immediately below the top of file comment). This can be an excellent shortcut for collecting imports every once in a while when you place them in the middle of a file to avoid context switching. NOTE : It currently doesn't work with cimports and introduces some extra over-head and a performance penalty. Type: Bool Default: False Python & Config File Name: float_to_top CLI Flags: --float-to-top","title":"Float To Top"},{"location":"docs/configuration/options/#filter-files","text":"Tells isort to filter files even when they are explicitly passed in as part of the CLI command. Type: Bool Default: False Python & Config File Name: filter_files CLI Flags: --filter-files","title":"Filter Files"},{"location":"docs/configuration/options/#formatter","text":"Specifies the name of a formatting plugin to use when producing output. Type: String Default: `` Python & Config File Name: formatter CLI Flags: --formatter","title":"Formatter"},{"location":"docs/configuration/options/#formatting-function","text":"No Description Type: Nonetype Default: None Python & Config File Name: formatting_function CLI Flags: Not Supported","title":"Formatting Function"},{"location":"docs/configuration/options/#color-output","text":"Tells isort to use color in terminal output. Type: Bool Default: False Python & Config File Name: color_output CLI Flags: --color","title":"Color Output"},{"location":"docs/configuration/options/#treat-comments-as-code","text":"Tells isort to treat the specified single line comment(s) as if they are code. Type: Frozenset Default: frozenset() Python & Config File Name: treat_comments_as_code CLI Flags: --treat-comment-as-code","title":"Treat Comments As Code"},{"location":"docs/configuration/options/#treat-all-comments-as-code","text":"Tells isort to treat all single line comments as if they are code. Type: Bool Default: False Python & Config File Name: treat_all_comments_as_code CLI Flags: --treat-all-comment-as-code","title":"Treat All Comments As Code"},{"location":"docs/configuration/options/#supported-extensions","text":"Specifies what extensions isort can be ran against. Type: Frozenset Default: ('pxd', 'py', 'pyi', 'pyx') Python & Config File Name: supported_extensions CLI Flags: --ext --extension --supported-extension","title":"Supported Extensions"},{"location":"docs/configuration/options/#blocked-extensions","text":"Specifies what extensions isort can never be ran against. Type: Frozenset Default: ('pex',) Python & Config File Name: blocked_extensions CLI Flags: --blocked-extension","title":"Blocked Extensions"},{"location":"docs/configuration/options/#constants","text":"No Description Type: Frozenset Default: frozenset() Python & Config File Name: constants CLI Flags: Not Supported","title":"Constants"},{"location":"docs/configuration/options/#classes","text":"No Description Type: Frozenset Default: frozenset() Python & Config File Name: classes CLI Flags: Not Supported","title":"Classes"},{"location":"docs/configuration/options/#variables","text":"No Description Type: Frozenset Default: frozenset() Python & Config File Name: variables CLI Flags: Not Supported","title":"Variables"},{"location":"docs/configuration/options/#dedup-headings","text":"Tells isort to only show an identical custom import heading comment once, even if there are multiple sections with the comment set. Type: Bool Default: False Python & Config File Name: dedup_headings CLI Flags: --dedup-headings","title":"Dedup Headings"},{"location":"docs/configuration/options/#only-sections","text":"Causes imports to be sorted only based on their sections like STDLIB,THIRDPARTY etc. Imports are unaltered and keep their relative positions within the different sections. Type: Bool Default: False Python & Config File Name: only_sections CLI Flags: --only-sections --os","title":"Only Sections"},{"location":"docs/configuration/options/#only-modified","text":"Suppresses verbose output for non-modified files. Type: Bool Default: False Python & Config File Name: only_modified CLI Flags: --only-modified --om","title":"Only Modified"},{"location":"docs/configuration/options/#combine-straight-imports","text":"Combines all the bare straight imports of the same section in a single line. Won't work with sections which have 'as' imports Type: Bool Default: False Python & Config File Name: combine_straight_imports CLI Flags: --combine-straight-imports --csi","title":"Combine Straight Imports"},{"location":"docs/configuration/options/#auto-identify-namespace-packages","text":"No Description Type: Bool Default: True Python & Config File Name: auto_identify_namespace_packages CLI Flags: Not Supported","title":"Auto Identify Namespace Packages"},{"location":"docs/configuration/options/#namespace-packages","text":"No Description Type: Frozenset Default: frozenset() Python & Config File Name: namespace_packages CLI Flags: Not Supported","title":"Namespace Packages"},{"location":"docs/configuration/options/#follow-links","text":"No Description Type: Bool Default: True Python & Config File Name: follow_links CLI Flags: Not Supported","title":"Follow Links"},{"location":"docs/configuration/options/#indented-import-headings","text":"No Description Type: Bool Default: True Python & Config File Name: indented_import_headings CLI Flags: Not Supported","title":"Indented Import Headings"},{"location":"docs/configuration/options/#show-version","text":"Displays the currently installed version of isort. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -V --version Examples:","title":"Show Version"},{"location":"docs/configuration/options/#example-cli-usage","text":"isort --version","title":"Example cli usage"},{"location":"docs/configuration/options/#version-number","text":"Returns just the current version number without the logo Type: String Default: ==SUPPRESS== Python & Config File Name: Not Supported CLI Flags: --vn --version-number","title":"Version Number"},{"location":"docs/configuration/options/#write-to-stdout","text":"Force resulting output to stdout, instead of in-place. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -d --stdout","title":"Write To Stdout"},{"location":"docs/configuration/options/#show-config","text":"See isort's determined config, as well as sources of config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-config","title":"Show Config"},{"location":"docs/configuration/options/#show-files","text":"See the files isort will be ran against with the current config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-files","title":"Show Files"},{"location":"docs/configuration/options/#show-diff","text":"Prints a diff of all the changes isort would make to a file, instead of changing it in place Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --df --diff","title":"Show Diff"},{"location":"docs/configuration/options/#check","text":"Checks the file for unsorted / unformatted imports and prints them to the command line without modifying the file. Returns 0 when nothing would change and returns 1 when the file would be reformatted. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: -c --check-only --check","title":"Check"},{"location":"docs/configuration/options/#settings-path","text":"Explicitly set the settings path or file instead of auto determining based on file location. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --sp --settings-path --settings-file --settings","title":"Settings Path"},{"location":"docs/configuration/options/#jobs","text":"Number of files to process in parallel. Type: Int Default: None Python & Config File Name: Not Supported CLI Flags: -j --jobs","title":"Jobs"},{"location":"docs/configuration/options/#ask-to-apply","text":"Tells isort to apply changes interactively. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --interactive","title":"Ask To Apply"},{"location":"docs/configuration/options/#files","text":"One or more Python source files that need their imports sorted. Type: String Default: None Python & Config File Name: Not Supported CLI Flags:","title":"Files"},{"location":"docs/configuration/options/#dont-follow-links","text":"Tells isort not to follow symlinks that are encountered when running recursively. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dont-follow-links","title":"Dont Follow Links"},{"location":"docs/configuration/options/#filename","text":"Provide the filename associated with a stream. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --filename","title":"Filename"},{"location":"docs/configuration/options/#dont-float-to-top","text":"Forces --float-to-top setting off. See --float-to-top for more information. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dont-float-to-top","title":"Dont Float To Top"},{"location":"docs/configuration/options/#dont-order-by-type","text":"Don't order imports by type, which is determined by case, in addition to alphabetically. NOTE : type here refers to the implied type from the import name capitalization. isort does not do type introspection for the imports. These \"types\" are simply: CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8 or a related coding standard and has many imports this is a good default. You can turn this on from the CLI using --order-by-type . Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --dt --dont-order-by-type","title":"Dont Order By Type"},{"location":"docs/configuration/options/#ext-format","text":"Tells isort to format the given files according to an extensions formatting rules. Type: String Default: None Python & Config File Name: Not Supported CLI Flags: --ext-format","title":"Ext Format"},{"location":"docs/configuration/options/#show-files_1","text":"See the files isort will be ran against with the current config options. Type: Bool Default: False Python & Config File Name: Not Supported CLI Flags: --show-files","title":"Show Files"},{"location":"docs/configuration/options/#deprecated-flags","text":"==SUPPRESS== Type: String Default: None Python & Config File Name: Not Supported CLI Flags: -k --keep-direct-and-as","title":"Deprecated Flags"},{"location":"docs/configuration/pre-commit/","text":"Using isort with pre-commit isort provides official support for pre-commit . isort pre-commit step To use isort's official pre-commit integration add the following config: - repo : https : // github . com / pycqa / isort rev : 5.6.3 hooks : - id : isort name : isort ( python ) - id : isort name : isort ( cython ) types : [ cython ] - id : isort name : isort ( pyi ) types : [ pyi ] under the repos section of your projects .pre-commit-config.yaml file. seed-isort-config Older versions of isort used a lot of magic to determine import placement, that could easily break when running on CI/CD. To fix this, a utilitiy called seed-isort-config was created. Since isort 5 however, the project has drastically improved its placement logic and ensured a good level of consistency across environments. If you have a step in your pre-commit config called seed-isort-config or similar, it is highly recommend that you remove this. It is guaranteed to slow things down, and can conflict with isort's own module placement logic.","title":"Pre Commit"},{"location":"docs/configuration/pre-commit/#using-isort-with-pre-commit","text":"isort provides official support for pre-commit .","title":"Using isort with pre-commit"},{"location":"docs/configuration/pre-commit/#isort-pre-commit-step","text":"To use isort's official pre-commit integration add the following config: - repo : https : // github . com / pycqa / isort rev : 5.6.3 hooks : - id : isort name : isort ( python ) - id : isort name : isort ( cython ) types : [ cython ] - id : isort name : isort ( pyi ) types : [ pyi ] under the repos section of your projects .pre-commit-config.yaml file.","title":"isort pre-commit step"},{"location":"docs/configuration/pre-commit/#seed-isort-config","text":"Older versions of isort used a lot of magic to determine import placement, that could easily break when running on CI/CD. To fix this, a utilitiy called seed-isort-config was created. Since isort 5 however, the project has drastically improved its placement logic and ensured a good level of consistency across environments. If you have a step in your pre-commit config called seed-isort-config or similar, it is highly recommend that you remove this. It is guaranteed to slow things down, and can conflict with isort's own module placement logic.","title":"seed-isort-config"},{"location":"docs/configuration/profiles/","text":"Built-in Profile for isort The following profiles are built into isort to allow easy interoperability with common projects and code styles. To use any of the listed profiles, use isort --profile PROFILE_NAME from the command line, or profile=PROFILE_NAME in your configuration file. black multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True ensure_newline_before_comments : True line_length : 88 django combine_as_imports : True include_trailing_comma : True multi_line_output : 5 line_length : 79 pycharm multi_line_output : 3 force_grid_wrap : 2 lines_after_imports : 2 google force_single_line : True force_sort_within_sections : True lexicographical : True single_line_exclusions : ('typing',) order_by_type : False group_by_package : True open_stack force_single_line : True force_sort_within_sections : True lexicographical : True plone force_alphabetical_sort : True force_single_line : True lines_after_imports : 2 line_length : 200 attrs atomic : True force_grid_wrap : 0 include_trailing_comma : True lines_after_imports : 2 lines_between_types : 1 multi_line_output : 3 use_parentheses : True hug multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True line_length : 100 wemake multi_line_output : 3 include_trailing_comma : True use_parentheses : True line_length : 80","title":"Profiles"},{"location":"docs/configuration/profiles/#built-in-profile-for-isort","text":"The following profiles are built into isort to allow easy interoperability with common projects and code styles. To use any of the listed profiles, use isort --profile PROFILE_NAME from the command line, or profile=PROFILE_NAME in your configuration file.","title":"Built-in Profile for isort"},{"location":"docs/configuration/profiles/#black","text":"multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True ensure_newline_before_comments : True line_length : 88","title":"black"},{"location":"docs/configuration/profiles/#django","text":"combine_as_imports : True include_trailing_comma : True multi_line_output : 5 line_length : 79","title":"django"},{"location":"docs/configuration/profiles/#pycharm","text":"multi_line_output : 3 force_grid_wrap : 2 lines_after_imports : 2","title":"pycharm"},{"location":"docs/configuration/profiles/#google","text":"force_single_line : True force_sort_within_sections : True lexicographical : True single_line_exclusions : ('typing',) order_by_type : False group_by_package : True","title":"google"},{"location":"docs/configuration/profiles/#open_stack","text":"force_single_line : True force_sort_within_sections : True lexicographical : True","title":"open_stack"},{"location":"docs/configuration/profiles/#plone","text":"force_alphabetical_sort : True force_single_line : True lines_after_imports : 2 line_length : 200","title":"plone"},{"location":"docs/configuration/profiles/#attrs","text":"atomic : True force_grid_wrap : 0 include_trailing_comma : True lines_after_imports : 2 lines_between_types : 1 multi_line_output : 3 use_parentheses : True","title":"attrs"},{"location":"docs/configuration/profiles/#hug","text":"multi_line_output : 3 include_trailing_comma : True force_grid_wrap : 0 use_parentheses : True line_length : 100","title":"hug"},{"location":"docs/configuration/profiles/#wemake","text":"multi_line_output : 3 include_trailing_comma : True use_parentheses : True line_length : 80","title":"wemake"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to isort Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting isort set up for local development The first step when contributing to any project is getting it set up on your local machine. isort aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) WSL users running Ubuntu may need to install Python's venv module even after installing Python. Once you have verified that your system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/isort.git cd isort poetry install Optionally, isolate poetry's installation from the rest of your system using the instructions on the poetry site here: https://python-poetry.org/docs/#installation ./scripts/test.sh should yield Success: no issues found ./scripts/clean.sh should yield a Safety report checking packages TIP : ./scripts/done.sh will run both clean and test in one step. Docker development If you would instead like to develop using Docker, the only local requirement is docker. See the docker docs if you have not used docker before. Once you have the docker daemon running and have cloned the repository, you can get started by following these steps: cd isort ./scripts/docker.sh A local test cycle might look like the following: docker build ./ -t isort:latest docker run isort if #2 fails, debug, save, and goto #1 docker run -it isort bash will get you into the failed environment docker run -v $(git rev-parse --show-toplevel):/isort will make changes made in the docker environment persist on your local checkout. TIP : combine both to get an interacive docker shell that loads changes made locally, even after build, to quickly rerun that pesky failing test ./scripts/docker.sh if #4 fails, debug, save and goto #1; you may need to specify a different --build-arg VERSION=$VER congrats! you are probably ready to push a contribution Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main isort project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Run tests locally to make sure everything is still working ./scripts/done.sh Or if you are using Docker docker run isort:latest Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by isort contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-isort","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to isort"},{"location":"docs/contributing/1.-contributing-guide/#getting-isort-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. isort aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) WSL users running Ubuntu may need to install Python's venv module even after installing Python. Once you have verified that your system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/isort.git cd isort poetry install Optionally, isolate poetry's installation from the rest of your system using the instructions on the poetry site here: https://python-poetry.org/docs/#installation ./scripts/test.sh should yield Success: no issues found ./scripts/clean.sh should yield a Safety report checking packages TIP : ./scripts/done.sh will run both clean and test in one step.","title":"Getting isort set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#docker-development","text":"If you would instead like to develop using Docker, the only local requirement is docker. See the docker docs if you have not used docker before. Once you have the docker daemon running and have cloned the repository, you can get started by following these steps: cd isort ./scripts/docker.sh A local test cycle might look like the following: docker build ./ -t isort:latest docker run isort if #2 fails, debug, save, and goto #1 docker run -it isort bash will get you into the failed environment docker run -v $(git rev-parse --show-toplevel):/isort will make changes made in the docker environment persist on your local checkout. TIP : combine both to get an interacive docker shell that loads changes made locally, even after build, to quickly rerun that pesky failing test ./scripts/docker.sh if #4 fails, debug, save and goto #1; you may need to specify a different --build-arg VERSION=$VER congrats! you are probably ready to push a contribution","title":"Docker development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main isort project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Run tests locally to make sure everything is still working ./scripts/done.sh Or if you are using Docker docker run isort:latest Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by isort contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Core Developers Aniruddha Bhattacharjee (@anirudnits) Jon Dufresne (@jdufresne) Tamas Szabo (@sztamas) Timothy Edmund Crosley (@timothycrosley) Plugin Writers VIM - Juan Pedro Fisanotti (@fisadev) Emacs - Friedrich Paetzke (@paetzke) Sublime - Thijs de Zoute (@thijsdezoete) Notable Bug Reporters Bengt L\u00fcers (@Bengt) Chris Adams (@acdha) @OddBloke Martin Geisler (@mgeisler) Tim Heap (@timheap) Mat\u011bj Nikl (@MatejNikl) Code Contributors Aaron Gallagher (@habnabit) Thomas Grainger (@graingert) Thijs de Zoute (@thijsdezoete) Marc Abramowitz (@msabramo) Daniel Cowgill (@dcowgill) Francois Lebel (@flebel) Antoni Segura Puimedon (@celebdor) Pablo (@oubiga) Oskar Hahn (@ostcar) Wim Glenn (@wimglenn) Matt Caldwell (@mattcaldwell) Dwayne Bailey (@dwaynebailey) Ionel Cristian M\u0103rie\u0219 (@ionelmc) Chris Adams (@acdha) GuoJing (@GuoJing) George Hickman (@ghickman) Dan Davison (@dandavison) Maciej Wolff (@maciejwo) Elliott Sales de Andrade (@qulogic) Kasper Jacobsen (@dinoshauer) Sebastian Pipping (@hartwork) Helen Sherwood-Taylor (@helenst) Mocker (@Zuckonit) Tim Graham (@timgraham) Adam (@NorthIsUp) Norman J\u00e4ckel (@normanjaeckel) Derrick Petzold (@dpetzold) Michael van Tellingen (@mvantellingen) Patrick Yevsukov (@patrickyevsukov) Christer van der Meeren (@cmeeren) Timon Wong/NHNCN (@timonwong) Jeremy Dunck (@jdunck) Benjamin ABEL (@benjaminabel) Dan Baragan (@danbaragan) Rob Cowie (@robcowie) Amit Shah (@Amwam) Patrick Gerken (@do3cc) @dein0s David Stensland (@terite) Ankur Dedania (@AbsoluteMSTR) Lee Packham (@leepa) Jesse Mullan (@jmullan) Kwok-kuen Cheung (@cheungpat) Johan Bloemberg (@aequitas) Dan Watson (@dcwatson) \u00c9ric Araujo (@merwok) Dan Palmer (@danpalmer) Andy Boot (@bootandy) @m7v8 John Vandenberg (@jayvdb) Adam Chainz (@adamchainz) @Brightcells Jonas Trappenberg (@teeberg) Andrew Konstantaras (@akonsta) Jason Brackman (@jasonbrackman) Kathryn Lingel (@katlings) Andrew Gaul (@gaul) John Chadwick (@jchv) Jon Dufresne (@jdufresne) Brian F. Baron (@briabar) Madison Caldwell (@madirey) Matt Yule-Bennett (@mattbennett) Jaswanth Kumar (@jaswanth098) Dario Navin (@Zarathustra2) Danny Weinberg (@FuegoFro) Gram (@orsinium) Hugo van Kemenade (@hugovk) G\u00e9ry Ogam (@maggyero) Cody Scott (@Siecje) Pedro Algarvio (@s0undt3ch) Chris St. Pierre (@stpierre) Sebastian Rittau (@srittau) Jo\u00e3o M.C. Teixeira (@joaomcteixeira) Honnix (@honnix) Anders Kaseorg (@andersk) @r-richmond Sebastian (@sebix) Kosei Kitahara (@Surgo) Seung Hyeon, Kim (@hyeonjames) Gerard Dalmau (@gdalmau) Robert Tasarz (@rtasarz) Ryo Miyajima (@sergeant-wizard) @mdagaro Maksim Kurnikov (@mkurnikov) Daniel Hahler (@blueyed) @ucodery Aarni Koskela (@akx) Alex Chan (@alexwlchan) Rick Thomas (@richardlthomas) Jeppe Fihl-Pearson (@Tenzer) Jonas Lundberg (@lundberg) Neil (@NeilGirdhar) @dmanikowski-reef Stephen Brown II (@StephenBrown2) Ankur Dedania (@AnkurDedania) Anthony Sottile (@asottile) Bendik Samseth (@bsamseth) Dan W Anderson (@anderson-dan-w) DeepSource Bot (@deepsourcebot) Mitar (@mitar) Omer Katz (@thedrow) Santiago Castro (@bryant1410) Sergey Fursov (@GeyseR) Thomas Robitaille (@astrofrog) Ville Skytt\u00e4 (@scop) Hakan \u00c7elik (@hakancelik96) Dylan Katz (@Plazmaz) Linus Lewandowski (@LEW21) Bastien G\u00e9rard (@bagerard) Brian Dombrowski (@bdombro) Ed Morley (@edmorley) Graeme Coupar (@obmarg) Jerome Leclanche (@jleclanche) Joshu Coats (@rhwlo) Mansour Behabadi (@oxplot) Sam Lai (@slai) Tamas Szabo (@sztamas) Yedidyah Bar David (@didib) Hidetoshi Hirokawa (@h-hirokawa) Aaron Chong (@acjh) Harai Akihiro (@harai) Andy Freeland (@rouge8) @ethifus Joachim Brandon LeBlanc (@demosdemon) Brian May (@brianmay) Bruno Oliveira (@nicoddemus) Bruno Reni\u00e9 (@brutasse) Bryce Guinta (@brycepg) David Chan (@dchanm) David Smith (@smithdc1) Irv Lustig (@Dr-Irv) Dylan Richardson (@dylrich) Emil Melnikov (@emilmelnikov) Eric Johnson (@metrizable) @ryabtsev Felix Yan (@felixonmars) Gil Forcada Codinachs (@gforcada) Ilya Konstantinov (@ikonst) Jace Browning (@jacebrowning) Jin Suk Park (@jinmel) J\u00fcrgen Gmach (@jugmac00) Maciej Gawinecki (@dzieciou) Minn Soe (@MinnSoe) Nikolaus Wittenstein (@adzenith) Norman J. Harman Jr. (@njharman) P R Gurunath (@gurunath-p) Patrick Hayes (@pfhayes) Pete Grayson (@jpgrayson) Philip Jenvey (@pjenvey) Rajiv Bakulesh Shah (@brainix) Reid D McKenzie (@arrdem) Robert DeRose (@RobertDeRose) Roey Darwish Dror (@r-darwish) Rudinei Goi Roecker (@rudineirk) Wagner (@wagner-certat) Nikita Sobolev (@sobolevn) Terence Honles (@terencehonles) The Gitter Badger (@gitter-badger) Tim Gates (@timgates42) Tim Staley (@timstaley) Vincent Hatakeyama (@vincent-hatakeyama) Yaron de Leeuw (@jarondl) @jwg4 @nicolelodeon \u0141ukasz Langa (@ambv) Grzegorz Pstrucha (@Gricha) Zac Hatfield-Dodds (@Zac-HD) Ji\u0159\u00ed \u0160korpil (@JiriSko) James Winegar (@jameswinegar) Abdullah Dursun (@adursun) Guillaume Lostis (@glostis) Krzysztof Jagie\u0142\u0142o (@kjagiello) Nicholas Devenish (@ndevenish) Aniruddha Bhattacharjee (@anirudnits) Alexandre Yang (@AlexandreYang) Andrew Howe (@howeaj) Sang-Heon Jeon (@lntuition) Denis Veselov (@saippuakauppias) James Curtin (@jamescurtin) Marco Gorelli (@MarcoGorelli) Louis Sautier (@sbraz) Timur Kushukov (@timqsh) Bhupesh Varshney (@Bhupesh-V) Rohan Khanna (@rohankhanna) Vasilis Gerakaris (@vgerak) @tonci-bw @jaydesl Tamara (@infinityxxx) Akihiro Nitta (@akihironitta) Samuel Gaist (@sgaist) @dwanderson-intel Quentin Santos (@qsantos) @gofr Pavel Savchenko (@asfaltboy) Documenters Reinout van Rees (@reinout) Helen Sherwood-Taylor (@helenst) Elliott Sales de Andrade (@QuLogic) Brian Peiris (@brianpeiris) Tim Graham (@timgraham) Josh Soref (@jsoref) Teg Khanna (@tegkhanna) Sarah Beth Tracy (@sbtries) Aaron Brown (@aaronvbrown) Harutaka Kawamura (@harupy) Brad Solomon (@bsolomon1124) Martynas Mickevi\u010dius (@2m) Taneli Hukkinen (@hukkinj1) @r-richmond John Villalovos (@JohnVillalovos) Kosei Kitahara (@Surgo) Marat Sharafutdinov (@decaz) Abtin (@abtinmo) @scottwedge Hasan Ramezani (@hramezani) A sincere thanks to everyone who has helped isort be the great utility it is today! It would not be one-hundredth as useful and consistent as it is now without the help of your bug reports, commits, and suggestions. You guys rock! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Aniruddha Bhattacharjee (@anirudnits) Jon Dufresne (@jdufresne) Tamas Szabo (@sztamas) Timothy Edmund Crosley (@timothycrosley)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#plugin-writers","text":"VIM - Juan Pedro Fisanotti (@fisadev) Emacs - Friedrich Paetzke (@paetzke) Sublime - Thijs de Zoute (@thijsdezoete)","title":"Plugin Writers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"Bengt L\u00fcers (@Bengt) Chris Adams (@acdha) @OddBloke Martin Geisler (@mgeisler) Tim Heap (@timheap) Mat\u011bj Nikl (@MatejNikl)","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"Aaron Gallagher (@habnabit) Thomas Grainger (@graingert) Thijs de Zoute (@thijsdezoete) Marc Abramowitz (@msabramo) Daniel Cowgill (@dcowgill) Francois Lebel (@flebel) Antoni Segura Puimedon (@celebdor) Pablo (@oubiga) Oskar Hahn (@ostcar) Wim Glenn (@wimglenn) Matt Caldwell (@mattcaldwell) Dwayne Bailey (@dwaynebailey) Ionel Cristian M\u0103rie\u0219 (@ionelmc) Chris Adams (@acdha) GuoJing (@GuoJing) George Hickman (@ghickman) Dan Davison (@dandavison) Maciej Wolff (@maciejwo) Elliott Sales de Andrade (@qulogic) Kasper Jacobsen (@dinoshauer) Sebastian Pipping (@hartwork) Helen Sherwood-Taylor (@helenst) Mocker (@Zuckonit) Tim Graham (@timgraham) Adam (@NorthIsUp) Norman J\u00e4ckel (@normanjaeckel) Derrick Petzold (@dpetzold) Michael van Tellingen (@mvantellingen) Patrick Yevsukov (@patrickyevsukov) Christer van der Meeren (@cmeeren) Timon Wong/NHNCN (@timonwong) Jeremy Dunck (@jdunck) Benjamin ABEL (@benjaminabel) Dan Baragan (@danbaragan) Rob Cowie (@robcowie) Amit Shah (@Amwam) Patrick Gerken (@do3cc) @dein0s David Stensland (@terite) Ankur Dedania (@AbsoluteMSTR) Lee Packham (@leepa) Jesse Mullan (@jmullan) Kwok-kuen Cheung (@cheungpat) Johan Bloemberg (@aequitas) Dan Watson (@dcwatson) \u00c9ric Araujo (@merwok) Dan Palmer (@danpalmer) Andy Boot (@bootandy) @m7v8 John Vandenberg (@jayvdb) Adam Chainz (@adamchainz) @Brightcells Jonas Trappenberg (@teeberg) Andrew Konstantaras (@akonsta) Jason Brackman (@jasonbrackman) Kathryn Lingel (@katlings) Andrew Gaul (@gaul) John Chadwick (@jchv) Jon Dufresne (@jdufresne) Brian F. Baron (@briabar) Madison Caldwell (@madirey) Matt Yule-Bennett (@mattbennett) Jaswanth Kumar (@jaswanth098) Dario Navin (@Zarathustra2) Danny Weinberg (@FuegoFro) Gram (@orsinium) Hugo van Kemenade (@hugovk) G\u00e9ry Ogam (@maggyero) Cody Scott (@Siecje) Pedro Algarvio (@s0undt3ch) Chris St. Pierre (@stpierre) Sebastian Rittau (@srittau) Jo\u00e3o M.C. Teixeira (@joaomcteixeira) Honnix (@honnix) Anders Kaseorg (@andersk) @r-richmond Sebastian (@sebix) Kosei Kitahara (@Surgo) Seung Hyeon, Kim (@hyeonjames) Gerard Dalmau (@gdalmau) Robert Tasarz (@rtasarz) Ryo Miyajima (@sergeant-wizard) @mdagaro Maksim Kurnikov (@mkurnikov) Daniel Hahler (@blueyed) @ucodery Aarni Koskela (@akx) Alex Chan (@alexwlchan) Rick Thomas (@richardlthomas) Jeppe Fihl-Pearson (@Tenzer) Jonas Lundberg (@lundberg) Neil (@NeilGirdhar) @dmanikowski-reef Stephen Brown II (@StephenBrown2) Ankur Dedania (@AnkurDedania) Anthony Sottile (@asottile) Bendik Samseth (@bsamseth) Dan W Anderson (@anderson-dan-w) DeepSource Bot (@deepsourcebot) Mitar (@mitar) Omer Katz (@thedrow) Santiago Castro (@bryant1410) Sergey Fursov (@GeyseR) Thomas Robitaille (@astrofrog) Ville Skytt\u00e4 (@scop) Hakan \u00c7elik (@hakancelik96) Dylan Katz (@Plazmaz) Linus Lewandowski (@LEW21) Bastien G\u00e9rard (@bagerard) Brian Dombrowski (@bdombro) Ed Morley (@edmorley) Graeme Coupar (@obmarg) Jerome Leclanche (@jleclanche) Joshu Coats (@rhwlo) Mansour Behabadi (@oxplot) Sam Lai (@slai) Tamas Szabo (@sztamas) Yedidyah Bar David (@didib) Hidetoshi Hirokawa (@h-hirokawa) Aaron Chong (@acjh) Harai Akihiro (@harai) Andy Freeland (@rouge8) @ethifus Joachim Brandon LeBlanc (@demosdemon) Brian May (@brianmay) Bruno Oliveira (@nicoddemus) Bruno Reni\u00e9 (@brutasse) Bryce Guinta (@brycepg) David Chan (@dchanm) David Smith (@smithdc1) Irv Lustig (@Dr-Irv) Dylan Richardson (@dylrich) Emil Melnikov (@emilmelnikov) Eric Johnson (@metrizable) @ryabtsev Felix Yan (@felixonmars) Gil Forcada Codinachs (@gforcada) Ilya Konstantinov (@ikonst) Jace Browning (@jacebrowning) Jin Suk Park (@jinmel) J\u00fcrgen Gmach (@jugmac00) Maciej Gawinecki (@dzieciou) Minn Soe (@MinnSoe) Nikolaus Wittenstein (@adzenith) Norman J. Harman Jr. (@njharman) P R Gurunath (@gurunath-p) Patrick Hayes (@pfhayes) Pete Grayson (@jpgrayson) Philip Jenvey (@pjenvey) Rajiv Bakulesh Shah (@brainix) Reid D McKenzie (@arrdem) Robert DeRose (@RobertDeRose) Roey Darwish Dror (@r-darwish) Rudinei Goi Roecker (@rudineirk) Wagner (@wagner-certat) Nikita Sobolev (@sobolevn) Terence Honles (@terencehonles) The Gitter Badger (@gitter-badger) Tim Gates (@timgates42) Tim Staley (@timstaley) Vincent Hatakeyama (@vincent-hatakeyama) Yaron de Leeuw (@jarondl) @jwg4 @nicolelodeon \u0141ukasz Langa (@ambv) Grzegorz Pstrucha (@Gricha) Zac Hatfield-Dodds (@Zac-HD) Ji\u0159\u00ed \u0160korpil (@JiriSko) James Winegar (@jameswinegar) Abdullah Dursun (@adursun) Guillaume Lostis (@glostis) Krzysztof Jagie\u0142\u0142o (@kjagiello) Nicholas Devenish (@ndevenish) Aniruddha Bhattacharjee (@anirudnits) Alexandre Yang (@AlexandreYang) Andrew Howe (@howeaj) Sang-Heon Jeon (@lntuition) Denis Veselov (@saippuakauppias) James Curtin (@jamescurtin) Marco Gorelli (@MarcoGorelli) Louis Sautier (@sbraz) Timur Kushukov (@timqsh) Bhupesh Varshney (@Bhupesh-V) Rohan Khanna (@rohankhanna) Vasilis Gerakaris (@vgerak) @tonci-bw @jaydesl Tamara (@infinityxxx) Akihiro Nitta (@akihironitta) Samuel Gaist (@sgaist) @dwanderson-intel Quentin Santos (@qsantos) @gofr Pavel Savchenko (@asfaltboy)","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"Reinout van Rees (@reinout) Helen Sherwood-Taylor (@helenst) Elliott Sales de Andrade (@QuLogic) Brian Peiris (@brianpeiris) Tim Graham (@timgraham) Josh Soref (@jsoref) Teg Khanna (@tegkhanna) Sarah Beth Tracy (@sbtries) Aaron Brown (@aaronvbrown) Harutaka Kawamura (@harupy) Brad Solomon (@bsolomon1124) Martynas Mickevi\u010dius (@2m) Taneli Hukkinen (@hukkinj1) @r-richmond John Villalovos (@JohnVillalovos) Kosei Kitahara (@Surgo) Marat Sharafutdinov (@decaz) Abtin (@abtinmo) @scottwedge Hasan Ramezani (@hramezani) A sincere thanks to everyone who has helped isort be the great utility it is today! It would not be one-hundredth as useful and consistent as it is now without the help of your bug reports, commits, and suggestions. You guys rock! ~Timothy Crosley","title":"Documenters"},{"location":"docs/major_releases/introducing_isort_5/","text":"Introducing isort 5 isort 5.0.0 is the first major release of isort in over five years and the first significant refactoring of isort since it was conceived more than ten years ago. It's also the first version to require Python 3 (Python 3.6+ at that!) to run - though it can still be run on source files from any version of Python. This does mean that there may be some pain with the upgrade process, but we believe the improvements will be well worth it. Click here for an attempt at full changelog with a list of breaking changes. Using isort 4.x.x? Click here for the isort 5.0.0 upgrade guide. Try isort 5 right now from your browser! So why the massive change? Profile support isort --profile black . isort --profile django . isort --profile pycharm . isort --profile google . isort --profile open_stack . isort --profile plone . isort --profile attrs . isort --profile hug . isort is very configurable. That's great, but it can be overwhelming, both for users and for the isort project. isort now comes with profiles for the most common isort configurations, so you likely will not need to configure anything at all. This also means that as a project, isort can run extensive tests against these specific profiles to ensure nothing breaks over time. Sort imports anywhere import a # <- These are sorted import b b . install ( a ) import os # <- And these are sorted import sys def my_function (): import x # <- Even these are sorted! import z isort 5 will find and sort contiguous section of imports no matter where they are. It also allows you to place code in-between imports without any hacks required. Streaming architecture import a import b ... \u221e isort has been refactored to use a streaming architecture. This means it can sort files of any size (even larger than the Python interpreter supports!) without breaking a sweat. It also means that even when sorting imports in smaller files, it is faster and more resource-efficient. Consistent behavior across all environments Sorting the same file with the same configuration should give you the same output no matter what computer or OS you are running. Extensive effort has been placed around refactoring how modules are placed and how configuration files are loaded to ensure this is the case. Cython support cimport ctime from cpython cimport PyLong_FromVoidPtr from cpython cimport bool as py_bool from cython.operator cimport dereference as deref from cython.operator cimport preincrement as preinc from libc.stdint cimport uint64_t , uintptr_t from libc.stdlib cimport atoi , calloc , free , malloc from libc.string cimport memcpy , strlen from libcpp cimport bool as cpp_bool from libcpp.map cimport map as cpp_map from libcpp.pair cimport pair as cpp_pair from libcpp.string cimport string as cpp_string from libcpp.vector cimport vector as cpp_vector from multimap cimport multimap as cpp_multimap from wstring cimport wstring as cpp_wstring isort 5 adds seamless support for Cython ( .pyx ) files. Action Comments import e import f # isort: off <- Turns isort parsing off import b import a # isort: on <- Turns isort parsing back on import c import d isort 5 adds support for Action Comments which provide a quick and convient way to control the flow of parsing within single source files. First class Python API import isort isort . code ( \"\"\" import b import a \"\"\" ) == \"\"\" import a import b \"\"\" isort now exposes its programmatic API as a first-class citizen. This API makes it easy to extend or use isort in your own Python project. You can see the full documentation for this new API here . Solid base for the future A major focus for the release was to give isort a solid foundation for the next 5-10 years of the project's life. isort has been refactored into functional components that are easily testable. The project now has 100% code coverage. It utilizes tools like Hypothesis to reduce the number of unexpected errors. It went from fully dynamic to fully static typing using mypy. Finally, it utilizes the latest linters both on (like DeepSource ) and offline (like Flake8 ) to help ensure a higher bar for all code contributions into the future. Give 5.0.0 a try! Try isort 5 right now from your browser! OR Install isort locally using pip3 install isort . Click here for full installation instructions.","title":"Introducing Isort 5"},{"location":"docs/major_releases/introducing_isort_5/#introducing-isort-5","text":"isort 5.0.0 is the first major release of isort in over five years and the first significant refactoring of isort since it was conceived more than ten years ago. It's also the first version to require Python 3 (Python 3.6+ at that!) to run - though it can still be run on source files from any version of Python. This does mean that there may be some pain with the upgrade process, but we believe the improvements will be well worth it. Click here for an attempt at full changelog with a list of breaking changes. Using isort 4.x.x? Click here for the isort 5.0.0 upgrade guide. Try isort 5 right now from your browser! So why the massive change?","title":"Introducing isort 5"},{"location":"docs/major_releases/introducing_isort_5/#profile-support","text":"isort --profile black . isort --profile django . isort --profile pycharm . isort --profile google . isort --profile open_stack . isort --profile plone . isort --profile attrs . isort --profile hug . isort is very configurable. That's great, but it can be overwhelming, both for users and for the isort project. isort now comes with profiles for the most common isort configurations, so you likely will not need to configure anything at all. This also means that as a project, isort can run extensive tests against these specific profiles to ensure nothing breaks over time.","title":"Profile support"},{"location":"docs/major_releases/introducing_isort_5/#sort-imports-anywhere","text":"import a # <- These are sorted import b b . install ( a ) import os # <- And these are sorted import sys def my_function (): import x # <- Even these are sorted! import z isort 5 will find and sort contiguous section of imports no matter where they are. It also allows you to place code in-between imports without any hacks required.","title":"Sort imports anywhere"},{"location":"docs/major_releases/introducing_isort_5/#streaming-architecture","text":"import a import b ... \u221e isort has been refactored to use a streaming architecture. This means it can sort files of any size (even larger than the Python interpreter supports!) without breaking a sweat. It also means that even when sorting imports in smaller files, it is faster and more resource-efficient.","title":"Streaming architecture"},{"location":"docs/major_releases/introducing_isort_5/#consistent-behavior-across-all-environments","text":"Sorting the same file with the same configuration should give you the same output no matter what computer or OS you are running. Extensive effort has been placed around refactoring how modules are placed and how configuration files are loaded to ensure this is the case.","title":"Consistent behavior across all environments"},{"location":"docs/major_releases/introducing_isort_5/#cython-support","text":"cimport ctime from cpython cimport PyLong_FromVoidPtr from cpython cimport bool as py_bool from cython.operator cimport dereference as deref from cython.operator cimport preincrement as preinc from libc.stdint cimport uint64_t , uintptr_t from libc.stdlib cimport atoi , calloc , free , malloc from libc.string cimport memcpy , strlen from libcpp cimport bool as cpp_bool from libcpp.map cimport map as cpp_map from libcpp.pair cimport pair as cpp_pair from libcpp.string cimport string as cpp_string from libcpp.vector cimport vector as cpp_vector from multimap cimport multimap as cpp_multimap from wstring cimport wstring as cpp_wstring isort 5 adds seamless support for Cython ( .pyx ) files.","title":"Cython support"},{"location":"docs/major_releases/introducing_isort_5/#action-comments","text":"import e import f # isort: off <- Turns isort parsing off import b import a # isort: on <- Turns isort parsing back on import c import d isort 5 adds support for Action Comments which provide a quick and convient way to control the flow of parsing within single source files.","title":"Action Comments"},{"location":"docs/major_releases/introducing_isort_5/#first-class-python-api","text":"import isort isort . code ( \"\"\" import b import a \"\"\" ) == \"\"\" import a import b \"\"\" isort now exposes its programmatic API as a first-class citizen. This API makes it easy to extend or use isort in your own Python project. You can see the full documentation for this new API here .","title":"First class Python API"},{"location":"docs/major_releases/introducing_isort_5/#solid-base-for-the-future","text":"A major focus for the release was to give isort a solid foundation for the next 5-10 years of the project's life. isort has been refactored into functional components that are easily testable. The project now has 100% code coverage. It utilizes tools like Hypothesis to reduce the number of unexpected errors. It went from fully dynamic to fully static typing using mypy. Finally, it utilizes the latest linters both on (like DeepSource ) and offline (like Flake8 ) to help ensure a higher bar for all code contributions into the future.","title":"Solid base for the future"},{"location":"docs/major_releases/introducing_isort_5/#give-500-a-try","text":"Try isort 5 right now from your browser! OR Install isort locally using pip3 install isort . Click here for full installation instructions.","title":"Give 5.0.0 a try!"},{"location":"docs/major_releases/release_policy/","text":"isort Project Official Release Policy isort has moved from being a simple hobby project for individuals to sort imports in their Python files to an essential part of the CI/CD pipeline for large companies and significant Open Source projects. Due to this evolution, it is now of increased importance that isort maintains a level of quality, predictability, and consistency that gives projects big and small confidence to depend on it. Formatting guarantees With isort 5.1.0, the isort Project guarantees that formatting will stay the same for the options given in accordance to its test suite for the duration of all major releases. This means projects can safely use isort > 5.1.0 < 6.0.0 without worrying about major formatting changes disrupting their Project. Packaging guarantees Starting with the 5.0.0 release isort includes the following project guarantees to help guide development: isort will never have dependencies, optional, required, or otherwise. isort will always act the same independent to the Python environment it is installed in. Versioning isort follows the Semantic Versioning 2.0.0 specification meaning it has three numerical version parts with distinct rules MAJOR.MINOR.PATCH . Patch Releases x.x.1 Within the isort Project, patch releases are really meant solely to fix bugs and minor oversights. Patch releases should never drastically change formatting, even if it's for the better. Minor Releases x.1.x Minor changes can contain new backward-incompatible features, and of particular note can include bug fixes that result in intentional formatting changes - but they should still never be too large in scope. API backward compatibility should strictly be maintained. Major Releases 1.x.x Major releases are the only place where backward-incompatible changes or substantial formatting changes can occur. Because these kind of changes are likely to break projects that utilize isort, either as a formatter or library, isort must do the following: Release a release candidate with at least 2 weeks for bugs to be reported and fixed. Keep releasing follow up release candidates until there are no or few bugs reported. Provide an upgrade guide that helps users work around any backward-incompatible changes. Provide a detailed changelog of all changes. Where possible, warn and point to the upgrade guide instead of breaking when options are removed.","title":"Release Policy"},{"location":"docs/major_releases/release_policy/#isort-project-official-release-policy","text":"isort has moved from being a simple hobby project for individuals to sort imports in their Python files to an essential part of the CI/CD pipeline for large companies and significant Open Source projects. Due to this evolution, it is now of increased importance that isort maintains a level of quality, predictability, and consistency that gives projects big and small confidence to depend on it.","title":"isort Project Official Release Policy"},{"location":"docs/major_releases/release_policy/#formatting-guarantees","text":"With isort 5.1.0, the isort Project guarantees that formatting will stay the same for the options given in accordance to its test suite for the duration of all major releases. This means projects can safely use isort > 5.1.0 < 6.0.0 without worrying about major formatting changes disrupting their Project.","title":"Formatting guarantees"},{"location":"docs/major_releases/release_policy/#packaging-guarantees","text":"Starting with the 5.0.0 release isort includes the following project guarantees to help guide development: isort will never have dependencies, optional, required, or otherwise. isort will always act the same independent to the Python environment it is installed in.","title":"Packaging guarantees"},{"location":"docs/major_releases/release_policy/#versioning","text":"isort follows the Semantic Versioning 2.0.0 specification meaning it has three numerical version parts with distinct rules MAJOR.MINOR.PATCH .","title":"Versioning"},{"location":"docs/major_releases/release_policy/#patch-releases-xx1","text":"Within the isort Project, patch releases are really meant solely to fix bugs and minor oversights. Patch releases should never drastically change formatting, even if it's for the better.","title":"Patch Releases x.x.1"},{"location":"docs/major_releases/release_policy/#minor-releases-x1x","text":"Minor changes can contain new backward-incompatible features, and of particular note can include bug fixes that result in intentional formatting changes - but they should still never be too large in scope. API backward compatibility should strictly be maintained.","title":"Minor Releases x.1.x"},{"location":"docs/major_releases/release_policy/#major-releases-1xx","text":"Major releases are the only place where backward-incompatible changes or substantial formatting changes can occur. Because these kind of changes are likely to break projects that utilize isort, either as a formatter or library, isort must do the following: Release a release candidate with at least 2 weeks for bugs to be reported and fixed. Keep releasing follow up release candidates until there are no or few bugs reported. Provide an upgrade guide that helps users work around any backward-incompatible changes. Provide a detailed changelog of all changes. Where possible, warn and point to the upgrade guide instead of breaking when options are removed.","title":"Major Releases 1.x.x"},{"location":"docs/quick_start/0.-try/","text":"Try isort from your browser! Use our live isort editor to see how isort can help improve the formatting of your Python imports. Safe to use. No code is transmitted. The below live isort tester doesn't transmit any of the code you paste to our server or anyone else's. Instead, this page runs a complete Python3 installation with isort installed entirely within your browser. To accomplish this, it utilizes the pyodide project. // set the pyodide files URL (packages.json, pyodide.asm.data etc) window.languagePluginUrl = 'https://pyodide-cdn2.iodide.io/v0.15.0/full/'; from future import braces import b import b import os import a from future import braces import b import a import b, a Loading... Configuration (Note: the below must follow JSON format). Full configuration guide is here : {\"line_length\": 80, \"profile\": \"black\", \"atomic\": true } Like what you saw? Installing isort to use locally is as simple as pip3 install isort . Click here for full installation instructions.","title":"0. Try"},{"location":"docs/quick_start/0.-try/#try-isort-from-your-browser","text":"Use our live isort editor to see how isort can help improve the formatting of your Python imports. Safe to use. No code is transmitted. The below live isort tester doesn't transmit any of the code you paste to our server or anyone else's. Instead, this page runs a complete Python3 installation with isort installed entirely within your browser. To accomplish this, it utilizes the pyodide project. // set the pyodide files URL (packages.json, pyodide.asm.data etc) window.languagePluginUrl = 'https://pyodide-cdn2.iodide.io/v0.15.0/full/'; from future import braces import b import b import os import a from future import braces import b import a import b, a Loading... Configuration (Note: the below must follow JSON format). Full configuration guide is here : {\"line_length\": 80, \"profile\": \"black\", \"atomic\": true } Like what you saw? Installing isort to use locally is as simple as pip3 install isort . Click here for full installation instructions.","title":"Try isort from your browser!"},{"location":"docs/quick_start/1.-install/","text":"Install isort using your preferred Python package manager: pip3 install isort OR poetry add isort OR pipenv install isort OR For a fully isolated user installation you can use pipx pipx install isort Tip If you want isort to act as a linter for projects, it probably makes since to add isort as an explicit development dependency for each project that uses it. If, on the other hand, you are an individual developer simply using isort as a personal tool to clean up your own commits, a global or user level installation makes sense. Both are seamlessly supported on a single machine.","title":"1. Install"},{"location":"docs/quick_start/2.-cli/","text":"Command Line Usage Once installed, isort exposes a command line utility for sorting, organizing, and formatting imports within Python and Cython source files. To verify the tool is installed correctly, run isort from the command line and you should be given the available commands and the version of isort installed. For a list of all CLI options type isort --help or view the online configuration reference : Formatting a Project In general, isort is most commonly utilized across an entire projects source at once. The simplest way to do this is isort . or if using a src directory isort src . isort will automatically find all Python source files recursively and pick-up a configuration file placed at the root of your project if present. This can be combined with any command line configuration customizations such as specifying a profile to use ( isort . --profile black ). Verifying a Project The second most common usage of isort is verifying that imports within a project are formatted correctly (often within the context of a CI/CD system). The simplest way to accomplish this is using the check command line option: isort --check . . To improve the usefulness of errors when they do occur, this can be combined with the diff option: isort --check --diff . . Single Source Files Finally, isort can just as easily be ran against individual source files. Simply pass in a single or multiple source files to sort or validate (Example: isort setup.py ). Multiple Projects Running a single isort command across multiple projects, or source files spanning multiple projects, is highly discouraged. Instead it is recommended that an isort process (or command) is ran for each project independently. This is because isort creates an immutable config for each CLI instance. # YES isort project1 isort project2 # Also YES isort project1 / src project1 / test isort project2 / src project2 / test # NO isort project1 project2","title":"2. Cli"},{"location":"docs/quick_start/2.-cli/#command-line-usage","text":"Once installed, isort exposes a command line utility for sorting, organizing, and formatting imports within Python and Cython source files. To verify the tool is installed correctly, run isort from the command line and you should be given the available commands and the version of isort installed. For a list of all CLI options type isort --help or view the online configuration reference :","title":"Command Line Usage"},{"location":"docs/quick_start/2.-cli/#formatting-a-project","text":"In general, isort is most commonly utilized across an entire projects source at once. The simplest way to do this is isort . or if using a src directory isort src . isort will automatically find all Python source files recursively and pick-up a configuration file placed at the root of your project if present. This can be combined with any command line configuration customizations such as specifying a profile to use ( isort . --profile black ).","title":"Formatting a Project"},{"location":"docs/quick_start/2.-cli/#verifying-a-project","text":"The second most common usage of isort is verifying that imports within a project are formatted correctly (often within the context of a CI/CD system). The simplest way to accomplish this is using the check command line option: isort --check . . To improve the usefulness of errors when they do occur, this can be combined with the diff option: isort --check --diff . .","title":"Verifying a Project"},{"location":"docs/quick_start/2.-cli/#single-source-files","text":"Finally, isort can just as easily be ran against individual source files. Simply pass in a single or multiple source files to sort or validate (Example: isort setup.py ).","title":"Single Source Files"},{"location":"docs/quick_start/2.-cli/#multiple-projects","text":"Running a single isort command across multiple projects, or source files spanning multiple projects, is highly discouraged. Instead it is recommended that an isort process (or command) is ran for each project independently. This is because isort creates an immutable config for each CLI instance. # YES isort project1 isort project2 # Also YES isort project1 / src project1 / test isort project2 / src project2 / test # NO isort project1 project2","title":"Multiple Projects"},{"location":"docs/quick_start/3.-api/","text":"Programmatic Python API Usage In addition to the powerful command line interface, isort exposes a complete Python API. To use the Python API, import isort and then call the desired function call: Every function is fully type hinted and requires and returns only builtin Python objects. Highlights include: isort.code - Takes a string containing code, and returns it with imports sorted. isort.check_code - Takes a string containing code, and returns True if all imports are sorted correctly, otherwise, False . isort.stream - Takes an input stream containing Python code and an output stream. Outputs code to output stream with all imports sorted. isort.stream - Takes an input stream containing Python code and returns True if all imports in the stream are sorted correctly, otherwise, False . isort.file - Takes the path of a Python source file and sorts the imports in-place. isort.check_file - Takes the path of a Python source file and returns True if all imports contained within are sorted correctly, otherwise, False . isort.place_module - Takes the name of a module as a string and returns the categorization determined for it. isort.place_module_with_reason - Takes the name of a module as a string and returns the categorization determined for it and why that categorization was given. For a full definition of the API see the API reference documentation or try help(isort) from an interactive interpreter.","title":"3. Api"},{"location":"docs/quick_start/3.-api/#programmatic-python-api-usage","text":"In addition to the powerful command line interface, isort exposes a complete Python API. To use the Python API, import isort and then call the desired function call: Every function is fully type hinted and requires and returns only builtin Python objects. Highlights include: isort.code - Takes a string containing code, and returns it with imports sorted. isort.check_code - Takes a string containing code, and returns True if all imports are sorted correctly, otherwise, False . isort.stream - Takes an input stream containing Python code and an output stream. Outputs code to output stream with all imports sorted. isort.stream - Takes an input stream containing Python code and returns True if all imports in the stream are sorted correctly, otherwise, False . isort.file - Takes the path of a Python source file and sorts the imports in-place. isort.check_file - Takes the path of a Python source file and returns True if all imports contained within are sorted correctly, otherwise, False . isort.place_module - Takes the name of a module as a string and returns the categorization determined for it. isort.place_module_with_reason - Takes the name of a module as a string and returns the categorization determined for it and why that categorization was given. For a full definition of the API see the API reference documentation or try help(isort) from an interactive interpreter.","title":"Programmatic Python API Usage"},{"location":"docs/upgrade_guides/5.0.0/","text":"Upgrading to 5.0.0 isort 5.0.0 is the first major release of isort in 5 years, and as such it does introduce some breaking changes. This guide is meant to help migrate projects from using isort 4.x.x unto the 5.0.0 release. Related documentation: isort 5.0.0 changelog isort 5 release document If you use pre-commit remove seed-isort-config. If you currently use pre-commit, make sure to see the pre-commit section of this document. In particular, make sure to remove any seed-isort-config pre-step. Imports no Longer Moved to Top One of the most immediately evident changes when upgrading to isort 5, is it now avoids moving imports around code by default. The great thing about this is that it means that isort can safely run against complex code bases that need to place side effects between import sections without needing any comments, flags, or configs. It's also part of the rearchitecting that allows it to sort within type checking conditionals and functions. However, it can be a jarring change for those of us who have gotten used to placing imports right above their usage in code to avoid context switching. No need to worry! isort still supports this work mode. If you want to move all imports to the top, you can use the new --float-to-top flag in the CLI or float_to_top=true option in your config file. See: https://pycqa.github.io/isort/docs/configuration/options/#float-to-top Migrating CLI options --dont-skip or -ns In an earlier version isort had a default skip of __init__.py . To get around that many projects wanted a way to not skip __init__.py or any other files that were automatically skipped in the future by isort. isort no longer has any default skips, so if the value here is __init__.py you can simply remove the command line option. If it is something else, just make sure you aren't specifying to skip that file somewhere else in your config. --recursive or -rc Prior to version 5.0.0, isort wouldn't automatically traverse directories. The --recursive option was necessary to tell it to do so. In 5.0.0 directories are automatically traversed for all Python files, and as such this option is no longer necessary and should simply be removed. --apply or -y Prior to version 5.0.0, depending on how isort was executed, it would ask you before making every file change. In isort 5.0.0 file changes happen by default inline with other formatters. --interactive is available to restore the previous behavior. If encountered this option can simply be removed. --keep-direct-and-as or -k Many versions ago, by default isort would remove imports such as from datetime import datetime if an alias for the same import also existed such as from datetime import datetime as dt - never allowing both to exist. The option was originally added to allow working around this, and was then turned on as the default. Now the option for the old behaviour has been removed. Simply remove the option from your config file. -ac , -wl , -ws , -tc , -sp , -sp , -sl , -sg , -sd , -rr , -ot , -nlb , -nis , -ls , -le , -lbt , -lai , -fss , -fgw , -ff , -fass , -fas , -dt , -ds , -df , -cs , -ca , -af , -ac Two-letter shortened setting names (like ac for atomic ) now require two dashes to avoid ambiguity. Simply add another dash before the option, or switch to the long form option to fix (example: --ac or --atomic ). -v and -V The -v (previously for version now for verbose) and -V (previously for verbose and now for version) options have been swapped to be more consistent with tools across the CLI and in particular Python ecosystem. Migrating Config options The first thing to keep in mind is how isort loads config options has changed in isort 5. It will no longer merge multiple config files, instead you must have 1 isort config per a project. If you have multiple configs, they will need to be merged into 1 single one. You can see the priority order of configuration files and the manner in which they are loaded on the config files documentation page . Config options are loaded relative to the file, not the isort instance. isort looks for a config file based on the path of the file you request to sort. If you have your config placed outside of the project, you can use --settings-path to manually specify the config location instead. Full information about how config files are loaded is in the linked config files documentation page. not_skip This is the same as the --dont-skip CLI option above. In an earlier version isort had a default skip of __init__.py . To get around that many projects wanted a way to not skip __init__.py or any other files that were automatically skipped in the future by isort. isort no longer has any default skips, so if the value here is __init__.py you can simply remove the setting. If it is something else, just make sure you aren't specifying to skip that file somewhere else in your config. keep_direct_and_as_imports This is the same as keep-direct-and-as from CLI. Many versions ago, by default isort would remove imports such as from datetime import datetime if an alias for the same import also existed such as from datetime import datetime as dt - never allowing both to exist. The option was originally added to allow working around this, and was then turned on as the default. Now the option for the old behaviour has been removed. Simply remove the option from your config file. known_standard_library isort settings no longer merge together, instead they override. The old behavior of merging together caused many hard to track down errors, but the one place it was very convenient was for adding a few additional standard library modules. In isort 5, you can still get this behavior by moving your extra modules from the known_standard_library setting to extra_standard_library . module placement changes: known_third_party , known_first_party , default_section , etc... isort has completely rewritten its logic for placing modules in 5.0.0 to ensure the same behavior across environments. You can see the details of this change here . The TL;DR of which is that isort has now changed from default_section=FIRSTPARTY to default_section=THIRDPARTY . If you all already setting the default section to third party, your config is probably in good shape. If not, you can either use the old finding approach with --magic-placement in the CLI or old_finders=True in your config, or preferably, you are able to remove all placement options and isort will determine it correctly. If it doesn't, you should be able to just specify your projects modules with known_first_party and be done with it. Migrating pre-commit seed-isort-config If you have a step in your precommit called seed-isort-config or similar, it is highly recommend that you remove this. It is unnecessary in 5.x.x, is guaranteed to slow things down, and worse can conflict with isort's own module placement logic. isort pre-commit step isort now includes an optimized precommit configuration in the repo itself. To use it you can replace any existing isort precommit step with: - repo : https : // github . com / pycqa / isort rev : 5.6.3 hooks : - id : isort name : isort ( python ) - id : isort name : isort ( cython ) types : [ cython ] - id : isort name : isort ( pyi ) types : [ pyi ] under the repos section of your projects .pre-commit-config.yaml config.","title":"5.0.0"},{"location":"docs/upgrade_guides/5.0.0/#upgrading-to-500","text":"isort 5.0.0 is the first major release of isort in 5 years, and as such it does introduce some breaking changes. This guide is meant to help migrate projects from using isort 4.x.x unto the 5.0.0 release. Related documentation: isort 5.0.0 changelog isort 5 release document If you use pre-commit remove seed-isort-config. If you currently use pre-commit, make sure to see the pre-commit section of this document. In particular, make sure to remove any seed-isort-config pre-step.","title":"Upgrading to 5.0.0"},{"location":"docs/upgrade_guides/5.0.0/#imports-no-longer-moved-to-top","text":"One of the most immediately evident changes when upgrading to isort 5, is it now avoids moving imports around code by default. The great thing about this is that it means that isort can safely run against complex code bases that need to place side effects between import sections without needing any comments, flags, or configs. It's also part of the rearchitecting that allows it to sort within type checking conditionals and functions. However, it can be a jarring change for those of us who have gotten used to placing imports right above their usage in code to avoid context switching. No need to worry! isort still supports this work mode. If you want to move all imports to the top, you can use the new --float-to-top flag in the CLI or float_to_top=true option in your config file. See: https://pycqa.github.io/isort/docs/configuration/options/#float-to-top","title":"Imports no Longer Moved to Top"},{"location":"docs/upgrade_guides/5.0.0/#migrating-cli-options","text":"","title":"Migrating CLI options"},{"location":"docs/upgrade_guides/5.0.0/#-dont-skip-or-ns","text":"In an earlier version isort had a default skip of __init__.py . To get around that many projects wanted a way to not skip __init__.py or any other files that were automatically skipped in the future by isort. isort no longer has any default skips, so if the value here is __init__.py you can simply remove the command line option. If it is something else, just make sure you aren't specifying to skip that file somewhere else in your config.","title":"--dont-skip or -ns"},{"location":"docs/upgrade_guides/5.0.0/#-recursive-or-rc","text":"Prior to version 5.0.0, isort wouldn't automatically traverse directories. The --recursive option was necessary to tell it to do so. In 5.0.0 directories are automatically traversed for all Python files, and as such this option is no longer necessary and should simply be removed.","title":"--recursive or -rc"},{"location":"docs/upgrade_guides/5.0.0/#-apply-or-y","text":"Prior to version 5.0.0, depending on how isort was executed, it would ask you before making every file change. In isort 5.0.0 file changes happen by default inline with other formatters. --interactive is available to restore the previous behavior. If encountered this option can simply be removed.","title":"--apply or -y"},{"location":"docs/upgrade_guides/5.0.0/#-keep-direct-and-as-or-k","text":"Many versions ago, by default isort would remove imports such as from datetime import datetime if an alias for the same import also existed such as from datetime import datetime as dt - never allowing both to exist. The option was originally added to allow working around this, and was then turned on as the default. Now the option for the old behaviour has been removed. Simply remove the option from your config file.","title":"--keep-direct-and-as or -k"},{"location":"docs/upgrade_guides/5.0.0/#-ac-wl-ws-tc-sp-sp-sl-sg-sd-rr-ot-nlb-nis-ls-le-lbt-lai-fss-fgw-ff-fass-fas-dt-ds-df-cs-ca-af-ac","text":"Two-letter shortened setting names (like ac for atomic ) now require two dashes to avoid ambiguity. Simply add another dash before the option, or switch to the long form option to fix (example: --ac or --atomic ).","title":"-ac, -wl, -ws, -tc, -sp, -sp, -sl, -sg, -sd, -rr, -ot, -nlb, -nis, -ls, -le, -lbt, -lai, -fss, -fgw, -ff, -fass, -fas, -dt, -ds, -df, -cs, -ca, -af, -ac"},{"location":"docs/upgrade_guides/5.0.0/#-v-and-v","text":"The -v (previously for version now for verbose) and -V (previously for verbose and now for version) options have been swapped to be more consistent with tools across the CLI and in particular Python ecosystem.","title":"-v and -V"},{"location":"docs/upgrade_guides/5.0.0/#migrating-config-options","text":"The first thing to keep in mind is how isort loads config options has changed in isort 5. It will no longer merge multiple config files, instead you must have 1 isort config per a project. If you have multiple configs, they will need to be merged into 1 single one. You can see the priority order of configuration files and the manner in which they are loaded on the config files documentation page . Config options are loaded relative to the file, not the isort instance. isort looks for a config file based on the path of the file you request to sort. If you have your config placed outside of the project, you can use --settings-path to manually specify the config location instead. Full information about how config files are loaded is in the linked config files documentation page.","title":"Migrating Config options"},{"location":"docs/upgrade_guides/5.0.0/#not_skip","text":"This is the same as the --dont-skip CLI option above. In an earlier version isort had a default skip of __init__.py . To get around that many projects wanted a way to not skip __init__.py or any other files that were automatically skipped in the future by isort. isort no longer has any default skips, so if the value here is __init__.py you can simply remove the setting. If it is something else, just make sure you aren't specifying to skip that file somewhere else in your config.","title":"not_skip"},{"location":"docs/upgrade_guides/5.0.0/#keep_direct_and_as_imports","text":"This is the same as keep-direct-and-as from CLI. Many versions ago, by default isort would remove imports such as from datetime import datetime if an alias for the same import also existed such as from datetime import datetime as dt - never allowing both to exist. The option was originally added to allow working around this, and was then turned on as the default. Now the option for the old behaviour has been removed. Simply remove the option from your config file.","title":"keep_direct_and_as_imports"},{"location":"docs/upgrade_guides/5.0.0/#known_standard_library","text":"isort settings no longer merge together, instead they override. The old behavior of merging together caused many hard to track down errors, but the one place it was very convenient was for adding a few additional standard library modules. In isort 5, you can still get this behavior by moving your extra modules from the known_standard_library setting to extra_standard_library .","title":"known_standard_library"},{"location":"docs/upgrade_guides/5.0.0/#module-placement-changes-known_third_party-known_first_party-default_section-etc","text":"isort has completely rewritten its logic for placing modules in 5.0.0 to ensure the same behavior across environments. You can see the details of this change here . The TL;DR of which is that isort has now changed from default_section=FIRSTPARTY to default_section=THIRDPARTY . If you all already setting the default section to third party, your config is probably in good shape. If not, you can either use the old finding approach with --magic-placement in the CLI or old_finders=True in your config, or preferably, you are able to remove all placement options and isort will determine it correctly. If it doesn't, you should be able to just specify your projects modules with known_first_party and be done with it.","title":"module placement changes: known_third_party, known_first_party, default_section, etc..."},{"location":"docs/upgrade_guides/5.0.0/#migrating-pre-commit","text":"","title":"Migrating pre-commit"},{"location":"docs/upgrade_guides/5.0.0/#seed-isort-config","text":"If you have a step in your precommit called seed-isort-config or similar, it is highly recommend that you remove this. It is unnecessary in 5.x.x, is guaranteed to slow things down, and worse can conflict with isort's own module placement logic.","title":"seed-isort-config"},{"location":"docs/upgrade_guides/5.0.0/#isort-pre-commit-step","text":"isort now includes an optimized precommit configuration in the repo itself. To use it you can replace any existing isort precommit step with: - repo : https : // github . com / pycqa / isort rev : 5.6.3 hooks : - id : isort name : isort ( python ) - id : isort name : isort ( cython ) types : [ cython ] - id : isort name : isort ( pyi ) types : [ pyi ] under the repos section of your projects .pre-commit-config.yaml config.","title":"isort pre-commit step"},{"location":"docs/warning_and_error_codes/W0500/","text":"W0500 Warning Codes The W0500 error codes are reserved for warnings related to a major release of the isort project. Generally, the existence of any of these will trigger one additional warning listing the upgrade guide. For the most recent upgrade guide, see: The 5.0.0 Upgrade Guide. . W0501: Deprecated CLI flags were included that will be ignored. This warning will be shown if a CLI flag is passed into the isort command that is no longer supported but can safely be ignored. Often, this happens because an argument used to be required to turn on a feature that then became the default. An example of this is --recursive which became the default behavior for all folders passed-in starting with 5.0.0. W0502: Deprecated CLI flags were included that will safely be remapped. This warning will be shown if a CLI flag is passed into the isort command that is no longer supported but can safely be remapped to the new version of the flag. If you encounter this warning, you must update the argument to match the new flag before the next major release. W0503: Deprecated config options were ignored. This warning will be shown if a deprecated config option is defined in the Project's isort config file, but can safely be ignored. This is similar to W0500 but dealing with config files rather than CLI flags.","title":"W0500"},{"location":"docs/warning_and_error_codes/W0500/#w0500-warning-codes","text":"The W0500 error codes are reserved for warnings related to a major release of the isort project. Generally, the existence of any of these will trigger one additional warning listing the upgrade guide. For the most recent upgrade guide, see: The 5.0.0 Upgrade Guide. .","title":"W0500 Warning Codes"},{"location":"docs/warning_and_error_codes/W0500/#w0501-deprecated-cli-flags-were-included-that-will-be-ignored","text":"This warning will be shown if a CLI flag is passed into the isort command that is no longer supported but can safely be ignored. Often, this happens because an argument used to be required to turn on a feature that then became the default. An example of this is --recursive which became the default behavior for all folders passed-in starting with 5.0.0.","title":"W0501: Deprecated CLI flags were included that will be ignored."},{"location":"docs/warning_and_error_codes/W0500/#w0502-deprecated-cli-flags-were-included-that-will-safely-be-remapped","text":"This warning will be shown if a CLI flag is passed into the isort command that is no longer supported but can safely be remapped to the new version of the flag. If you encounter this warning, you must update the argument to match the new flag before the next major release.","title":"W0502: Deprecated CLI flags were included that will safely be remapped."},{"location":"docs/warning_and_error_codes/W0500/#w0503-deprecated-config-options-were-ignored","text":"This warning will be shown if a deprecated config option is defined in the Project's isort config file, but can safely be ignored. This is similar to W0500 but dealing with config files rather than CLI flags.","title":"W0503: Deprecated config options were ignored."},{"location":"reference/isort/","text":"Module isort Defines the public isort interface View Source \"\"\"Defines the public isort interface\"\"\" from . import settings from ._version import __version__ from .api import ImportKey from .api import check_code_string as check_code from .api import ( check_file , check_stream , find_imports_in_code , find_imports_in_file , find_imports_in_paths , find_imports_in_stream , place_module , place_module_with_reason , ) from .api import sort_code_string as code from .api import sort_file as file from .api import sort_stream as stream from .settings import Config Sub-modules isort.api isort.comments isort.core isort.deprecated isort.exceptions isort.files isort.format isort.hooks isort.identify isort.io isort.literal isort.logo isort.main isort.output isort.parse isort.place isort.profiles isort.pylama_isort isort.sections isort.settings isort.setuptools_commands isort.sorting isort.stdlibs isort.utils isort.wrap isort.wrap_modes","title":"Index"},{"location":"reference/isort/#module-isort","text":"Defines the public isort interface View Source \"\"\"Defines the public isort interface\"\"\" from . import settings from ._version import __version__ from .api import ImportKey from .api import check_code_string as check_code from .api import ( check_file , check_stream , find_imports_in_code , find_imports_in_file , find_imports_in_paths , find_imports_in_stream , place_module , place_module_with_reason , ) from .api import sort_code_string as code from .api import sort_file as file from .api import sort_stream as stream from .settings import Config","title":"Module isort"},{"location":"reference/isort/#sub-modules","text":"isort.api isort.comments isort.core isort.deprecated isort.exceptions isort.files isort.format isort.hooks isort.identify isort.io isort.literal isort.logo isort.main isort.output isort.parse isort.place isort.profiles isort.pylama_isort isort.sections isort.settings isort.setuptools_commands isort.sorting isort.stdlibs isort.utils isort.wrap isort.wrap_modes","title":"Sub-modules"},{"location":"reference/isort/api/","text":"Module isort.api View Source import shutil import sys from enum import Enum from io import StringIO from itertools import chain from pathlib import Path from typing import Iterator , Optional , Set , TextIO , Union , cast from warnings import warn from isort import core from . import files , identify , io from .exceptions import ( ExistingSyntaxErrors , FileSkipComment , FileSkipSetting , IntroducedSyntaxErrors , ) from .format import ask_whether_to_apply_changes_to_file , create_terminal_printer , show_unified_diff from .io import Empty from .place import module as place_module # noqa: F401 from .place import module_with_reason as place_module_with_reason # noqa: F401 from .settings import DEFAULT_CONFIG , Config class ImportKey ( Enum ): \"\"\"Defines how to key an individual import, generally for deduping. Import keys are defined from less to more specific: from x.y import z as a ______| | | | | | | | PACKAGE | | | ________| | | | | | MODULE | | _________________| | | | ATTRIBUTE | ______________________| | ALIAS \"\"\" PACKAGE = 1 MODULE = 2 ATTRIBUTE = 3 ALIAS = 4 def sort_code_string ( code : str , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\"\" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , show_diff = show_diff , ) output_stream . seek ( 0 ) return output_stream . read () def check_code_string ( code : str , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ) -> bool : \"\"\"Sorts any imports within the provided code stream, outputs to the provided output stream. Returns `True` if anything is modified from the original input stream, otherwise `False`. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\"\" if show_diff : _output_stream = StringIO () _input_stream = StringIO ( input_stream . read ()) changed = sort_stream ( input_stream = _input_stream , output_stream = _output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ** config_kwargs , ) _output_stream . seek ( 0 ) _input_stream . seek ( 0 ) show_unified_diff ( file_input = _input_stream . read (), file_output = _output_stream . read (), file_path = file_path , output = output_stream if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return changed config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ): raise FileSkipSetting ( content_source ) _internal_output = output_stream if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) if not output_stream . readable (): _internal_output = StringIO () try : changed = core . process ( input_stream , _internal_output , extension = extension or ( file_path and file_path . suffix . lstrip ( \".\" )) or \"py\" , config = config , ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : _internal_output . seek ( 0 ) try : compile ( _internal_output . read (), content_source , \"exec\" , 0 , 1 ) _internal_output . seek ( 0 ) if _internal_output != output_stream : output_stream . write ( _internal_output . read ()) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed def check_stream ( input_stream : TextIO , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) if show_diff : input_stream = StringIO ( input_stream . read ()) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) printer = create_terminal_printer ( color = config . color_output ) if not changed : if config . verbose and not config . only_modified : printer . success ( f \"{file_path or ''} Everything Looks Good!\" ) return True printer . error ( f \"{file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return False def check_file ( filename : Union [ str , Path ], show_diff : Union [ bool , TextIO ] = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , extension : Optional [ str ] = None , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = extension , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) def sort_file ( filename : Union [ str , Path ], extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : Union [ bool , TextIO ] = False , write_to_stdout : bool = False , output : Optional [ TextIO ] = None , ** config_kwargs , ) -> bool : \"\"\"Sorts and formats any groups of imports imports within the provided file or Path. Returns `True` if the file has been changed, otherwise `False`. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - **output**: If a TextIO is provided, results will be written there rather than replacing the original file content. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : actual_file_path = file_path or source_file . path config = _config ( path = actual_file_path , config = config , ** config_kwargs ) changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) else : if output is None : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) with tmp_file . open ( encoding = source_file . encoding , newline = \"\" ) as tmp_out : show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_out . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) if show_diff or ( ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ) ): return False source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass # pragma: no cover else : changed = sort_stream ( input_stream = source_file . stream , output_stream = output , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff : source_file . stream . seek ( 0 ) output . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = output . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) source_file . stream . close () except ExistingSyntaxErrors : warn ( f \"{actual_file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( f \"{actual_file_path} unable to sort as isort introduces new syntax errors\" ) return changed def find_imports_in_code ( code : str , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code string. - **code**: The string of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" yield from find_imports_in_stream ( input_stream = StringIO ( code ), config = config , file_path = file_path , unique = unique , top_only = top_only , ** config_kwargs , ) def find_imports_in_stream ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , _seen : Optional [ Set [ str ]] = None , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code stream. - **input_stream**: The stream of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - **_seen**: An optional set of imports already seen. Generally meant only for internal use. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) identified_imports = identify . imports ( input_stream , config = config , file_path = file_path , top_only = top_only ) if not unique : yield from identified_imports seen : Set [ str ] = set () if _seen is None else _seen for identified_import in identified_imports : if unique in ( True , ImportKey . ALIAS ): key = identified_import . statement () elif unique == ImportKey . ATTRIBUTE : key = f \"{identified_import.module}.{identified_import.attribute}\" elif unique == ImportKey . MODULE : key = identified_import . module elif unique == ImportKey . PACKAGE : key = identified_import . module . split ( \".\" )[ 0 ] if key and key not in seen : seen . add ( key ) yield identified_import def find_imports_in_file ( filename : Union [ str , Path ], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source file. - **filename**: The name or Path of the file to look for imports in. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : yield from find_imports_in_stream ( input_stream = source_file . stream , config = config , file_path = file_path or source_file . path , unique = unique , top_only = top_only , ** config_kwargs , ) def find_imports_in_paths ( paths : Iterator [ Union [ str , Path ]], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source paths. - **paths**: A collection of paths to recursively look for imports within. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) seen : Optional [ Set [ str ]] = set () if unique else None yield from chain ( * ( find_imports_in_file ( file_name , unique = unique , config = config , top_only = top_only , _seen = seen ) for file_name in files . find ( map ( str , paths ), config , [], []) ) ) def _config ( path : Optional [ Path ] = None , config : Config = DEFAULT_CONFIG , ** config_kwargs ) -> Config : if path : if ( config is DEFAULT_CONFIG and \"settings_path\" not in config_kwargs and \"settings_file\" not in config_kwargs ): config_kwargs [ \"settings_path\" ] = path if config_kwargs : if config is not DEFAULT_CONFIG : raise ValueError ( \"You can either specify custom configuration options using kwargs or \" \"passing in a Config object. Not Both!\" ) config = Config ( ** config_kwargs ) return config Functions check_code_string def check_code_string ( code : str , show_diff : Union [ bool , TextIO ] = False , extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks the order, format, and categorization of imports within the provided code string. Returns True if everything is correct, otherwise False . code : The string of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_code_string ( code : str , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \" \"\" Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\" \" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) check_file def check_file ( filename : Union [ str , pathlib . Path ], show_diff : Union [ bool , TextIO ] = False , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , extension : Union [ str , NoneType ] = None , ** config_kwargs ) -> bool Checks any imports within the provided file, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. filename : The name or Path of the file to check. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. extension : The file extension that contains imports. Defaults to filename extension or py. **config_kwargs : Any config modifications. View Source def check_file ( filename : Union [ str , Path ] , show_diff : Union [ bool , TextIO ] = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , extension : Optional [ str ] = None , ** config_kwargs , ) -> bool : \" \"\" Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - ****config_kwargs**: Any config modifications. \"\" \" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = extension , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) check_stream def check_stream ( input_stream : < class ' TextIO '>, show_diff : Union [ bool , TextIO ] = False , extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks any imports within the provided code stream, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. input_stream : The stream of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_stream ( input_stream : TextIO , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \" \"\" Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\" \" config = _config ( path = file_path , config = config , ** config_kwargs ) if show_diff : input_stream = StringIO ( input_stream . read ()) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) printer = create_terminal_printer ( color = config . color_output ) if not changed : if config . verbose and not config . only_modified : printer . success ( f \"{file_path or ''} Everything Looks Good!\" ) return True printer . error ( f \"{file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return False find_imports_in_code def find_imports_in_code ( code : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided code string. code : The string of code with imports that need to be sorted. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. **config_kwargs : Any config modifications. View Source def find_imports_in_code ( code : str , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code string. - **code**: The string of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" yield from find_imports_in_stream ( input_stream = StringIO ( code ), config = config , file_path = file_path , unique = unique , top_only = top_only , ** config_kwargs , ) find_imports_in_file def find_imports_in_file ( filename : Union [ str , pathlib . Path ], config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided source file. filename : The name or Path of the file to look for imports in. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. **config_kwargs : Any config modifications. View Source def find_imports_in_file ( filename : Union [ str , Path ], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source file. - **filename**: The name or Path of the file to look for imports in. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : yield from find_imports_in_stream ( input_stream = source_file . stream , config = config , file_path = file_path or source_file . path , unique = unique , top_only = top_only , ** config_kwargs , ) find_imports_in_paths def find_imports_in_paths ( paths : Iterator [ Union [ str , pathlib . Path ]], config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided source paths. paths : A collection of paths to recursively look for imports within. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. **config_kwargs : Any config modifications. View Source def find_imports_in_paths ( paths : Iterator [ Union [ str , Path ]], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source paths. - **paths**: A collection of paths to recursively look for imports within. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) seen : Optional [ Set [ str ]] = set () if unique else None yield from chain ( * ( find_imports_in_file ( file_name , unique = unique , config = config , top_only = top_only , _seen = seen ) for file_name in files . find ( map ( str , paths ), config , [], []) ) ) find_imports_in_stream def find_imports_in_stream ( input_stream : < class ' TextIO '>, config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , _seen : Union [ Set [ str ], NoneType ] = None , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided code stream. input_stream : The stream of code with imports that need to be sorted. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. _seen : An optional set of imports already seen. Generally meant only for internal use. **config_kwargs : Any config modifications. View Source def find_imports_in_stream ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , _seen : Optional [ Set [ str ]] = None , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code stream. - **input_stream**: The stream of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - **_seen**: An optional set of imports already seen. Generally meant only for internal use. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) identified_imports = identify . imports ( input_stream , config = config , file_path = file_path , top_only = top_only ) if not unique : yield from identified_imports seen : Set [ str ] = set () if _seen is None else _seen for identified_import in identified_imports : if unique in ( True , ImportKey . ALIAS ): key = identified_import . statement () elif unique == ImportKey . ATTRIBUTE : key = f \"{identified_import.module}.{identified_import.attribute}\" elif unique == ImportKey . MODULE : key = identified_import . module elif unique == ImportKey . PACKAGE : key = identified_import . module . split ( \".\" )[ 0 ] if key and key not in seen : seen . add ( key ) yield identified_import sort_code_string def sort_code_string ( code : str , extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs ) Sorts any imports within the provided code string, returning a new string with them sorted. code : The string of code with imports that need to be sorted. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. **config_kwargs : Any config modifications. View Source def sort_code_string ( code : str , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ) : \" \"\" Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\" \" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , show_diff = show_diff , ) output_stream . seek ( 0 ) return output_stream . read () sort_file def sort_file ( filename : Union [ str , pathlib . Path ], extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : Union [ bool , TextIO ] = False , write_to_stdout : bool = False , output : Union [ TextIO , NoneType ] = None , ** config_kwargs ) -> bool Sorts and formats any groups of imports imports within the provided file or Path. Returns True if the file has been changed, otherwise False . filename : The name or Path of the file to format. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. ask_to_apply : If True , prompt before applying any changes. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. write_to_stdout : If True , write to stdout instead of the input file. output : If a TextIO is provided, results will be written there rather than replacing the original file content. **config_kwargs : Any config modifications. View Source def sort_file ( filename : Union [ str , Path ] , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : Union [ bool , TextIO ] = False , write_to_stdout : bool = False , output : Optional [ TextIO ] = None , ** config_kwargs , ) -> bool : \" \"\" Sorts and formats any groups of imports imports within the provided file or Path. Returns `True` if the file has been changed, otherwise `False`. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - **output**: If a TextIO is provided, results will be written there rather than replacing the original file content. - ****config_kwargs**: Any config modifications. \"\" \" with io . File . read ( filename ) as source_file : actual_file_path = file_path or source_file . path config = _config ( path = actual_file_path , config = config , ** config_kwargs ) changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) else : if output is None : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) with tmp_file . open ( encoding = source_file . encoding , newline = \"\" ) as tmp_out : show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_out . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) if show_diff or ( ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ) ) : return False source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass # pragma: no cover else : changed = sort_stream ( input_stream = source_file . stream , output_stream = output , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff : source_file . stream . seek ( 0 ) output . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = output . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) source_file . stream . close () except ExistingSyntaxErrors : warn ( f \"{actual_file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( f \"{actual_file_path} unable to sort as isort introduces new syntax errors\" ) return changed sort_stream def sort_stream ( input_stream : < class ' TextIO '>, output_stream : < class ' TextIO '>, extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs ) -> bool Sorts any imports within the provided code stream, outputs to the provided output stream. Returns True if anything is modified from the original input stream, otherwise False . input_stream : The stream of code with imports that need to be sorted. output_stream : The stream where sorted imports should be written to. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. **config_kwargs : Any config modifications. View Source def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ) -> bool : \" \"\" Sorts any imports within the provided code stream, outputs to the provided output stream. Returns `True` if anything is modified from the original input stream, otherwise `False`. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\" \" if show_diff : _output_stream = StringIO () _input_stream = StringIO ( input_stream . read ()) changed = sort_stream ( input_stream = _input_stream , output_stream = _output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ** config_kwargs , ) _output_stream . seek ( 0 ) _input_stream . seek ( 0 ) show_unified_diff ( file_input = _input_stream . read (), file_output = _output_stream . read (), file_path = file_path , output = output_stream if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return changed config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ) : raise FileSkipSetting ( content_source ) _internal_output = output_stream if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) if not output_stream . readable () : _internal_output = StringIO () try : changed = core . process ( input_stream , _internal_output , extension = extension or ( file_path and file_path . suffix . lstrip ( \".\" )) or \"py\" , config = config , ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : _internal_output . seek ( 0 ) try : compile ( _internal_output . read (), content_source , \"exec\" , 0 , 1 ) _internal_output . seek ( 0 ) if _internal_output != output_stream : output_stream . write ( _internal_output . read ()) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed Classes ImportKey class ImportKey ( / , * args , ** kwargs ) Defines how to key an individual import, generally for deduping. Import keys are defined from less to more specific: from x.y import z as a _ _| | | | | | | | PACKAGE | | | _ _| | | | | | MODULE | | _ _ | | | | ATTRIBUTE | _ _ _ | | ALIAS View Source class ImportKey ( Enum ): \"\"\"Defines how to key an individual import, generally for deduping. Import keys are defined from less to more specific: from x.y import z as a ______| | | | | | | | PACKAGE | | | ________| | | | | | MODULE | | _________________| | | | ATTRIBUTE | ______________________| | ALIAS \"\"\" PACKAGE = 1 MODULE = 2 ATTRIBUTE = 3 ALIAS = 4 Ancestors (in MRO) enum.Enum Class variables ALIAS ATTRIBUTE MODULE PACKAGE name value","title":"API"},{"location":"reference/isort/api/#module-isortapi","text":"View Source import shutil import sys from enum import Enum from io import StringIO from itertools import chain from pathlib import Path from typing import Iterator , Optional , Set , TextIO , Union , cast from warnings import warn from isort import core from . import files , identify , io from .exceptions import ( ExistingSyntaxErrors , FileSkipComment , FileSkipSetting , IntroducedSyntaxErrors , ) from .format import ask_whether_to_apply_changes_to_file , create_terminal_printer , show_unified_diff from .io import Empty from .place import module as place_module # noqa: F401 from .place import module_with_reason as place_module_with_reason # noqa: F401 from .settings import DEFAULT_CONFIG , Config class ImportKey ( Enum ): \"\"\"Defines how to key an individual import, generally for deduping. Import keys are defined from less to more specific: from x.y import z as a ______| | | | | | | | PACKAGE | | | ________| | | | | | MODULE | | _________________| | | | ATTRIBUTE | ______________________| | ALIAS \"\"\" PACKAGE = 1 MODULE = 2 ATTRIBUTE = 3 ALIAS = 4 def sort_code_string ( code : str , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ): \"\"\"Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\"\" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , show_diff = show_diff , ) output_stream . seek ( 0 ) return output_stream . read () def check_code_string ( code : str , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ) -> bool : \"\"\"Sorts any imports within the provided code stream, outputs to the provided output stream. Returns `True` if anything is modified from the original input stream, otherwise `False`. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\"\" if show_diff : _output_stream = StringIO () _input_stream = StringIO ( input_stream . read ()) changed = sort_stream ( input_stream = _input_stream , output_stream = _output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ** config_kwargs , ) _output_stream . seek ( 0 ) _input_stream . seek ( 0 ) show_unified_diff ( file_input = _input_stream . read (), file_output = _output_stream . read (), file_path = file_path , output = output_stream if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return changed config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ): raise FileSkipSetting ( content_source ) _internal_output = output_stream if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) if not output_stream . readable (): _internal_output = StringIO () try : changed = core . process ( input_stream , _internal_output , extension = extension or ( file_path and file_path . suffix . lstrip ( \".\" )) or \"py\" , config = config , ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : _internal_output . seek ( 0 ) try : compile ( _internal_output . read (), content_source , \"exec\" , 0 , 1 ) _internal_output . seek ( 0 ) if _internal_output != output_stream : output_stream . write ( _internal_output . read ()) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed def check_stream ( input_stream : TextIO , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( path = file_path , config = config , ** config_kwargs ) if show_diff : input_stream = StringIO ( input_stream . read ()) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) printer = create_terminal_printer ( color = config . color_output ) if not changed : if config . verbose and not config . only_modified : printer . success ( f \"{file_path or ''} Everything Looks Good!\" ) return True printer . error ( f \"{file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return False def check_file ( filename : Union [ str , Path ], show_diff : Union [ bool , TextIO ] = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , extension : Optional [ str ] = None , ** config_kwargs , ) -> bool : \"\"\"Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = extension , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , ) def sort_file ( filename : Union [ str , Path ], extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : Union [ bool , TextIO ] = False , write_to_stdout : bool = False , output : Optional [ TextIO ] = None , ** config_kwargs , ) -> bool : \"\"\"Sorts and formats any groups of imports imports within the provided file or Path. Returns `True` if the file has been changed, otherwise `False`. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - **output**: If a TextIO is provided, results will be written there rather than replacing the original file content. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : actual_file_path = file_path or source_file . path config = _config ( path = actual_file_path , config = config , ** config_kwargs ) changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) else : if output is None : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) with tmp_file . open ( encoding = source_file . encoding , newline = \"\" ) as tmp_out : show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_out . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) if show_diff or ( ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ) ): return False source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass # pragma: no cover else : changed = sort_stream ( input_stream = source_file . stream , output_stream = output , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff : source_file . stream . seek ( 0 ) output . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = output . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) source_file . stream . close () except ExistingSyntaxErrors : warn ( f \"{actual_file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( f \"{actual_file_path} unable to sort as isort introduces new syntax errors\" ) return changed def find_imports_in_code ( code : str , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code string. - **code**: The string of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" yield from find_imports_in_stream ( input_stream = StringIO ( code ), config = config , file_path = file_path , unique = unique , top_only = top_only , ** config_kwargs , ) def find_imports_in_stream ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , _seen : Optional [ Set [ str ]] = None , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code stream. - **input_stream**: The stream of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - **_seen**: An optional set of imports already seen. Generally meant only for internal use. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) identified_imports = identify . imports ( input_stream , config = config , file_path = file_path , top_only = top_only ) if not unique : yield from identified_imports seen : Set [ str ] = set () if _seen is None else _seen for identified_import in identified_imports : if unique in ( True , ImportKey . ALIAS ): key = identified_import . statement () elif unique == ImportKey . ATTRIBUTE : key = f \"{identified_import.module}.{identified_import.attribute}\" elif unique == ImportKey . MODULE : key = identified_import . module elif unique == ImportKey . PACKAGE : key = identified_import . module . split ( \".\" )[ 0 ] if key and key not in seen : seen . add ( key ) yield identified_import def find_imports_in_file ( filename : Union [ str , Path ], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source file. - **filename**: The name or Path of the file to look for imports in. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : yield from find_imports_in_stream ( input_stream = source_file . stream , config = config , file_path = file_path or source_file . path , unique = unique , top_only = top_only , ** config_kwargs , ) def find_imports_in_paths ( paths : Iterator [ Union [ str , Path ]], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source paths. - **paths**: A collection of paths to recursively look for imports within. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) seen : Optional [ Set [ str ]] = set () if unique else None yield from chain ( * ( find_imports_in_file ( file_name , unique = unique , config = config , top_only = top_only , _seen = seen ) for file_name in files . find ( map ( str , paths ), config , [], []) ) ) def _config ( path : Optional [ Path ] = None , config : Config = DEFAULT_CONFIG , ** config_kwargs ) -> Config : if path : if ( config is DEFAULT_CONFIG and \"settings_path\" not in config_kwargs and \"settings_file\" not in config_kwargs ): config_kwargs [ \"settings_path\" ] = path if config_kwargs : if config is not DEFAULT_CONFIG : raise ValueError ( \"You can either specify custom configuration options using kwargs or \" \"passing in a Config object. Not Both!\" ) config = Config ( ** config_kwargs ) return config","title":"Module isort.api"},{"location":"reference/isort/api/#functions","text":"","title":"Functions"},{"location":"reference/isort/api/#check_code_string","text":"def check_code_string ( code : str , show_diff : Union [ bool , TextIO ] = False , extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks the order, format, and categorization of imports within the provided code string. Returns True if everything is correct, otherwise False . code : The string of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_code_string ( code : str , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \" \"\" Checks the order, format, and categorization of imports within the provided code string. Returns `True` if everything is correct, otherwise `False`. - **code**: The string of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\" \" config = _config ( path = file_path , config = config , ** config_kwargs ) return check_stream ( StringIO ( code ), show_diff = show_diff , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , )","title":"check_code_string"},{"location":"reference/isort/api/#check_file","text":"def check_file ( filename : Union [ str , pathlib . Path ], show_diff : Union [ bool , TextIO ] = False , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , extension : Union [ str , NoneType ] = None , ** config_kwargs ) -> bool Checks any imports within the provided file, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. filename : The name or Path of the file to check. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. extension : The file extension that contains imports. Defaults to filename extension or py. **config_kwargs : Any config modifications. View Source def check_file ( filename : Union [ str , Path ] , show_diff : Union [ bool , TextIO ] = False , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , extension : Optional [ str ] = None , ** config_kwargs , ) -> bool : \" \"\" Checks any imports within the provided file, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **filename**: The name or Path of the file to check. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - ****config_kwargs**: Any config modifications. \"\" \" with io . File . read ( filename ) as source_file : return check_stream ( source_file . stream , show_diff = show_diff , extension = extension , config = config , file_path = file_path or source_file . path , disregard_skip = disregard_skip , ** config_kwargs , )","title":"check_file"},{"location":"reference/isort/api/#check_stream","text":"def check_stream ( input_stream : < class ' TextIO '>, show_diff : Union [ bool , TextIO ] = False , extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , ** config_kwargs ) -> bool Checks any imports within the provided code stream, returning False if any unsorted or incorrectly imports are found or True if no problems are identified. input_stream : The stream of code with imports that need to be sorted. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. **config_kwargs : Any config modifications. View Source def check_stream ( input_stream : TextIO , show_diff : Union [ bool , TextIO ] = False , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , ** config_kwargs , ) -> bool : \" \"\" Checks any imports within the provided code stream, returning `False` if any unsorted or incorrectly imports are found or `True` if no problems are identified. - **input_stream**: The stream of code with imports that need to be sorted. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - ****config_kwargs**: Any config modifications. \"\" \" config = _config ( path = file_path , config = config , ** config_kwargs ) if show_diff : input_stream = StringIO ( input_stream . read ()) changed : bool = sort_stream ( input_stream = input_stream , output_stream = Empty , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) printer = create_terminal_printer ( color = config . color_output ) if not changed : if config . verbose and not config . only_modified : printer . success ( f \"{file_path or ''} Everything Looks Good!\" ) return True printer . error ( f \"{file_path or ''} Imports are incorrectly sorted and/or formatted.\" ) if show_diff : output_stream = StringIO () input_stream . seek ( 0 ) file_contents = input_stream . read () sort_stream ( input_stream = StringIO ( file_contents ), output_stream = output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ) output_stream . seek ( 0 ) show_unified_diff ( file_input = file_contents , file_output = output_stream . read (), file_path = file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return False","title":"check_stream"},{"location":"reference/isort/api/#find_imports_in_code","text":"def find_imports_in_code ( code : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided code string. code : The string of code with imports that need to be sorted. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. **config_kwargs : Any config modifications. View Source def find_imports_in_code ( code : str , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code string. - **code**: The string of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" yield from find_imports_in_stream ( input_stream = StringIO ( code ), config = config , file_path = file_path , unique = unique , top_only = top_only , ** config_kwargs , )","title":"find_imports_in_code"},{"location":"reference/isort/api/#find_imports_in_file","text":"def find_imports_in_file ( filename : Union [ str , pathlib . Path ], config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided source file. filename : The name or Path of the file to look for imports in. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. **config_kwargs : Any config modifications. View Source def find_imports_in_file ( filename : Union [ str , Path ], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source file. - **filename**: The name or Path of the file to look for imports in. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" with io . File . read ( filename ) as source_file : yield from find_imports_in_stream ( input_stream = source_file . stream , config = config , file_path = file_path or source_file . path , unique = unique , top_only = top_only , ** config_kwargs , )","title":"find_imports_in_file"},{"location":"reference/isort/api/#find_imports_in_paths","text":"def find_imports_in_paths ( paths : Iterator [ Union [ str , pathlib . Path ]], config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided source paths. paths : A collection of paths to recursively look for imports within. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. **config_kwargs : Any config modifications. View Source def find_imports_in_paths ( paths : Iterator [ Union [ str , Path ]], config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided source paths. - **paths**: A collection of paths to recursively look for imports within. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) seen : Optional [ Set [ str ]] = set () if unique else None yield from chain ( * ( find_imports_in_file ( file_name , unique = unique , config = config , top_only = top_only , _seen = seen ) for file_name in files . find ( map ( str , paths ), config , [], []) ) )","title":"find_imports_in_paths"},{"location":"reference/isort/api/#find_imports_in_stream","text":"def find_imports_in_stream ( input_stream : < class ' TextIO '>, config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , unique : Union [ bool , isort . api . ImportKey ] = False , top_only : bool = False , _seen : Union [ Set [ str ], NoneType ] = None , ** config_kwargs ) -> Iterator [ isort . identify . Import ] Finds and returns all imports within the provided code stream. input_stream : The stream of code with imports that need to be sorted. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. unique : If True, only the first instance of an import is returned. top_only : If True, only return imports that occur before the first function or class. _seen : An optional set of imports already seen. Generally meant only for internal use. **config_kwargs : Any config modifications. View Source def find_imports_in_stream ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , unique : Union [ bool , ImportKey ] = False , top_only : bool = False , _seen : Optional [ Set [ str ]] = None , ** config_kwargs , ) -> Iterator [ identify . Import ]: \"\"\"Finds and returns all imports within the provided code stream. - **input_stream**: The stream of code with imports that need to be sorted. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **unique**: If True, only the first instance of an import is returned. - **top_only**: If True, only return imports that occur before the first function or class. - **_seen**: An optional set of imports already seen. Generally meant only for internal use. - ****config_kwargs**: Any config modifications. \"\"\" config = _config ( config = config , ** config_kwargs ) identified_imports = identify . imports ( input_stream , config = config , file_path = file_path , top_only = top_only ) if not unique : yield from identified_imports seen : Set [ str ] = set () if _seen is None else _seen for identified_import in identified_imports : if unique in ( True , ImportKey . ALIAS ): key = identified_import . statement () elif unique == ImportKey . ATTRIBUTE : key = f \"{identified_import.module}.{identified_import.attribute}\" elif unique == ImportKey . MODULE : key = identified_import . module elif unique == ImportKey . PACKAGE : key = identified_import . module . split ( \".\" )[ 0 ] if key and key not in seen : seen . add ( key ) yield identified_import","title":"find_imports_in_stream"},{"location":"reference/isort/api/#sort_code_string","text":"def sort_code_string ( code : str , extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs ) Sorts any imports within the provided code string, returning a new string with them sorted. code : The string of code with imports that need to be sorted. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. **config_kwargs : Any config modifications. View Source def sort_code_string ( code : str , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ) : \" \"\" Sorts any imports within the provided code string, returning a new string with them sorted. - **code**: The string of code with imports that need to be sorted. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\" \" input_stream = StringIO ( code ) output_stream = StringIO () config = _config ( path = file_path , config = config , ** config_kwargs ) sort_stream ( input_stream , output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , show_diff = show_diff , ) output_stream . seek ( 0 ) return output_stream . read ()","title":"sort_code_string"},{"location":"reference/isort/api/#sort_file","text":"def sort_file ( filename : Union [ str , pathlib . Path ], extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : Union [ bool , TextIO ] = False , write_to_stdout : bool = False , output : Union [ TextIO , NoneType ] = None , ** config_kwargs ) -> bool Sorts and formats any groups of imports imports within the provided file or Path. Returns True if the file has been changed, otherwise False . filename : The name or Path of the file to format. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. ask_to_apply : If True , prompt before applying any changes. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. write_to_stdout : If True , write to stdout instead of the input file. output : If a TextIO is provided, results will be written there rather than replacing the original file content. **config_kwargs : Any config modifications. View Source def sort_file ( filename : Union [ str , Path ] , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = True , ask_to_apply : bool = False , show_diff : Union [ bool , TextIO ] = False , write_to_stdout : bool = False , output : Optional [ TextIO ] = None , ** config_kwargs , ) -> bool : \" \"\" Sorts and formats any groups of imports imports within the provided file or Path. Returns `True` if the file has been changed, otherwise `False`. - **filename**: The name or Path of the file to format. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **ask_to_apply**: If `True`, prompt before applying any changes. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - **write_to_stdout**: If `True`, write to stdout instead of the input file. - **output**: If a TextIO is provided, results will be written there rather than replacing the original file content. - ****config_kwargs**: Any config modifications. \"\" \" with io . File . read ( filename ) as source_file : actual_file_path = file_path or source_file . path config = _config ( path = actual_file_path , config = config , ** config_kwargs ) changed : bool = False try : if write_to_stdout : changed = sort_stream ( input_stream = source_file . stream , output_stream = sys . stdout , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) else : if output is None : tmp_file = source_file . path . with_suffix ( source_file . path . suffix + \".isorted\" ) try : with tmp_file . open ( \"w\" , encoding = source_file . encoding , newline = \"\" ) as output_stream : shutil . copymode ( filename , tmp_file ) changed = sort_stream ( input_stream = source_file . stream , output_stream = output_stream , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff or ask_to_apply : source_file . stream . seek ( 0 ) with tmp_file . open ( encoding = source_file . encoding , newline = \"\" ) as tmp_out : show_unified_diff ( file_input = source_file . stream . read (), file_output = tmp_out . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) if show_diff or ( ask_to_apply and not ask_whether_to_apply_changes_to_file ( str ( source_file . path ) ) ) : return False source_file . stream . close () tmp_file . replace ( source_file . path ) if not config . quiet : print ( f \"Fixing {source_file.path}\" ) finally : try : # Python 3.8+: use `missing_ok=True` instead of try except. tmp_file . unlink () except FileNotFoundError : pass # pragma: no cover else : changed = sort_stream ( input_stream = source_file . stream , output_stream = output , config = config , file_path = actual_file_path , disregard_skip = disregard_skip , extension = extension , ) if changed : if show_diff : source_file . stream . seek ( 0 ) output . seek ( 0 ) show_unified_diff ( file_input = source_file . stream . read (), file_output = output . read (), file_path = actual_file_path , output = None if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) source_file . stream . close () except ExistingSyntaxErrors : warn ( f \"{actual_file_path} unable to sort due to existing syntax errors\" ) except IntroducedSyntaxErrors : # pragma: no cover warn ( f \"{actual_file_path} unable to sort as isort introduces new syntax errors\" ) return changed","title":"sort_file"},{"location":"reference/isort/api/#sort_stream","text":"def sort_stream ( input_stream : < class ' TextIO '>, output_stream : < class ' TextIO '>, extension : Union [ str , NoneType ] = None , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs ) -> bool Sorts any imports within the provided code stream, outputs to the provided output stream. Returns True if anything is modified from the original input stream, otherwise False . input_stream : The stream of code with imports that need to be sorted. output_stream : The stream where sorted imports should be written to. extension : The file extension that contains imports. Defaults to filename extension or py. config : The config object to use when sorting imports. file_path : The disk location where the code string was pulled from. disregard_skip : set to True if you want to ignore a skip set in config for this file. show_diff : If True the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. **config_kwargs : Any config modifications. View Source def sort_stream ( input_stream : TextIO , output_stream : TextIO , extension : Optional [ str ] = None , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , disregard_skip : bool = False , show_diff : Union [ bool , TextIO ] = False , ** config_kwargs , ) -> bool : \" \"\" Sorts any imports within the provided code stream, outputs to the provided output stream. Returns `True` if anything is modified from the original input stream, otherwise `False`. - **input_stream**: The stream of code with imports that need to be sorted. - **output_stream**: The stream where sorted imports should be written to. - **extension**: The file extension that contains imports. Defaults to filename extension or py. - **config**: The config object to use when sorting imports. - **file_path**: The disk location where the code string was pulled from. - **disregard_skip**: set to `True` if you want to ignore a skip set in config for this file. - **show_diff**: If `True` the changes that need to be done will be printed to stdout, if a TextIO stream is provided results will be written to it, otherwise no diff will be computed. - ****config_kwargs**: Any config modifications. \"\" \" if show_diff : _output_stream = StringIO () _input_stream = StringIO ( input_stream . read ()) changed = sort_stream ( input_stream = _input_stream , output_stream = _output_stream , extension = extension , config = config , file_path = file_path , disregard_skip = disregard_skip , ** config_kwargs , ) _output_stream . seek ( 0 ) _input_stream . seek ( 0 ) show_unified_diff ( file_input = _input_stream . read (), file_output = _output_stream . read (), file_path = file_path , output = output_stream if show_diff is True else cast ( TextIO , show_diff ), color_output = config . color_output , ) return changed config = _config ( path = file_path , config = config , ** config_kwargs ) content_source = str ( file_path or \"Passed in content\" ) if not disregard_skip : if file_path and config . is_skipped ( file_path ) : raise FileSkipSetting ( content_source ) _internal_output = output_stream if config . atomic : try : file_content = input_stream . read () compile ( file_content , content_source , \"exec\" , 0 , 1 ) input_stream = StringIO ( file_content ) except SyntaxError : raise ExistingSyntaxErrors ( content_source ) if not output_stream . readable () : _internal_output = StringIO () try : changed = core . process ( input_stream , _internal_output , extension = extension or ( file_path and file_path . suffix . lstrip ( \".\" )) or \"py\" , config = config , ) except FileSkipComment : raise FileSkipComment ( content_source ) if config . atomic : _internal_output . seek ( 0 ) try : compile ( _internal_output . read (), content_source , \"exec\" , 0 , 1 ) _internal_output . seek ( 0 ) if _internal_output != output_stream : output_stream . write ( _internal_output . read ()) except SyntaxError : # pragma: no cover raise IntroducedSyntaxErrors ( content_source ) return changed","title":"sort_stream"},{"location":"reference/isort/api/#classes","text":"","title":"Classes"},{"location":"reference/isort/api/#importkey","text":"class ImportKey ( / , * args , ** kwargs ) Defines how to key an individual import, generally for deduping. Import keys are defined from less to more specific: from x.y import z as a _ _| | | | | | | | PACKAGE | | | _ _| | | | | | MODULE | | _ _ | | | | ATTRIBUTE | _ _ _ | | ALIAS View Source class ImportKey ( Enum ): \"\"\"Defines how to key an individual import, generally for deduping. Import keys are defined from less to more specific: from x.y import z as a ______| | | | | | | | PACKAGE | | | ________| | | | | | MODULE | | _________________| | | | ATTRIBUTE | ______________________| | ALIAS \"\"\" PACKAGE = 1 MODULE = 2 ATTRIBUTE = 3 ALIAS = 4","title":"ImportKey"},{"location":"reference/isort/api/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/isort/api/#class-variables","text":"ALIAS ATTRIBUTE MODULE PACKAGE name value","title":"Class variables"},{"location":"reference/isort/comments/","text":"Module isort.comments View Source from typing import List , Optional , Tuple def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" ) def add_to_line ( comments : Optional [ List [ str ]], original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string )[ 0 ] if not comments : return original_string unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\" Functions add_to_line def add_to_line ( comments : Union [ List [ str ], NoneType ], original_string : str = '' , removed : bool = False , comment_prefix : str = '' ) -> str Returns a string with comments added if removed is not set. View Source def add_to_line ( comments : Optional [ List[str ] ] , original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string ) [ 0 ] if not comments : return original_string unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\" parse def parse ( line : str ) -> Tuple [ str , str ] Parses import lines for comments and returns back the import statement and the associated comment. View Source def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" )","title":"Comments"},{"location":"reference/isort/comments/#module-isortcomments","text":"View Source from typing import List , Optional , Tuple def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" ) def add_to_line ( comments : Optional [ List [ str ]], original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string )[ 0 ] if not comments : return original_string unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\"","title":"Module isort.comments"},{"location":"reference/isort/comments/#functions","text":"","title":"Functions"},{"location":"reference/isort/comments/#add_to_line","text":"def add_to_line ( comments : Union [ List [ str ], NoneType ], original_string : str = '' , removed : bool = False , comment_prefix : str = '' ) -> str Returns a string with comments added if removed is not set. View Source def add_to_line ( comments : Optional [ List[str ] ] , original_string : str = \"\" , removed : bool = False , comment_prefix : str = \"\" , ) -> str : \"\"\"Returns a string with comments added if removed is not set.\"\"\" if removed : return parse ( original_string ) [ 0 ] if not comments : return original_string unique_comments : List [ str ] = [] for comment in comments : if comment not in unique_comments : unique_comments . append ( comment ) return f \"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}\"","title":"add_to_line"},{"location":"reference/isort/comments/#parse","text":"def parse ( line : str ) -> Tuple [ str , str ] Parses import lines for comments and returns back the import statement and the associated comment. View Source def parse ( line : str ) -> Tuple [ str , str ]: \"\"\"Parses import lines for comments and returns back the import statement and the associated comment. \"\"\" comment_start = line . find ( \"#\" ) if comment_start != - 1 : return ( line [: comment_start ], line [ comment_start + 1 :] . strip ()) return ( line , \"\" )","title":"parse"},{"location":"reference/isort/core/","text":"Module isort.core View Source import textwrap from io import StringIO from itertools import chain from typing import List , TextIO , Union import isort . literal from isort . settings import DEFAULT_CONFIG , Config from . import output , parse from . exceptions import FileSkipComment from . format import format_natural , remove_whitespace from . settings import FILE_SKIP_COMMENTS CIMPORT_IDENTIFIERS = ( \"cimport \" , \"cimport*\" , \"from.cimport\" ) IMPORT_START_IDENTIFIERS = ( \"from \" , \"from.import\" , \"import \" , \"import*\" ) + CIMPORT_IDENTIFIERS COMMENT_INDICATORS = ( '\"\"\"' , \"'''\" , \"'\" , '\"' , \"#\" ) CODE_SORT_COMMENTS = ( \"# isort: list\" , \"# isort: dict\" , \"# isort: set\" , \"# isort: unique-list\" , \"# isort: tuple\" , \"# isort: unique-tuple\" , \"# isort: assignments\" , ) def process ( input_stream: TextIO , output_stream: TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , ) -> bool : \"\"\"Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided `input_stream`, sorted and then outputted to the specified `output_stream`. - `input_stream`: Text stream with unsorted import sections. - `output_stream`: Text stream to output sorted inputs into. - `config`: Config settings to use when sorting imports. Defaults settings. - *Default*: `isort.settings.DEFAULT_CONFIG`. - `extension`: The file extension or file extension rules that should be used. - *Default*: `\" py \"`. - *Choices*: `[\" py \", \" pyi \", \" pyx \"]`. Returns `True` if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise `False`. \"\"\" line_separator: str = config . line_ending add_imports: List [ str ] = [ format_natural ( addition ) for addition in config . add_imports ] import_section: str = \"\" next_import_section: str = \"\" next_cimports: bool = False in_quote: str = \"\" first_comment_index_start: int = - 1 first_comment_index_end: int = - 1 contains_imports: bool = False in_top_comment: bool = False first_import_section: bool = True indent : str = \"\" isort_off: bool = False code_sorting: Union [ bool , str ] = False code_sorting_section: str = \"\" code_sorting_indent: str = \"\" cimports : bool = False made_changes: bool = False stripped_line: str = \"\" end_of_file: bool = False verbose_output: List [ str ] = [] if config . float_to_top: new_input = \"\" current = \"\" isort_off = False for line in chain ( input_stream , ( None ,)) : if isort_off and line is not None : if line == \"# isort: on\\n\" : isort_off = False new_input += line elif line in ( \"# isort: split\\n\" , \"# isort: off\\n\" , None ) or str ( line ). endswith ( \"# isort: split\\n\" ) : if line == \"# isort: off\\n\" : isort_off = True if current : if add_imports: add_line_separator = line_separator or \"\\n\" current += add_line_separator + add_line_separator . join ( add_imports ) add_imports = [] parsed = parse . file_contents ( current , config = config ) verbose_output += parsed . verbose_output extra_space = \"\" while current and current [ - 1 ] == \"\\n\" : extra_space += \"\\n\" current = current [:- 1 ] extra_space = extra_space . replace ( \"\\n\" , \"\" , 1 ) sorted_output = output . sorted_imports ( parsed , config , extension , import_type= \"import\" ) made_changes = made_changes or _ has_changed ( before = current , after = sorted_output , line_separator = parsed . line_separator , ignore_whitespace = config . ignore_whitespace , ) new_input += sorted_output new_input += extra_space current = \"\" new_input += line or \"\" else : current += line or \"\" input_stream = StringIO ( new_input ) for index , line in enumerate ( chain ( input_stream , ( None ,))) : if line is None : if index == 0 and not config . force_adds: return False not_imports = True end_of_file = True line = \"\" if not line_separator: line_separator = \"\\n\" if code_sorting and code_sorting_section: output_stream . write ( textwrap . indent ( isort . literal . assignment ( code_sorting_section , str ( code_sorting ), extension , config= _ indented_config ( config , indent ), ), code_sorting_indent , ) ) else : stripped_line = line . strip () if stripped_line and not line_separator: line_separator = line [ len ( line . rstrip ()) : ]. replace ( \" \" , \"\" ). replace ( \"\\t\" , \"\" ) for file_skip_comment in FILE_SKIP_COMMENTS : if file_skip_comment in line : raise FileSkipComment ( \"Passed in content\" ) if not in_quote and stripped_line == \"# isort: off\" : isort_off = True if ( ( index == 0 or ( index in ( 1 , 2 ) and not contains_imports )) and stripped_line . startswith ( \"#\" ) and stripped_line not in config . section_comments ) : in_top_comment = True elif in_top_comment: if not line . startswith ( \"#\" ) or stripped_line in config . section_comments: in_top_comment = False first_comment_index_end = index - 1 was_in_quote = bool ( in_quote ) if ( not stripped_line . startswith ( \"#\" ) or in_quote ) and '\"' in line or \"'\" in line : char_index = 0 if first_comment_index_start == - 1 and ( line . startswith ( '\"' ) or line . startswith ( \"'\" ) ) : first_comment_index_start = index while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \": char_index += 1 elif in_quote: if line[char_index : char_index + len(in_quote)] == in_quote: in_quote = \"\" if first_comment_index_end < first_comment_index_start: first_comment_index_end = index elif line[char_index] in (\" '\", ' \"'): long_quote = line[char_index : char_index + 3] if long_quote in ('\"\"\" ', \"''' \"): in_quote = long_quote char_index += 2 else: in_quote = line[char_index] elif line[char_index] == \" # \": break char_index += 1 not_imports = bool(in_quote) or was_in_quote or in_top_comment or isort_off if not (in_quote or was_in_quote or in_top_comment): if isort_off: if stripped_line == \" # isort : on \": isort_off = False elif stripped_line.endswith(\" # isort : split \"): not_imports = True elif stripped_line in CODE_SORT_COMMENTS: code_sorting = stripped_line.split(\" isort : \")[1].strip() code_sorting_indent = line[: -len(line.lstrip())] not_imports = True elif code_sorting: if not stripped_line: output_stream.write( textwrap.indent( isort.literal.assignment( code_sorting_section, str(code_sorting), extension, config=_indented_config(config, indent), ), code_sorting_indent, ) ) not_imports = True code_sorting = False code_sorting_section = \"\" code_sorting_indent = \"\" else: code_sorting_section += line line = \"\" elif stripped_line in config.section_comments: if import_section and not contains_imports: output_stream.write(import_section) import_section = line not_imports = False else: import_section += line indent = line[: -len(line.lstrip())] elif not (stripped_line or contains_imports): not_imports = True elif ( not stripped_line or stripped_line.startswith(\" # \") and (not indent or indent + line.lstrip() == line) and not config.treat_all_comments_as_code and stripped_line not in config.treat_comments_as_code ): import_section += line elif stripped_line.startswith(IMPORT_START_IDENTIFIERS): did_contain_imports = contains_imports contains_imports = True new_indent = line[: -len(line.lstrip())] import_statement = line stripped_line = line.strip().split(\" # \")[0] while stripped_line.endswith(\" \\\\ \") or ( \" ( \" in stripped_line and \" ) \" not in stripped_line ): if stripped_line.endswith(\" \\\\ \"): while stripped_line and stripped_line.endswith(\" \\\\ \"): line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line else: while \" ) \" not in stripped_line: line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line cimport_statement: bool = False if ( import_statement.lstrip().startswith(CIMPORT_IDENTIFIERS) or \" cimport \" in import_statement or \" cimport* \" in import_statement or \" cimport ( \" in import_statement or \" . cimport \" in import_statement ): cimport_statement = True if cimport_statement != cimports or ( new_indent != indent and import_section and (not did_contain_imports or len(new_indent) < len(indent)) ): indent = new_indent if import_section: next_cimports = cimport_statement next_import_section = import_statement import_statement = \"\" not_imports = True line = \"\" else: cimports = cimport_statement else: if new_indent != indent: if import_section and did_contain_imports: import_statement = indent + import_statement.lstrip() else: indent = new_indent import_section += import_statement else: not_imports = True if not_imports: raw_import_section: str = import_section if ( add_imports and (stripped_line or end_of_file) and not config.append_only and not in_top_comment and not in_quote and not import_section and not line.lstrip().startswith(COMMENT_INDICATORS) ): import_section = line_separator.join(add_imports) + line_separator if end_of_file and index != 0: output_stream.write(line_separator) contains_imports = True add_imports = [] if next_import_section and not import_section: # pragma: no cover raw_import_section = import_section = next_import_section next_import_section = \"\" if import_section: if add_imports and not indent: import_section = ( line_separator.join(add_imports) + line_separator + import_section ) contains_imports = True add_imports = [] if not indent: import_section += line raw_import_section += line if not contains_imports: output_stream.write(import_section) else: leading_whitespace = import_section[: -len(import_section.lstrip())] trailing_whitespace = import_section[len(import_section.rstrip()) :] if first_import_section and not import_section.lstrip( line_separator ).startswith(COMMENT_INDICATORS): import_section = import_section.lstrip(line_separator) raw_import_section = raw_import_section.lstrip(line_separator) first_import_section = False if indent: import_section = \"\".join( line[len(indent) :] for line in import_section.splitlines(keepends=True) ) parsed_content = parse.file_contents(import_section, config=config) verbose_output += parsed_content.verbose_output sorted_import_section = output.sorted_imports( parsed_content, _indented_config(config, indent), extension, import_type=\" cimport \" if cimports else \" import \", ) if not (import_section.strip() and not sorted_import_section): if indent: sorted_import_section = ( leading_whitespace + textwrap.indent(sorted_import_section, indent).strip() + trailing_whitespace ) made_changes = made_changes or _has_changed( before=raw_import_section, after=sorted_import_section, line_separator=line_separator, ignore_whitespace=config.ignore_whitespace, ) output_stream.write(sorted_import_section) if not line and not indent and next_import_section: output_stream.write(line_separator) if indent: output_stream.write(line) if not next_import_section: indent = \"\" if next_import_section: cimports = next_cimports contains_imports = True else: contains_imports = False import_section = next_import_section next_import_section = \"\" else: output_stream.write(line) not_imports = False if stripped_line and not in_quote and not import_section and not next_import_section: if stripped_line == \" yield \": while not stripped_line or stripped_line == \" yield \": new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \")[0] if stripped_line.startswith(\" raise \") or stripped_line.startswith(\" yield \"): while stripped_line.endswith(\" \\\\ \"): new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \" )[ 0 ] if made_changes and config . only_modified: for output_str in verbose_output: print ( output_str ) return made_changes def _ indented_config ( config : Config , indent : str ) : if not indent : return config return Config ( config = config , line_length = max ( config . line_length - len ( indent ), 0 ), wrap_length = max ( config . wrap_length - len ( indent ), 0 ), lines_after_imports = 1 , import_headings = config . import_headings if config . indented_import_headings else {}, ) def _ has_changed ( before : str , after : str , line_separator: str , ignore_whitespace: bool ) -> bool : if ignore_whitespace: return ( remove_whitespace ( before , line_separator = line_separator ). strip () ! = remove_whitespace ( after , line_separator = line_separator ). strip () ) return before . strip () ! = after . strip () Variables CIMPORT_IDENTIFIERS CODE_SORT_COMMENTS COMMENT_INDICATORS FILE_SKIP_COMMENTS IMPORT_START_IDENTIFIERS Functions process def process ( input_stream : < class ' TextIO '>, output_stream : < class ' TextIO '>, extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> bool Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided input_stream , sorted and then outputted to the specified output_stream . input_stream : Text stream with unsorted import sections. output_stream : Text stream to output sorted inputs into. config : Config settings to use when sorting imports. Defaults settings. Default : isort.settings.DEFAULT_CONFIG . extension : The file extension or file extension rules that should be used. Default : \"py\" . Choices : [\"py\", \"pyi\", \"pyx\"] . Returns True if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise False . View Source def process ( input_stream: TextIO , output_stream: TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , ) -> bool : \"\"\"Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided `input_stream`, sorted and then outputted to the specified `output_stream`. - `input_stream`: Text stream with unsorted import sections. - `output_stream`: Text stream to output sorted inputs into. - `config`: Config settings to use when sorting imports. Defaults settings. - *Default*: `isort.settings.DEFAULT_CONFIG`. - `extension`: The file extension or file extension rules that should be used. - *Default*: `\" py \"`. - *Choices*: `[\" py \", \" pyi \", \" pyx \"]`. Returns `True` if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise `False`. \"\"\" line_separator: str = config . line_ending add_imports: List [ str ] = [ format_natural ( addition ) for addition in config . add_imports ] import_section: str = \"\" next_import_section: str = \"\" next_cimports: bool = False in_quote: str = \"\" first_comment_index_start: int = - 1 first_comment_index_end: int = - 1 contains_imports: bool = False in_top_comment: bool = False first_import_section: bool = True indent : str = \"\" isort_off: bool = False code_sorting: Union [ bool , str ] = False code_sorting_section: str = \"\" code_sorting_indent: str = \"\" cimports : bool = False made_changes: bool = False stripped_line: str = \"\" end_of_file: bool = False verbose_output: List [ str ] = [] if config . float_to_top: new_input = \"\" current = \"\" isort_off = False for line in chain ( input_stream , ( None ,)) : if isort_off and line is not None : if line == \"# isort: on\\n\" : isort_off = False new_input += line elif line in ( \"# isort: split\\n\" , \"# isort: off\\n\" , None ) or str ( line ). endswith ( \"# isort: split\\n\" ) : if line == \"# isort: off\\n\" : isort_off = True if current : if add_imports: add_line_separator = line_separator or \"\\n\" current += add_line_separator + add_line_separator . join ( add_imports ) add_imports = [] parsed = parse . file_contents ( current , config = config ) verbose_output += parsed . verbose_output extra_space = \"\" while current and current [ - 1 ] == \"\\n\" : extra_space += \"\\n\" current = current [:- 1 ] extra_space = extra_space . replace ( \"\\n\" , \"\" , 1 ) sorted_output = output . sorted_imports ( parsed , config , extension , import_type= \"import\" ) made_changes = made_changes or _ has_changed ( before = current , after = sorted_output , line_separator = parsed . line_separator , ignore_whitespace = config . ignore_whitespace , ) new_input += sorted_output new_input += extra_space current = \"\" new_input += line or \"\" else : current += line or \"\" input_stream = StringIO ( new_input ) for index , line in enumerate ( chain ( input_stream , ( None ,))) : if line is None : if index == 0 and not config . force_adds: return False not_imports = True end_of_file = True line = \"\" if not line_separator: line_separator = \"\\n\" if code_sorting and code_sorting_section: output_stream . write ( textwrap . indent ( isort . literal . assignment ( code_sorting_section , str ( code_sorting ), extension , config= _ indented_config ( config , indent ), ), code_sorting_indent , ) ) else : stripped_line = line . strip () if stripped_line and not line_separator: line_separator = line [ len ( line . rstrip ()) : ]. replace ( \" \" , \"\" ). replace ( \"\\t\" , \"\" ) for file_skip_comment in FILE_SKIP_COMMENTS : if file_skip_comment in line : raise FileSkipComment ( \"Passed in content\" ) if not in_quote and stripped_line == \"# isort: off\" : isort_off = True if ( ( index == 0 or ( index in ( 1 , 2 ) and not contains_imports )) and stripped_line . startswith ( \"#\" ) and stripped_line not in config . section_comments ) : in_top_comment = True elif in_top_comment: if not line . startswith ( \"#\" ) or stripped_line in config . section_comments: in_top_comment = False first_comment_index_end = index - 1 was_in_quote = bool ( in_quote ) if ( not stripped_line . startswith ( \"#\" ) or in_quote ) and '\"' in line or \"'\" in line : char_index = 0 if first_comment_index_start == - 1 and ( line . startswith ( '\"' ) or line . startswith ( \"'\" ) ) : first_comment_index_start = index while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \": char_index += 1 elif in_quote: if line[char_index : char_index + len(in_quote)] == in_quote: in_quote = \"\" if first_comment_index_end < first_comment_index_start: first_comment_index_end = index elif line[char_index] in (\" '\", ' \"'): long_quote = line[char_index : char_index + 3] if long_quote in ('\"\"\" ', \"''' \"): in_quote = long_quote char_index += 2 else: in_quote = line[char_index] elif line[char_index] == \" # \": break char_index += 1 not_imports = bool(in_quote) or was_in_quote or in_top_comment or isort_off if not (in_quote or was_in_quote or in_top_comment): if isort_off: if stripped_line == \" # isort : on \": isort_off = False elif stripped_line.endswith(\" # isort : split \"): not_imports = True elif stripped_line in CODE_SORT_COMMENTS: code_sorting = stripped_line.split(\" isort : \")[1].strip() code_sorting_indent = line[: -len(line.lstrip())] not_imports = True elif code_sorting: if not stripped_line: output_stream.write( textwrap.indent( isort.literal.assignment( code_sorting_section, str(code_sorting), extension, config=_indented_config(config, indent), ), code_sorting_indent, ) ) not_imports = True code_sorting = False code_sorting_section = \"\" code_sorting_indent = \"\" else: code_sorting_section += line line = \"\" elif stripped_line in config.section_comments: if import_section and not contains_imports: output_stream.write(import_section) import_section = line not_imports = False else: import_section += line indent = line[: -len(line.lstrip())] elif not (stripped_line or contains_imports): not_imports = True elif ( not stripped_line or stripped_line.startswith(\" # \") and (not indent or indent + line.lstrip() == line) and not config.treat_all_comments_as_code and stripped_line not in config.treat_comments_as_code ): import_section += line elif stripped_line.startswith(IMPORT_START_IDENTIFIERS): did_contain_imports = contains_imports contains_imports = True new_indent = line[: -len(line.lstrip())] import_statement = line stripped_line = line.strip().split(\" # \")[0] while stripped_line.endswith(\" \\\\ \") or ( \" ( \" in stripped_line and \" ) \" not in stripped_line ): if stripped_line.endswith(\" \\\\ \"): while stripped_line and stripped_line.endswith(\" \\\\ \"): line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line else: while \" ) \" not in stripped_line: line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line cimport_statement: bool = False if ( import_statement.lstrip().startswith(CIMPORT_IDENTIFIERS) or \" cimport \" in import_statement or \" cimport* \" in import_statement or \" cimport ( \" in import_statement or \" . cimport \" in import_statement ): cimport_statement = True if cimport_statement != cimports or ( new_indent != indent and import_section and (not did_contain_imports or len(new_indent) < len(indent)) ): indent = new_indent if import_section: next_cimports = cimport_statement next_import_section = import_statement import_statement = \"\" not_imports = True line = \"\" else: cimports = cimport_statement else: if new_indent != indent: if import_section and did_contain_imports: import_statement = indent + import_statement.lstrip() else: indent = new_indent import_section += import_statement else: not_imports = True if not_imports: raw_import_section: str = import_section if ( add_imports and (stripped_line or end_of_file) and not config.append_only and not in_top_comment and not in_quote and not import_section and not line.lstrip().startswith(COMMENT_INDICATORS) ): import_section = line_separator.join(add_imports) + line_separator if end_of_file and index != 0: output_stream.write(line_separator) contains_imports = True add_imports = [] if next_import_section and not import_section: # pragma: no cover raw_import_section = import_section = next_import_section next_import_section = \"\" if import_section: if add_imports and not indent: import_section = ( line_separator.join(add_imports) + line_separator + import_section ) contains_imports = True add_imports = [] if not indent: import_section += line raw_import_section += line if not contains_imports: output_stream.write(import_section) else: leading_whitespace = import_section[: -len(import_section.lstrip())] trailing_whitespace = import_section[len(import_section.rstrip()) :] if first_import_section and not import_section.lstrip( line_separator ).startswith(COMMENT_INDICATORS): import_section = import_section.lstrip(line_separator) raw_import_section = raw_import_section.lstrip(line_separator) first_import_section = False if indent: import_section = \"\".join( line[len(indent) :] for line in import_section.splitlines(keepends=True) ) parsed_content = parse.file_contents(import_section, config=config) verbose_output += parsed_content.verbose_output sorted_import_section = output.sorted_imports( parsed_content, _indented_config(config, indent), extension, import_type=\" cimport \" if cimports else \" import \", ) if not (import_section.strip() and not sorted_import_section): if indent: sorted_import_section = ( leading_whitespace + textwrap.indent(sorted_import_section, indent).strip() + trailing_whitespace ) made_changes = made_changes or _has_changed( before=raw_import_section, after=sorted_import_section, line_separator=line_separator, ignore_whitespace=config.ignore_whitespace, ) output_stream.write(sorted_import_section) if not line and not indent and next_import_section: output_stream.write(line_separator) if indent: output_stream.write(line) if not next_import_section: indent = \"\" if next_import_section: cimports = next_cimports contains_imports = True else: contains_imports = False import_section = next_import_section next_import_section = \"\" else: output_stream.write(line) not_imports = False if stripped_line and not in_quote and not import_section and not next_import_section: if stripped_line == \" yield \": while not stripped_line or stripped_line == \" yield \": new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \")[0] if stripped_line.startswith(\" raise \") or stripped_line.startswith(\" yield \"): while stripped_line.endswith(\" \\\\ \"): new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \" )[ 0 ] if made_changes and config . only_modified: for output_str in verbose_output: print ( output_str ) return made_changes","title":"Core"},{"location":"reference/isort/core/#module-isortcore","text":"View Source import textwrap from io import StringIO from itertools import chain from typing import List , TextIO , Union import isort . literal from isort . settings import DEFAULT_CONFIG , Config from . import output , parse from . exceptions import FileSkipComment from . format import format_natural , remove_whitespace from . settings import FILE_SKIP_COMMENTS CIMPORT_IDENTIFIERS = ( \"cimport \" , \"cimport*\" , \"from.cimport\" ) IMPORT_START_IDENTIFIERS = ( \"from \" , \"from.import\" , \"import \" , \"import*\" ) + CIMPORT_IDENTIFIERS COMMENT_INDICATORS = ( '\"\"\"' , \"'''\" , \"'\" , '\"' , \"#\" ) CODE_SORT_COMMENTS = ( \"# isort: list\" , \"# isort: dict\" , \"# isort: set\" , \"# isort: unique-list\" , \"# isort: tuple\" , \"# isort: unique-tuple\" , \"# isort: assignments\" , ) def process ( input_stream: TextIO , output_stream: TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , ) -> bool : \"\"\"Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided `input_stream`, sorted and then outputted to the specified `output_stream`. - `input_stream`: Text stream with unsorted import sections. - `output_stream`: Text stream to output sorted inputs into. - `config`: Config settings to use when sorting imports. Defaults settings. - *Default*: `isort.settings.DEFAULT_CONFIG`. - `extension`: The file extension or file extension rules that should be used. - *Default*: `\" py \"`. - *Choices*: `[\" py \", \" pyi \", \" pyx \"]`. Returns `True` if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise `False`. \"\"\" line_separator: str = config . line_ending add_imports: List [ str ] = [ format_natural ( addition ) for addition in config . add_imports ] import_section: str = \"\" next_import_section: str = \"\" next_cimports: bool = False in_quote: str = \"\" first_comment_index_start: int = - 1 first_comment_index_end: int = - 1 contains_imports: bool = False in_top_comment: bool = False first_import_section: bool = True indent : str = \"\" isort_off: bool = False code_sorting: Union [ bool , str ] = False code_sorting_section: str = \"\" code_sorting_indent: str = \"\" cimports : bool = False made_changes: bool = False stripped_line: str = \"\" end_of_file: bool = False verbose_output: List [ str ] = [] if config . float_to_top: new_input = \"\" current = \"\" isort_off = False for line in chain ( input_stream , ( None ,)) : if isort_off and line is not None : if line == \"# isort: on\\n\" : isort_off = False new_input += line elif line in ( \"# isort: split\\n\" , \"# isort: off\\n\" , None ) or str ( line ). endswith ( \"# isort: split\\n\" ) : if line == \"# isort: off\\n\" : isort_off = True if current : if add_imports: add_line_separator = line_separator or \"\\n\" current += add_line_separator + add_line_separator . join ( add_imports ) add_imports = [] parsed = parse . file_contents ( current , config = config ) verbose_output += parsed . verbose_output extra_space = \"\" while current and current [ - 1 ] == \"\\n\" : extra_space += \"\\n\" current = current [:- 1 ] extra_space = extra_space . replace ( \"\\n\" , \"\" , 1 ) sorted_output = output . sorted_imports ( parsed , config , extension , import_type= \"import\" ) made_changes = made_changes or _ has_changed ( before = current , after = sorted_output , line_separator = parsed . line_separator , ignore_whitespace = config . ignore_whitespace , ) new_input += sorted_output new_input += extra_space current = \"\" new_input += line or \"\" else : current += line or \"\" input_stream = StringIO ( new_input ) for index , line in enumerate ( chain ( input_stream , ( None ,))) : if line is None : if index == 0 and not config . force_adds: return False not_imports = True end_of_file = True line = \"\" if not line_separator: line_separator = \"\\n\" if code_sorting and code_sorting_section: output_stream . write ( textwrap . indent ( isort . literal . assignment ( code_sorting_section , str ( code_sorting ), extension , config= _ indented_config ( config , indent ), ), code_sorting_indent , ) ) else : stripped_line = line . strip () if stripped_line and not line_separator: line_separator = line [ len ( line . rstrip ()) : ]. replace ( \" \" , \"\" ). replace ( \"\\t\" , \"\" ) for file_skip_comment in FILE_SKIP_COMMENTS : if file_skip_comment in line : raise FileSkipComment ( \"Passed in content\" ) if not in_quote and stripped_line == \"# isort: off\" : isort_off = True if ( ( index == 0 or ( index in ( 1 , 2 ) and not contains_imports )) and stripped_line . startswith ( \"#\" ) and stripped_line not in config . section_comments ) : in_top_comment = True elif in_top_comment: if not line . startswith ( \"#\" ) or stripped_line in config . section_comments: in_top_comment = False first_comment_index_end = index - 1 was_in_quote = bool ( in_quote ) if ( not stripped_line . startswith ( \"#\" ) or in_quote ) and '\"' in line or \"'\" in line : char_index = 0 if first_comment_index_start == - 1 and ( line . startswith ( '\"' ) or line . startswith ( \"'\" ) ) : first_comment_index_start = index while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \": char_index += 1 elif in_quote: if line[char_index : char_index + len(in_quote)] == in_quote: in_quote = \"\" if first_comment_index_end < first_comment_index_start: first_comment_index_end = index elif line[char_index] in (\" '\", ' \"'): long_quote = line[char_index : char_index + 3] if long_quote in ('\"\"\" ', \"''' \"): in_quote = long_quote char_index += 2 else: in_quote = line[char_index] elif line[char_index] == \" # \": break char_index += 1 not_imports = bool(in_quote) or was_in_quote or in_top_comment or isort_off if not (in_quote or was_in_quote or in_top_comment): if isort_off: if stripped_line == \" # isort : on \": isort_off = False elif stripped_line.endswith(\" # isort : split \"): not_imports = True elif stripped_line in CODE_SORT_COMMENTS: code_sorting = stripped_line.split(\" isort : \")[1].strip() code_sorting_indent = line[: -len(line.lstrip())] not_imports = True elif code_sorting: if not stripped_line: output_stream.write( textwrap.indent( isort.literal.assignment( code_sorting_section, str(code_sorting), extension, config=_indented_config(config, indent), ), code_sorting_indent, ) ) not_imports = True code_sorting = False code_sorting_section = \"\" code_sorting_indent = \"\" else: code_sorting_section += line line = \"\" elif stripped_line in config.section_comments: if import_section and not contains_imports: output_stream.write(import_section) import_section = line not_imports = False else: import_section += line indent = line[: -len(line.lstrip())] elif not (stripped_line or contains_imports): not_imports = True elif ( not stripped_line or stripped_line.startswith(\" # \") and (not indent or indent + line.lstrip() == line) and not config.treat_all_comments_as_code and stripped_line not in config.treat_comments_as_code ): import_section += line elif stripped_line.startswith(IMPORT_START_IDENTIFIERS): did_contain_imports = contains_imports contains_imports = True new_indent = line[: -len(line.lstrip())] import_statement = line stripped_line = line.strip().split(\" # \")[0] while stripped_line.endswith(\" \\\\ \") or ( \" ( \" in stripped_line and \" ) \" not in stripped_line ): if stripped_line.endswith(\" \\\\ \"): while stripped_line and stripped_line.endswith(\" \\\\ \"): line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line else: while \" ) \" not in stripped_line: line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line cimport_statement: bool = False if ( import_statement.lstrip().startswith(CIMPORT_IDENTIFIERS) or \" cimport \" in import_statement or \" cimport* \" in import_statement or \" cimport ( \" in import_statement or \" . cimport \" in import_statement ): cimport_statement = True if cimport_statement != cimports or ( new_indent != indent and import_section and (not did_contain_imports or len(new_indent) < len(indent)) ): indent = new_indent if import_section: next_cimports = cimport_statement next_import_section = import_statement import_statement = \"\" not_imports = True line = \"\" else: cimports = cimport_statement else: if new_indent != indent: if import_section and did_contain_imports: import_statement = indent + import_statement.lstrip() else: indent = new_indent import_section += import_statement else: not_imports = True if not_imports: raw_import_section: str = import_section if ( add_imports and (stripped_line or end_of_file) and not config.append_only and not in_top_comment and not in_quote and not import_section and not line.lstrip().startswith(COMMENT_INDICATORS) ): import_section = line_separator.join(add_imports) + line_separator if end_of_file and index != 0: output_stream.write(line_separator) contains_imports = True add_imports = [] if next_import_section and not import_section: # pragma: no cover raw_import_section = import_section = next_import_section next_import_section = \"\" if import_section: if add_imports and not indent: import_section = ( line_separator.join(add_imports) + line_separator + import_section ) contains_imports = True add_imports = [] if not indent: import_section += line raw_import_section += line if not contains_imports: output_stream.write(import_section) else: leading_whitespace = import_section[: -len(import_section.lstrip())] trailing_whitespace = import_section[len(import_section.rstrip()) :] if first_import_section and not import_section.lstrip( line_separator ).startswith(COMMENT_INDICATORS): import_section = import_section.lstrip(line_separator) raw_import_section = raw_import_section.lstrip(line_separator) first_import_section = False if indent: import_section = \"\".join( line[len(indent) :] for line in import_section.splitlines(keepends=True) ) parsed_content = parse.file_contents(import_section, config=config) verbose_output += parsed_content.verbose_output sorted_import_section = output.sorted_imports( parsed_content, _indented_config(config, indent), extension, import_type=\" cimport \" if cimports else \" import \", ) if not (import_section.strip() and not sorted_import_section): if indent: sorted_import_section = ( leading_whitespace + textwrap.indent(sorted_import_section, indent).strip() + trailing_whitespace ) made_changes = made_changes or _has_changed( before=raw_import_section, after=sorted_import_section, line_separator=line_separator, ignore_whitespace=config.ignore_whitespace, ) output_stream.write(sorted_import_section) if not line and not indent and next_import_section: output_stream.write(line_separator) if indent: output_stream.write(line) if not next_import_section: indent = \"\" if next_import_section: cimports = next_cimports contains_imports = True else: contains_imports = False import_section = next_import_section next_import_section = \"\" else: output_stream.write(line) not_imports = False if stripped_line and not in_quote and not import_section and not next_import_section: if stripped_line == \" yield \": while not stripped_line or stripped_line == \" yield \": new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \")[0] if stripped_line.startswith(\" raise \") or stripped_line.startswith(\" yield \"): while stripped_line.endswith(\" \\\\ \"): new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \" )[ 0 ] if made_changes and config . only_modified: for output_str in verbose_output: print ( output_str ) return made_changes def _ indented_config ( config : Config , indent : str ) : if not indent : return config return Config ( config = config , line_length = max ( config . line_length - len ( indent ), 0 ), wrap_length = max ( config . wrap_length - len ( indent ), 0 ), lines_after_imports = 1 , import_headings = config . import_headings if config . indented_import_headings else {}, ) def _ has_changed ( before : str , after : str , line_separator: str , ignore_whitespace: bool ) -> bool : if ignore_whitespace: return ( remove_whitespace ( before , line_separator = line_separator ). strip () ! = remove_whitespace ( after , line_separator = line_separator ). strip () ) return before . strip () ! = after . strip ()","title":"Module isort.core"},{"location":"reference/isort/core/#variables","text":"CIMPORT_IDENTIFIERS CODE_SORT_COMMENTS COMMENT_INDICATORS FILE_SKIP_COMMENTS IMPORT_START_IDENTIFIERS","title":"Variables"},{"location":"reference/isort/core/#functions","text":"","title":"Functions"},{"location":"reference/isort/core/#process","text":"def process ( input_stream : < class ' TextIO '>, output_stream : < class ' TextIO '>, extension : str = 'py' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> bool Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided input_stream , sorted and then outputted to the specified output_stream . input_stream : Text stream with unsorted import sections. output_stream : Text stream to output sorted inputs into. config : Config settings to use when sorting imports. Defaults settings. Default : isort.settings.DEFAULT_CONFIG . extension : The file extension or file extension rules that should be used. Default : \"py\" . Choices : [\"py\", \"pyi\", \"pyx\"] . Returns True if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise False . View Source def process ( input_stream: TextIO , output_stream: TextIO , extension : str = \"py\" , config : Config = DEFAULT_CONFIG , ) -> bool : \"\"\"Parses stream identifying sections of contiguous imports and sorting them Code with unsorted imports is read from the provided `input_stream`, sorted and then outputted to the specified `output_stream`. - `input_stream`: Text stream with unsorted import sections. - `output_stream`: Text stream to output sorted inputs into. - `config`: Config settings to use when sorting imports. Defaults settings. - *Default*: `isort.settings.DEFAULT_CONFIG`. - `extension`: The file extension or file extension rules that should be used. - *Default*: `\" py \"`. - *Choices*: `[\" py \", \" pyi \", \" pyx \"]`. Returns `True` if there were changes that needed to be made (errors present) from what was provided in the input_stream, otherwise `False`. \"\"\" line_separator: str = config . line_ending add_imports: List [ str ] = [ format_natural ( addition ) for addition in config . add_imports ] import_section: str = \"\" next_import_section: str = \"\" next_cimports: bool = False in_quote: str = \"\" first_comment_index_start: int = - 1 first_comment_index_end: int = - 1 contains_imports: bool = False in_top_comment: bool = False first_import_section: bool = True indent : str = \"\" isort_off: bool = False code_sorting: Union [ bool , str ] = False code_sorting_section: str = \"\" code_sorting_indent: str = \"\" cimports : bool = False made_changes: bool = False stripped_line: str = \"\" end_of_file: bool = False verbose_output: List [ str ] = [] if config . float_to_top: new_input = \"\" current = \"\" isort_off = False for line in chain ( input_stream , ( None ,)) : if isort_off and line is not None : if line == \"# isort: on\\n\" : isort_off = False new_input += line elif line in ( \"# isort: split\\n\" , \"# isort: off\\n\" , None ) or str ( line ). endswith ( \"# isort: split\\n\" ) : if line == \"# isort: off\\n\" : isort_off = True if current : if add_imports: add_line_separator = line_separator or \"\\n\" current += add_line_separator + add_line_separator . join ( add_imports ) add_imports = [] parsed = parse . file_contents ( current , config = config ) verbose_output += parsed . verbose_output extra_space = \"\" while current and current [ - 1 ] == \"\\n\" : extra_space += \"\\n\" current = current [:- 1 ] extra_space = extra_space . replace ( \"\\n\" , \"\" , 1 ) sorted_output = output . sorted_imports ( parsed , config , extension , import_type= \"import\" ) made_changes = made_changes or _ has_changed ( before = current , after = sorted_output , line_separator = parsed . line_separator , ignore_whitespace = config . ignore_whitespace , ) new_input += sorted_output new_input += extra_space current = \"\" new_input += line or \"\" else : current += line or \"\" input_stream = StringIO ( new_input ) for index , line in enumerate ( chain ( input_stream , ( None ,))) : if line is None : if index == 0 and not config . force_adds: return False not_imports = True end_of_file = True line = \"\" if not line_separator: line_separator = \"\\n\" if code_sorting and code_sorting_section: output_stream . write ( textwrap . indent ( isort . literal . assignment ( code_sorting_section , str ( code_sorting ), extension , config= _ indented_config ( config , indent ), ), code_sorting_indent , ) ) else : stripped_line = line . strip () if stripped_line and not line_separator: line_separator = line [ len ( line . rstrip ()) : ]. replace ( \" \" , \"\" ). replace ( \"\\t\" , \"\" ) for file_skip_comment in FILE_SKIP_COMMENTS : if file_skip_comment in line : raise FileSkipComment ( \"Passed in content\" ) if not in_quote and stripped_line == \"# isort: off\" : isort_off = True if ( ( index == 0 or ( index in ( 1 , 2 ) and not contains_imports )) and stripped_line . startswith ( \"#\" ) and stripped_line not in config . section_comments ) : in_top_comment = True elif in_top_comment: if not line . startswith ( \"#\" ) or stripped_line in config . section_comments: in_top_comment = False first_comment_index_end = index - 1 was_in_quote = bool ( in_quote ) if ( not stripped_line . startswith ( \"#\" ) or in_quote ) and '\"' in line or \"'\" in line : char_index = 0 if first_comment_index_start == - 1 and ( line . startswith ( '\"' ) or line . startswith ( \"'\" ) ) : first_comment_index_start = index while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \": char_index += 1 elif in_quote: if line[char_index : char_index + len(in_quote)] == in_quote: in_quote = \"\" if first_comment_index_end < first_comment_index_start: first_comment_index_end = index elif line[char_index] in (\" '\", ' \"'): long_quote = line[char_index : char_index + 3] if long_quote in ('\"\"\" ', \"''' \"): in_quote = long_quote char_index += 2 else: in_quote = line[char_index] elif line[char_index] == \" # \": break char_index += 1 not_imports = bool(in_quote) or was_in_quote or in_top_comment or isort_off if not (in_quote or was_in_quote or in_top_comment): if isort_off: if stripped_line == \" # isort : on \": isort_off = False elif stripped_line.endswith(\" # isort : split \"): not_imports = True elif stripped_line in CODE_SORT_COMMENTS: code_sorting = stripped_line.split(\" isort : \")[1].strip() code_sorting_indent = line[: -len(line.lstrip())] not_imports = True elif code_sorting: if not stripped_line: output_stream.write( textwrap.indent( isort.literal.assignment( code_sorting_section, str(code_sorting), extension, config=_indented_config(config, indent), ), code_sorting_indent, ) ) not_imports = True code_sorting = False code_sorting_section = \"\" code_sorting_indent = \"\" else: code_sorting_section += line line = \"\" elif stripped_line in config.section_comments: if import_section and not contains_imports: output_stream.write(import_section) import_section = line not_imports = False else: import_section += line indent = line[: -len(line.lstrip())] elif not (stripped_line or contains_imports): not_imports = True elif ( not stripped_line or stripped_line.startswith(\" # \") and (not indent or indent + line.lstrip() == line) and not config.treat_all_comments_as_code and stripped_line not in config.treat_comments_as_code ): import_section += line elif stripped_line.startswith(IMPORT_START_IDENTIFIERS): did_contain_imports = contains_imports contains_imports = True new_indent = line[: -len(line.lstrip())] import_statement = line stripped_line = line.strip().split(\" # \")[0] while stripped_line.endswith(\" \\\\ \") or ( \" ( \" in stripped_line and \" ) \" not in stripped_line ): if stripped_line.endswith(\" \\\\ \"): while stripped_line and stripped_line.endswith(\" \\\\ \"): line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line else: while \" ) \" not in stripped_line: line = input_stream.readline() stripped_line = line.strip().split(\" # \")[0] import_statement += line cimport_statement: bool = False if ( import_statement.lstrip().startswith(CIMPORT_IDENTIFIERS) or \" cimport \" in import_statement or \" cimport* \" in import_statement or \" cimport ( \" in import_statement or \" . cimport \" in import_statement ): cimport_statement = True if cimport_statement != cimports or ( new_indent != indent and import_section and (not did_contain_imports or len(new_indent) < len(indent)) ): indent = new_indent if import_section: next_cimports = cimport_statement next_import_section = import_statement import_statement = \"\" not_imports = True line = \"\" else: cimports = cimport_statement else: if new_indent != indent: if import_section and did_contain_imports: import_statement = indent + import_statement.lstrip() else: indent = new_indent import_section += import_statement else: not_imports = True if not_imports: raw_import_section: str = import_section if ( add_imports and (stripped_line or end_of_file) and not config.append_only and not in_top_comment and not in_quote and not import_section and not line.lstrip().startswith(COMMENT_INDICATORS) ): import_section = line_separator.join(add_imports) + line_separator if end_of_file and index != 0: output_stream.write(line_separator) contains_imports = True add_imports = [] if next_import_section and not import_section: # pragma: no cover raw_import_section = import_section = next_import_section next_import_section = \"\" if import_section: if add_imports and not indent: import_section = ( line_separator.join(add_imports) + line_separator + import_section ) contains_imports = True add_imports = [] if not indent: import_section += line raw_import_section += line if not contains_imports: output_stream.write(import_section) else: leading_whitespace = import_section[: -len(import_section.lstrip())] trailing_whitespace = import_section[len(import_section.rstrip()) :] if first_import_section and not import_section.lstrip( line_separator ).startswith(COMMENT_INDICATORS): import_section = import_section.lstrip(line_separator) raw_import_section = raw_import_section.lstrip(line_separator) first_import_section = False if indent: import_section = \"\".join( line[len(indent) :] for line in import_section.splitlines(keepends=True) ) parsed_content = parse.file_contents(import_section, config=config) verbose_output += parsed_content.verbose_output sorted_import_section = output.sorted_imports( parsed_content, _indented_config(config, indent), extension, import_type=\" cimport \" if cimports else \" import \", ) if not (import_section.strip() and not sorted_import_section): if indent: sorted_import_section = ( leading_whitespace + textwrap.indent(sorted_import_section, indent).strip() + trailing_whitespace ) made_changes = made_changes or _has_changed( before=raw_import_section, after=sorted_import_section, line_separator=line_separator, ignore_whitespace=config.ignore_whitespace, ) output_stream.write(sorted_import_section) if not line and not indent and next_import_section: output_stream.write(line_separator) if indent: output_stream.write(line) if not next_import_section: indent = \"\" if next_import_section: cimports = next_cimports contains_imports = True else: contains_imports = False import_section = next_import_section next_import_section = \"\" else: output_stream.write(line) not_imports = False if stripped_line and not in_quote and not import_section and not next_import_section: if stripped_line == \" yield \": while not stripped_line or stripped_line == \" yield \": new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \")[0] if stripped_line.startswith(\" raise \") or stripped_line.startswith(\" yield \"): while stripped_line.endswith(\" \\\\ \"): new_line = input_stream.readline() if not new_line: break output_stream.write(new_line) stripped_line = new_line.strip().split(\" # \" )[ 0 ] if made_changes and config . only_modified: for output_str in verbose_output: print ( output_str ) return made_changes","title":"process"},{"location":"reference/isort/exceptions/","text":"Module isort.exceptions All isort specific exception classes should be defined here View Source \"\"\"All isort specific exception classes should be defined here\"\"\" from pathlib import Path from typing import Any , Dict , Union from .profiles import profiles class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\" class InvalidSettingsPath ( ISortError ): \"\"\"Raised when a settings path is provided that is neither a valid file or directory\"\"\" def __init__ ( self , settings_path : str ): super () . __init__ ( f \"isort was told to use the settings_path: {settings_path} as the base directory or \" \"file that represents the starting point of config file discovery, but it does not \" \"exist.\" ) self . settings_path = settings_path class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message : str , file_path : str ): super () . __init__ ( message ) self . file_path = file_path class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path ) class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , ) class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile : str ): super () . __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile class FormattingPluginDoesNotExist ( ISortError ): \"\"\"Raised when a formatting plugin is set by the user that doesn't exist\"\"\" def __init__ ( self , formatter : str ): super () . __init__ ( f \"Specified formatting plugin of {formatter} does not exist. \" ) self . formatter = formatter class LiteralParsingFailure ( ISortError ): \"\"\"Raised when one of isorts literal sorting comments is used but isort can't parse the the given data structure. \"\"\" def __init__ ( self , code : str , original_error : Exception ): super () . __init__ ( f \"isort failed to parse the given literal {code}. It's important to note \" \"that isort literal sorting only supports simple literals parsable by \" f \"ast.literal_eval which gave the exception of {original_error}.\" ) self . code = code self . original_error = original_error class LiteralSortTypeMismatch ( ISortError ): \"\"\"Raised when an isort literal sorting comment is used, with a type that doesn't match the supplied data structure's type. \"\"\" def __init__ ( self , kind : type , expected_kind : type ): super () . __init__ ( f \"isort was told to sort a literal of type {expected_kind} but was given \" f \"a literal of type {kind}.\" ) self . kind = kind self . expected_kind = expected_kind class AssignmentsFormatMismatch ( ISortError ): \"\"\"Raised when isort is told to sort assignments but the format of the assignment section doesn't match isort's expectation. \"\"\" def __init__ ( self , code : str ): super () . __init__ ( \"isort was told to sort a section of assignments, however the given code: \\n\\n \" f \"{code} \\n\\n \" \"Does not match isort's strict single line formatting requirement for assignment \" \"sorting: \\n\\n \" \"{variable_name} = {value} \\n \" \"{variable_name2} = {value2} \\n \" \"... \\n\\n \" ) self . code = code class UnsupportedSettings ( ISortError ): \"\"\"Raised when settings are passed into isort (either from config, CLI, or runtime) that it doesn't support. \"\"\" @staticmethod def _format_option ( name : str , value : Any , source : str ) -> str : return f \" \\t - {name} = {value} (source: '{source}')\" def __init__ ( self , unsupported_settings : Dict [ str , Dict [ str , str ]]): errors = \" \\n \" . join ( self . _format_option ( name , ** option ) for name , option in unsupported_settings . items () ) super () . __init__ ( \"isort was provided settings that it doesn't support: \\n\\n \" f \"{errors} \\n\\n \" \"For a complete and up-to-date listing of supported settings see: \" \"https://pycqa.github.io/isort/docs/configuration/options/. \\n \" ) self . unsupported_settings = unsupported_settings class UnsupportedEncoding ( ISortError ): \"\"\"Raised when isort encounters an encoding error while trying to read a file\"\"\" def __init__ ( self , filename : Union [ str , Path ]): super () . __init__ ( f \"Unknown or unsupported encoding in {filename}\" ) self . filename = filename class MissingSection ( ISortError ): \"\"\"Raised when isort encounters an import that matches a section that is not defined\"\"\" def __init__ ( self , import_module : str , section : str ): super () . __init__ ( f \"Found {import_module} import while parsing, but {section} was not included \" \"in the `sections` setting of your config. Please add it before continuing \\n \" \"See https://pycqa.github.io/isort/#custom-sections-and-ordering \" \"for more info.\" ) Variables profiles Classes AssignmentsFormatMismatch class AssignmentsFormatMismatch ( code : str ) Raised when isort is told to sort assignments but the format of the assignment section doesn't match isort's expectation. View Source class AssignmentsFormatMismatch ( ISortError ): \"\"\"Raised when isort is told to sort assignments but the format of the assignment section doesn't match isort's expectation. \"\"\" def __init__ ( self , code : str ): super () . __init__ ( \"isort was told to sort a section of assignments, however the given code: \\n\\n \" f \"{code} \\n\\n \" \"Does not match isort's strict single line formatting requirement for assignment \" \"sorting: \\n\\n \" \"{variable_name} = {value} \\n \" \"{variable_name2} = {value2} \\n \" \"... \\n\\n \" ) self . code = code Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ExistingSyntaxErrors class ExistingSyntaxErrors ( file_path : str ) Raised when isort is told to sort imports within code that has existing syntax errors View Source class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FileSkipComment class FileSkipComment ( file_path : str ) Raised when an entire file is skipped due to a isort skip file comment View Source class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path ) Ancestors (in MRO) isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FileSkipSetting class FileSkipSetting ( file_path : str ) Raised when an entire file is skipped due to provided isort settings View Source class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , ) Ancestors (in MRO) isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FileSkipped class FileSkipped ( message : str , file_path : str ) Should be raised when a file is skipped for any reason View Source class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message: str , file_path: str ): super (). __init__ ( message ) self . file_path = file_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Descendants isort.exceptions.FileSkipComment isort.exceptions.FileSkipSetting Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. FormattingPluginDoesNotExist class FormattingPluginDoesNotExist ( formatter : str ) Raised when a formatting plugin is set by the user that doesn't exist View Source class FormattingPluginDoesNotExist ( ISortError ): \"\"\"Raised when a formatting plugin is set by the user that doesn't exist\"\"\" def __init__ ( self , formatter: str ): super (). __init__ ( f \"Specified formatting plugin of {formatter} does not exist. \" ) self . formatter = formatter Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ISortError class ISortError ( / , * args , ** kwargs ) Base isort exception object from which all isort sourced exceptions should inherit View Source class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants isort.exceptions.InvalidSettingsPath isort.exceptions.ExistingSyntaxErrors isort.exceptions.IntroducedSyntaxErrors isort.exceptions.FileSkipped isort.exceptions.ProfileDoesNotExist isort.exceptions.FormattingPluginDoesNotExist isort.exceptions.LiteralParsingFailure isort.exceptions.LiteralSortTypeMismatch isort.exceptions.AssignmentsFormatMismatch isort.exceptions.UnsupportedSettings isort.exceptions.UnsupportedEncoding isort.exceptions.MissingSection Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. IntroducedSyntaxErrors class IntroducedSyntaxErrors ( file_path : str ) Raised when isort has introduced a syntax error in the process of sorting imports View Source class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidSettingsPath class InvalidSettingsPath ( settings_path : str ) Raised when a settings path is provided that is neither a valid file or directory View Source class InvalidSettingsPath ( ISortError ): \"\"\"Raised when a settings path is provided that is neither a valid file or directory\"\"\" def __init__ ( self , settings_path: str ): super (). __init__ ( f \"isort was told to use the settings_path: {settings_path} as the base directory or \" \"file that represents the starting point of config file discovery, but it does not \" \"exist.\" ) self . settings_path = settings_path Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. LiteralParsingFailure class LiteralParsingFailure ( code : str , original_error : Exception ) Raised when one of isorts literal sorting comments is used but isort can't parse the the given data structure. View Source class LiteralParsingFailure ( ISortError ): \"\"\"Raised when one of isorts literal sorting comments is used but isort can't parse the the given data structure. \"\"\" def __init__ ( self , code: str , original_error: Exception ): super (). __init__ ( f \"isort failed to parse the given literal {code}. It's important to note \" \"that isort literal sorting only supports simple literals parsable by \" f \"ast.literal_eval which gave the exception of {original_error}.\" ) self . code = code self . original_error = original_error Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. LiteralSortTypeMismatch class LiteralSortTypeMismatch ( kind : type , expected_kind : type ) Raised when an isort literal sorting comment is used, with a type that doesn't match the supplied data structure's type. View Source class LiteralSortTypeMismatch ( ISortError ): \"\"\"Raised when an isort literal sorting comment is used, with a type that doesn't match the supplied data structure's type. \"\"\" def __init__ ( self , kind: type , expected_kind: type ): super (). __init__ ( f \"isort was told to sort a literal of type {expected_kind} but was given \" f \"a literal of type {kind}.\" ) self . kind = kind self . expected_kind = expected_kind Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. MissingSection class MissingSection ( import_module : str , section : str ) Raised when isort encounters an import that matches a section that is not defined View Source class MissingSection ( ISortError ): \"\"\"Raised when isort encounters an import that matches a section that is not defined\"\"\" def __init__ ( self , import_module : str , section : str ): super () . __init__ ( f \"Found {import_module} import while parsing, but {section} was not included \" \"in the `sections` setting of your config. Please add it before continuing \\n \" \"See https://pycqa.github.io/isort/#custom-sections-and-ordering \" \"for more info.\" ) Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. ProfileDoesNotExist class ProfileDoesNotExist ( profile : str ) Raised when a profile is set by the user that doesn't exist View Source class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile: str ): super (). __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnsupportedEncoding class UnsupportedEncoding ( filename : Union [ str , pathlib . Path ] ) Raised when isort encounters an encoding error while trying to read a file View Source class UnsupportedEncoding ( ISortError ): \"\"\"Raised when isort encounters an encoding error while trying to read a file\"\"\" def __init__ ( self , filename: Union [ str , Path ]): super (). __init__ ( f \"Unknown or unsupported encoding in {filename}\" ) self . filename = filename Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnsupportedSettings class UnsupportedSettings ( unsupported_settings : Dict [ str , Dict [ str , str ]] ) Raised when settings are passed into isort (either from config, CLI, or runtime) that it doesn't support. View Source class UnsupportedSettings ( ISortError ) : \"\"\"Raised when settings are passed into isort (either from config, CLI, or runtime) that it doesn't support. \"\"\" @staticmethod def _format_option ( name : str , value : Any , source : str ) -> str : return f \"\\t- {name} = {value} (source: '{source}')\" def __init__ ( self , unsupported_settings : Dict [ str, Dict[str, str ] ] ) : errors = \"\\n\" . join ( self . _format_option ( name , ** option ) for name , option in unsupported_settings . items () ) super (). __init__ ( \"isort was provided settings that it doesn't support:\\n\\n\" f \"{errors}\\n\\n\" \"For a complete and up-to-date listing of supported settings see: \" \"https://pycqa.github.io/isort/docs/configuration/options/.\\n\" ) self . unsupported_settings = unsupported_settings Ancestors (in MRO) isort.exceptions.ISortError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/isort/exceptions/#module-isortexceptions","text":"All isort specific exception classes should be defined here View Source \"\"\"All isort specific exception classes should be defined here\"\"\" from pathlib import Path from typing import Any , Dict , Union from .profiles import profiles class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\" class InvalidSettingsPath ( ISortError ): \"\"\"Raised when a settings path is provided that is neither a valid file or directory\"\"\" def __init__ ( self , settings_path : str ): super () . __init__ ( f \"isort was told to use the settings_path: {settings_path} as the base directory or \" \"file that represents the starting point of config file discovery, but it does not \" \"exist.\" ) self . settings_path = settings_path class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message : str , file_path : str ): super () . __init__ ( message ) self . file_path = file_path class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path ) class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path : str ): super () . __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , ) class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile : str ): super () . __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile class FormattingPluginDoesNotExist ( ISortError ): \"\"\"Raised when a formatting plugin is set by the user that doesn't exist\"\"\" def __init__ ( self , formatter : str ): super () . __init__ ( f \"Specified formatting plugin of {formatter} does not exist. \" ) self . formatter = formatter class LiteralParsingFailure ( ISortError ): \"\"\"Raised when one of isorts literal sorting comments is used but isort can't parse the the given data structure. \"\"\" def __init__ ( self , code : str , original_error : Exception ): super () . __init__ ( f \"isort failed to parse the given literal {code}. It's important to note \" \"that isort literal sorting only supports simple literals parsable by \" f \"ast.literal_eval which gave the exception of {original_error}.\" ) self . code = code self . original_error = original_error class LiteralSortTypeMismatch ( ISortError ): \"\"\"Raised when an isort literal sorting comment is used, with a type that doesn't match the supplied data structure's type. \"\"\" def __init__ ( self , kind : type , expected_kind : type ): super () . __init__ ( f \"isort was told to sort a literal of type {expected_kind} but was given \" f \"a literal of type {kind}.\" ) self . kind = kind self . expected_kind = expected_kind class AssignmentsFormatMismatch ( ISortError ): \"\"\"Raised when isort is told to sort assignments but the format of the assignment section doesn't match isort's expectation. \"\"\" def __init__ ( self , code : str ): super () . __init__ ( \"isort was told to sort a section of assignments, however the given code: \\n\\n \" f \"{code} \\n\\n \" \"Does not match isort's strict single line formatting requirement for assignment \" \"sorting: \\n\\n \" \"{variable_name} = {value} \\n \" \"{variable_name2} = {value2} \\n \" \"... \\n\\n \" ) self . code = code class UnsupportedSettings ( ISortError ): \"\"\"Raised when settings are passed into isort (either from config, CLI, or runtime) that it doesn't support. \"\"\" @staticmethod def _format_option ( name : str , value : Any , source : str ) -> str : return f \" \\t - {name} = {value} (source: '{source}')\" def __init__ ( self , unsupported_settings : Dict [ str , Dict [ str , str ]]): errors = \" \\n \" . join ( self . _format_option ( name , ** option ) for name , option in unsupported_settings . items () ) super () . __init__ ( \"isort was provided settings that it doesn't support: \\n\\n \" f \"{errors} \\n\\n \" \"For a complete and up-to-date listing of supported settings see: \" \"https://pycqa.github.io/isort/docs/configuration/options/. \\n \" ) self . unsupported_settings = unsupported_settings class UnsupportedEncoding ( ISortError ): \"\"\"Raised when isort encounters an encoding error while trying to read a file\"\"\" def __init__ ( self , filename : Union [ str , Path ]): super () . __init__ ( f \"Unknown or unsupported encoding in {filename}\" ) self . filename = filename class MissingSection ( ISortError ): \"\"\"Raised when isort encounters an import that matches a section that is not defined\"\"\" def __init__ ( self , import_module : str , section : str ): super () . __init__ ( f \"Found {import_module} import while parsing, but {section} was not included \" \"in the `sections` setting of your config. Please add it before continuing \\n \" \"See https://pycqa.github.io/isort/#custom-sections-and-ordering \" \"for more info.\" )","title":"Module isort.exceptions"},{"location":"reference/isort/exceptions/#variables","text":"profiles","title":"Variables"},{"location":"reference/isort/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/isort/exceptions/#assignmentsformatmismatch","text":"class AssignmentsFormatMismatch ( code : str ) Raised when isort is told to sort assignments but the format of the assignment section doesn't match isort's expectation. View Source class AssignmentsFormatMismatch ( ISortError ): \"\"\"Raised when isort is told to sort assignments but the format of the assignment section doesn't match isort's expectation. \"\"\" def __init__ ( self , code : str ): super () . __init__ ( \"isort was told to sort a section of assignments, however the given code: \\n\\n \" f \"{code} \\n\\n \" \"Does not match isort's strict single line formatting requirement for assignment \" \"sorting: \\n\\n \" \"{variable_name} = {value} \\n \" \"{variable_name2} = {value2} \\n \" \"... \\n\\n \" ) self . code = code","title":"AssignmentsFormatMismatch"},{"location":"reference/isort/exceptions/#ancestors-in-mro","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#existingsyntaxerrors","text":"class ExistingSyntaxErrors ( file_path : str ) Raised when isort is told to sort imports within code that has existing syntax errors View Source class ExistingSyntaxErrors ( ISortError ): \"\"\"Raised when isort is told to sort imports within code that has existing syntax errors\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort was told to sort imports within code that contains syntax errors: \" f \"{file_path}.\" ) self . file_path = file_path","title":"ExistingSyntaxErrors"},{"location":"reference/isort/exceptions/#ancestors-in-mro_1","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#fileskipcomment","text":"class FileSkipComment ( file_path : str ) Raised when an entire file is skipped due to a isort skip file comment View Source class FileSkipComment ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to a isort skip file comment\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} contains an file skip comment and was skipped.\" , file_path = file_path )","title":"FileSkipComment"},{"location":"reference/isort/exceptions/#ancestors-in-mro_2","text":"isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#fileskipsetting","text":"class FileSkipSetting ( file_path : str ) Raised when an entire file is skipped due to provided isort settings View Source class FileSkipSetting ( FileSkipped ): \"\"\"Raised when an entire file is skipped due to provided isort settings\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"{file_path} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" , file_path = file_path , )","title":"FileSkipSetting"},{"location":"reference/isort/exceptions/#ancestors-in-mro_3","text":"isort.exceptions.FileSkipped isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_3","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_3","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#fileskipped","text":"class FileSkipped ( message : str , file_path : str ) Should be raised when a file is skipped for any reason View Source class FileSkipped ( ISortError ): \"\"\"Should be raised when a file is skipped for any reason\"\"\" def __init__ ( self , message: str , file_path: str ): super (). __init__ ( message ) self . file_path = file_path","title":"FileSkipped"},{"location":"reference/isort/exceptions/#ancestors-in-mro_4","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#descendants","text":"isort.exceptions.FileSkipComment isort.exceptions.FileSkipSetting","title":"Descendants"},{"location":"reference/isort/exceptions/#class-variables_4","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_4","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#formattingplugindoesnotexist","text":"class FormattingPluginDoesNotExist ( formatter : str ) Raised when a formatting plugin is set by the user that doesn't exist View Source class FormattingPluginDoesNotExist ( ISortError ): \"\"\"Raised when a formatting plugin is set by the user that doesn't exist\"\"\" def __init__ ( self , formatter: str ): super (). __init__ ( f \"Specified formatting plugin of {formatter} does not exist. \" ) self . formatter = formatter","title":"FormattingPluginDoesNotExist"},{"location":"reference/isort/exceptions/#ancestors-in-mro_5","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_5","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_5","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#isorterror","text":"class ISortError ( / , * args , ** kwargs ) Base isort exception object from which all isort sourced exceptions should inherit View Source class ISortError ( Exception ): \"\"\"Base isort exception object from which all isort sourced exceptions should inherit\"\"\"","title":"ISortError"},{"location":"reference/isort/exceptions/#ancestors-in-mro_6","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#descendants_1","text":"isort.exceptions.InvalidSettingsPath isort.exceptions.ExistingSyntaxErrors isort.exceptions.IntroducedSyntaxErrors isort.exceptions.FileSkipped isort.exceptions.ProfileDoesNotExist isort.exceptions.FormattingPluginDoesNotExist isort.exceptions.LiteralParsingFailure isort.exceptions.LiteralSortTypeMismatch isort.exceptions.AssignmentsFormatMismatch isort.exceptions.UnsupportedSettings isort.exceptions.UnsupportedEncoding isort.exceptions.MissingSection","title":"Descendants"},{"location":"reference/isort/exceptions/#class-variables_6","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_6","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#introducedsyntaxerrors","text":"class IntroducedSyntaxErrors ( file_path : str ) Raised when isort has introduced a syntax error in the process of sorting imports View Source class IntroducedSyntaxErrors ( ISortError ): \"\"\"Raised when isort has introduced a syntax error in the process of sorting imports\"\"\" def __init__ ( self , file_path: str ): super (). __init__ ( f \"isort introduced syntax errors when attempting to sort the imports contained within \" f \"{file_path}.\" ) self . file_path = file_path","title":"IntroducedSyntaxErrors"},{"location":"reference/isort/exceptions/#ancestors-in-mro_7","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_7","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_7","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_7","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#invalidsettingspath","text":"class InvalidSettingsPath ( settings_path : str ) Raised when a settings path is provided that is neither a valid file or directory View Source class InvalidSettingsPath ( ISortError ): \"\"\"Raised when a settings path is provided that is neither a valid file or directory\"\"\" def __init__ ( self , settings_path: str ): super (). __init__ ( f \"isort was told to use the settings_path: {settings_path} as the base directory or \" \"file that represents the starting point of config file discovery, but it does not \" \"exist.\" ) self . settings_path = settings_path","title":"InvalidSettingsPath"},{"location":"reference/isort/exceptions/#ancestors-in-mro_8","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_8","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_8","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_8","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#literalparsingfailure","text":"class LiteralParsingFailure ( code : str , original_error : Exception ) Raised when one of isorts literal sorting comments is used but isort can't parse the the given data structure. View Source class LiteralParsingFailure ( ISortError ): \"\"\"Raised when one of isorts literal sorting comments is used but isort can't parse the the given data structure. \"\"\" def __init__ ( self , code: str , original_error: Exception ): super (). __init__ ( f \"isort failed to parse the given literal {code}. It's important to note \" \"that isort literal sorting only supports simple literals parsable by \" f \"ast.literal_eval which gave the exception of {original_error}.\" ) self . code = code self . original_error = original_error","title":"LiteralParsingFailure"},{"location":"reference/isort/exceptions/#ancestors-in-mro_9","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_9","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_9","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_9","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#literalsorttypemismatch","text":"class LiteralSortTypeMismatch ( kind : type , expected_kind : type ) Raised when an isort literal sorting comment is used, with a type that doesn't match the supplied data structure's type. View Source class LiteralSortTypeMismatch ( ISortError ): \"\"\"Raised when an isort literal sorting comment is used, with a type that doesn't match the supplied data structure's type. \"\"\" def __init__ ( self , kind: type , expected_kind: type ): super (). __init__ ( f \"isort was told to sort a literal of type {expected_kind} but was given \" f \"a literal of type {kind}.\" ) self . kind = kind self . expected_kind = expected_kind","title":"LiteralSortTypeMismatch"},{"location":"reference/isort/exceptions/#ancestors-in-mro_10","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_10","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_10","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_10","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#missingsection","text":"class MissingSection ( import_module : str , section : str ) Raised when isort encounters an import that matches a section that is not defined View Source class MissingSection ( ISortError ): \"\"\"Raised when isort encounters an import that matches a section that is not defined\"\"\" def __init__ ( self , import_module : str , section : str ): super () . __init__ ( f \"Found {import_module} import while parsing, but {section} was not included \" \"in the `sections` setting of your config. Please add it before continuing \\n \" \"See https://pycqa.github.io/isort/#custom-sections-and-ordering \" \"for more info.\" )","title":"MissingSection"},{"location":"reference/isort/exceptions/#ancestors-in-mro_11","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_11","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_11","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_11","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#profiledoesnotexist","text":"class ProfileDoesNotExist ( profile : str ) Raised when a profile is set by the user that doesn't exist View Source class ProfileDoesNotExist ( ISortError ): \"\"\"Raised when a profile is set by the user that doesn't exist\"\"\" def __init__ ( self , profile: str ): super (). __init__ ( f \"Specified profile of {profile} does not exist. \" f \"Available profiles: {','.join(profiles)}.\" ) self . profile = profile","title":"ProfileDoesNotExist"},{"location":"reference/isort/exceptions/#ancestors-in-mro_12","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_12","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_12","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_12","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#unsupportedencoding","text":"class UnsupportedEncoding ( filename : Union [ str , pathlib . Path ] ) Raised when isort encounters an encoding error while trying to read a file View Source class UnsupportedEncoding ( ISortError ): \"\"\"Raised when isort encounters an encoding error while trying to read a file\"\"\" def __init__ ( self , filename: Union [ str , Path ]): super (). __init__ ( f \"Unknown or unsupported encoding in {filename}\" ) self . filename = filename","title":"UnsupportedEncoding"},{"location":"reference/isort/exceptions/#ancestors-in-mro_13","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_13","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_13","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_13","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/exceptions/#unsupportedsettings","text":"class UnsupportedSettings ( unsupported_settings : Dict [ str , Dict [ str , str ]] ) Raised when settings are passed into isort (either from config, CLI, or runtime) that it doesn't support. View Source class UnsupportedSettings ( ISortError ) : \"\"\"Raised when settings are passed into isort (either from config, CLI, or runtime) that it doesn't support. \"\"\" @staticmethod def _format_option ( name : str , value : Any , source : str ) -> str : return f \"\\t- {name} = {value} (source: '{source}')\" def __init__ ( self , unsupported_settings : Dict [ str, Dict[str, str ] ] ) : errors = \"\\n\" . join ( self . _format_option ( name , ** option ) for name , option in unsupported_settings . items () ) super (). __init__ ( \"isort was provided settings that it doesn't support:\\n\\n\" f \"{errors}\\n\\n\" \"For a complete and up-to-date listing of supported settings see: \" \"https://pycqa.github.io/isort/docs/configuration/options/.\\n\" ) self . unsupported_settings = unsupported_settings","title":"UnsupportedSettings"},{"location":"reference/isort/exceptions/#ancestors-in-mro_14","text":"isort.exceptions.ISortError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/isort/exceptions/#class-variables_14","text":"args","title":"Class variables"},{"location":"reference/isort/exceptions/#methods_14","text":"","title":"Methods"},{"location":"reference/isort/exceptions/#with_traceback_14","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/isort/files/","text":"Module isort.files View Source import os from pathlib import Path from typing import Iterable , Iterator , List , Set from warnings import warn from isort.settings import Config def find ( paths : Iterable [ str ], config : Config , skipped : List [ str ], broken : List [ str ] ) -> Iterator [ str ]: \"\"\"Fines and provides an iterator for all Python source files defined in paths.\"\"\" visited_dirs : Set [ Path ] = set () for path in paths : if os . path . isdir ( path ): for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = config . follow_links ): base_path = Path ( dirpath ) for dirname in list ( dirnames ): full_path = base_path / dirname resolved_path = full_path . resolve () if config . is_skipped ( full_path ): skipped . append ( dirname ) dirnames . remove ( dirname ) else : if resolved_path in visited_dirs : # pragma: no cover if not config . quiet : warn ( f \"Likely recursive symlink detected to {resolved_path}\" ) dirnames . remove ( dirname ) visited_dirs . add ( resolved_path ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if config . is_supported_filetype ( filepath ): if config . is_skipped ( Path ( filepath )): skipped . append ( filename ) else : yield filepath elif not os . path . exists ( path ): broken . append ( path ) else : yield path Functions find def find ( paths : Iterable [ str ], config : isort . settings . Config , skipped : List [ str ], broken : List [ str ] ) -> Iterator [ str ] Fines and provides an iterator for all Python source files defined in paths. View Source def find ( paths : Iterable [ str ] , config : Config , skipped : List [ str ] , broken : List [ str ] ) -> Iterator [ str ] : \"\"\"Fines and provides an iterator for all Python source files defined in paths.\"\"\" visited_dirs : Set [ Path ] = set () for path in paths : if os . path . isdir ( path ) : for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = config . follow_links ) : base_path = Path ( dirpath ) for dirname in list ( dirnames ) : full_path = base_path / dirname resolved_path = full_path . resolve () if config . is_skipped ( full_path ) : skipped . append ( dirname ) dirnames . remove ( dirname ) else : if resolved_path in visited_dirs : # pragma : no cover if not config . quiet : warn ( f \"Likely recursive symlink detected to {resolved_path}\" ) dirnames . remove ( dirname ) visited_dirs . add ( resolved_path ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if config . is_supported_filetype ( filepath ) : if config . is_skipped ( Path ( filepath )) : skipped . append ( filename ) else : yield filepath elif not os . path . exists ( path ) : broken . append ( path ) else : yield path","title":"Files"},{"location":"reference/isort/files/#module-isortfiles","text":"View Source import os from pathlib import Path from typing import Iterable , Iterator , List , Set from warnings import warn from isort.settings import Config def find ( paths : Iterable [ str ], config : Config , skipped : List [ str ], broken : List [ str ] ) -> Iterator [ str ]: \"\"\"Fines and provides an iterator for all Python source files defined in paths.\"\"\" visited_dirs : Set [ Path ] = set () for path in paths : if os . path . isdir ( path ): for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = config . follow_links ): base_path = Path ( dirpath ) for dirname in list ( dirnames ): full_path = base_path / dirname resolved_path = full_path . resolve () if config . is_skipped ( full_path ): skipped . append ( dirname ) dirnames . remove ( dirname ) else : if resolved_path in visited_dirs : # pragma: no cover if not config . quiet : warn ( f \"Likely recursive symlink detected to {resolved_path}\" ) dirnames . remove ( dirname ) visited_dirs . add ( resolved_path ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if config . is_supported_filetype ( filepath ): if config . is_skipped ( Path ( filepath )): skipped . append ( filename ) else : yield filepath elif not os . path . exists ( path ): broken . append ( path ) else : yield path","title":"Module isort.files"},{"location":"reference/isort/files/#functions","text":"","title":"Functions"},{"location":"reference/isort/files/#find","text":"def find ( paths : Iterable [ str ], config : isort . settings . Config , skipped : List [ str ], broken : List [ str ] ) -> Iterator [ str ] Fines and provides an iterator for all Python source files defined in paths. View Source def find ( paths : Iterable [ str ] , config : Config , skipped : List [ str ] , broken : List [ str ] ) -> Iterator [ str ] : \"\"\"Fines and provides an iterator for all Python source files defined in paths.\"\"\" visited_dirs : Set [ Path ] = set () for path in paths : if os . path . isdir ( path ) : for dirpath , dirnames , filenames in os . walk ( path , topdown = True , followlinks = config . follow_links ) : base_path = Path ( dirpath ) for dirname in list ( dirnames ) : full_path = base_path / dirname resolved_path = full_path . resolve () if config . is_skipped ( full_path ) : skipped . append ( dirname ) dirnames . remove ( dirname ) else : if resolved_path in visited_dirs : # pragma : no cover if not config . quiet : warn ( f \"Likely recursive symlink detected to {resolved_path}\" ) dirnames . remove ( dirname ) visited_dirs . add ( resolved_path ) for filename in filenames : filepath = os . path . join ( dirpath , filename ) if config . is_supported_filetype ( filepath ) : if config . is_skipped ( Path ( filepath )) : skipped . append ( filename ) else : yield filepath elif not os . path . exists ( path ) : broken . append ( path ) else : yield path","title":"find"},{"location":"reference/isort/format/","text":"Module isort.format View Source import re import sys from datetime import datetime from difflib import unified_diff from pathlib import Path from typing import Optional , TextIO try : import colorama except ImportError : colorama_unavailable = True else : colorama_unavailable = False colorama . init () ADDED_LINE_PATTERN = re . compile ( r \"\\+[^+]\" ) REMOVED_LINE_PATTERN = re . compile ( r \"-[^-]\" ) def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ], output : Optional [ TextIO ] = None , color_output : bool = False , ): \"\"\"Shows a unified_diff for the provided input and output against the provided file path. - **file_input**: A string that represents the contents of a file before changes. - **file_output**: A string that represents the contents of a file after changes. - **file_path**: A Path object that represents the file path of the file being changed. - **output**: A stream to output the diff to. If non is provided uses sys.stdout. - **color_output**: Use color in output if True. \"\"\" printer = create_terminal_printer ( color_output , output ) file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat () . st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : printer . diff_line ( line ) def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True def remove_whitespace ( content : str , line_separator : str = \" \\n \" ) -> str : content = content . replace ( line_separator , \"\" ) . replace ( \" \" , \"\" ) . replace ( \" \\x0c \" , \"\" ) return content class BasicPrinter : ERROR = \"ERROR\" SUCCESS = \"SUCCESS\" def __init__ ( self , output : Optional [ TextIO ] = None ): self . output = output or sys . stdout def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output ) def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr ) def diff_line ( self , line : str ) -> None : self . output . write ( line ) class ColoramaPrinter ( BasicPrinter ): def __init__ ( self , output : Optional [ TextIO ] = None ): super () . __init__ ( output = output ) # Note: this constants are instance variables instead ofs class variables # because they refer to colorama which might not be installed. self . ERROR = self . style_text ( \"ERROR\" , colorama . Fore . RED ) self . SUCCESS = self . style_text ( \"SUCCESS\" , colorama . Fore . GREEN ) self . ADDED_LINE = colorama . Fore . GREEN self . REMOVED_LINE = colorama . Fore . RED @staticmethod def style_text ( text : str , style : Optional [ str ] = None ) -> str : if style is None : return text return style + text + colorama . Style . RESET_ALL def diff_line ( self , line : str ) -> None : style = None if re . match ( ADDED_LINE_PATTERN , line ): style = self . ADDED_LINE elif re . match ( REMOVED_LINE_PATTERN , line ): style = self . REMOVED_LINE self . output . write ( self . style_text ( line , style )) def create_terminal_printer ( color : bool , output : Optional [ TextIO ] = None ): if color and colorama_unavailable : no_colorama_message = ( \" \\n \" \"Sorry, but to use --color (color_output) the colorama python package is required. \\n\\n \" \"Reference: https://pypi.org/project/colorama/ \\n\\n \" \"You can either install it separately on your system or as the colors extra \" \"for isort. Ex: \\n\\n \" \"$ pip install isort[colors] \\n \" ) print ( no_colorama_message , file = sys . stderr ) sys . exit ( 1 ) return ColoramaPrinter ( output ) if color else BasicPrinter ( output ) Variables ADDED_LINE_PATTERN REMOVED_LINE_PATTERN colorama_unavailable Functions ask_whether_to_apply_changes_to_file def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool View Source def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True create_terminal_printer def create_terminal_printer ( color : bool , output : Union [ TextIO , NoneType ] = None ) View Source def create_terminal_printer ( color : bool , output : Optional [ TextIO ] = None ) : if color and colorama_unavailable : no_colorama_message = ( \"\\n\" \"Sorry, but to use --color (color_output) the colorama python package is required.\\n\\n\" \"Reference: https://pypi.org/project/colorama/\\n\\n\" \"You can either install it separately on your system or as the colors extra \" \"for isort. Ex: \\n\\n\" \"$ pip install isort[colors]\\n\" ) print ( no_colorama_message , file = sys . stderr ) sys . exit ( 1 ) return ColoramaPrinter ( output ) if color else BasicPrinter ( output ) format_natural def format_natural ( import_line : str ) -> str View Source def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line format_simplified def format_simplified ( import_line : str ) -> str View Source def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line remove_whitespace def remove_whitespace ( content : str , line_separator : str = ' \\n ' ) -> str View Source def remove_whitespace ( content : str , line_separator : str = \"\\n\" ) -> str : content = content . replace ( line_separator , \"\" ). replace ( \" \" , \"\" ). replace ( \"\\x0c\" , \"\" ) return content show_unified_diff def show_unified_diff ( * , file_input : str , file_output : str , file_path : Union [ pathlib . Path , NoneType ], output : Union [ TextIO , NoneType ] = None , color_output : bool = False ) Shows a unified_diff for the provided input and output against the provided file path. file_input : A string that represents the contents of a file before changes. file_output : A string that represents the contents of a file after changes. file_path : A Path object that represents the file path of the file being changed. output : A stream to output the diff to. If non is provided uses sys.stdout. color_output : Use color in output if True. View Source def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ] , output : Optional [ TextIO ] = None , color_output : bool = False , ) : \"\"\"Shows a unified_diff for the provided input and output against the provided file path. - **file_input**: A string that represents the contents of a file before changes. - **file_output**: A string that represents the contents of a file after changes. - **file_path**: A Path object that represents the file path of the file being changed. - **output**: A stream to output the diff to. If non is provided uses sys.stdout. - **color_output**: Use color in output if True. \"\"\" printer = create_terminal_printer ( color_output , output ) file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat (). st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : printer . diff_line ( line ) Classes BasicPrinter class BasicPrinter ( output : Union [ TextIO , NoneType ] = None ) View Source class BasicPrinter : ERROR = \"ERROR\" SUCCESS = \"SUCCESS\" def __init__ ( self , output : Optional [ TextIO ] = None ) : self . output = output or sys . stdout def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output ) def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr ) def diff_line ( self , line : str ) -> None : self . output . write ( line ) Descendants isort.format.ColoramaPrinter Class variables ERROR SUCCESS Methods diff_line def diff_line ( self , line : str ) -> None View Source def diff_line ( self , line : str ) -> None : self . output . write ( line ) error def error ( self , message : str ) -> None View Source def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr ) success def success ( self , message : str ) -> None View Source def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output ) ColoramaPrinter class ColoramaPrinter ( output : Union [ TextIO , NoneType ] = None ) View Source class ColoramaPrinter ( BasicPrinter ) : def __init__ ( self , output : Optional [ TextIO ] = None ) : super (). __init__ ( output = output ) # Note : this constants are instance variables instead ofs class variables # because they refer to colorama which might not be installed . self . ERROR = self . style_text ( \"ERROR\" , colorama . Fore . RED ) self . SUCCESS = self . style_text ( \"SUCCESS\" , colorama . Fore . GREEN ) self . ADDED_LINE = colorama . Fore . GREEN self . REMOVED_LINE = colorama . Fore . RED @staticmethod def style_text ( text : str , style : Optional [ str ] = None ) -> str : if style is None : return text return style + text + colorama . Style . RESET_ALL def diff_line ( self , line : str ) -> None : style = None if re . match ( ADDED_LINE_PATTERN , line ) : style = self . ADDED_LINE elif re . match ( REMOVED_LINE_PATTERN , line ) : style = self . REMOVED_LINE self . output . write ( self . style_text ( line , style )) Ancestors (in MRO) isort.format.BasicPrinter Class variables ERROR SUCCESS Static methods style_text def style_text ( text : str , style : Union [ str , NoneType ] = None ) -> str View Source @staticmethod def style_text ( text : str , style : Optional [ str ] = None ) -> str : if style is None : return text return style + text + colorama . Style . RESET_ALL Methods diff_line def diff_line ( self , line : str ) -> None View Source def diff_line ( self , line : str ) -> None : style = None if re . match ( ADDED_LINE_PATTERN , line ): style = self . ADDED_LINE elif re . match ( REMOVED_LINE_PATTERN , line ): style = self . REMOVED_LINE self . output . write ( self . style_text ( line , style )) error def error ( self , message : str ) -> None View Source def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr ) success def success ( self , message : str ) -> None View Source def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output )","title":"Format"},{"location":"reference/isort/format/#module-isortformat","text":"View Source import re import sys from datetime import datetime from difflib import unified_diff from pathlib import Path from typing import Optional , TextIO try : import colorama except ImportError : colorama_unavailable = True else : colorama_unavailable = False colorama . init () ADDED_LINE_PATTERN = re . compile ( r \"\\+[^+]\" ) REMOVED_LINE_PATTERN = re . compile ( r \"-[^-]\" ) def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ], output : Optional [ TextIO ] = None , color_output : bool = False , ): \"\"\"Shows a unified_diff for the provided input and output against the provided file path. - **file_input**: A string that represents the contents of a file before changes. - **file_output**: A string that represents the contents of a file after changes. - **file_path**: A Path object that represents the file path of the file being changed. - **output**: A stream to output the diff to. If non is provided uses sys.stdout. - **color_output**: Use color in output if True. \"\"\" printer = create_terminal_printer ( color_output , output ) file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat () . st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : printer . diff_line ( line ) def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True def remove_whitespace ( content : str , line_separator : str = \" \\n \" ) -> str : content = content . replace ( line_separator , \"\" ) . replace ( \" \" , \"\" ) . replace ( \" \\x0c \" , \"\" ) return content class BasicPrinter : ERROR = \"ERROR\" SUCCESS = \"SUCCESS\" def __init__ ( self , output : Optional [ TextIO ] = None ): self . output = output or sys . stdout def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output ) def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr ) def diff_line ( self , line : str ) -> None : self . output . write ( line ) class ColoramaPrinter ( BasicPrinter ): def __init__ ( self , output : Optional [ TextIO ] = None ): super () . __init__ ( output = output ) # Note: this constants are instance variables instead ofs class variables # because they refer to colorama which might not be installed. self . ERROR = self . style_text ( \"ERROR\" , colorama . Fore . RED ) self . SUCCESS = self . style_text ( \"SUCCESS\" , colorama . Fore . GREEN ) self . ADDED_LINE = colorama . Fore . GREEN self . REMOVED_LINE = colorama . Fore . RED @staticmethod def style_text ( text : str , style : Optional [ str ] = None ) -> str : if style is None : return text return style + text + colorama . Style . RESET_ALL def diff_line ( self , line : str ) -> None : style = None if re . match ( ADDED_LINE_PATTERN , line ): style = self . ADDED_LINE elif re . match ( REMOVED_LINE_PATTERN , line ): style = self . REMOVED_LINE self . output . write ( self . style_text ( line , style )) def create_terminal_printer ( color : bool , output : Optional [ TextIO ] = None ): if color and colorama_unavailable : no_colorama_message = ( \" \\n \" \"Sorry, but to use --color (color_output) the colorama python package is required. \\n\\n \" \"Reference: https://pypi.org/project/colorama/ \\n\\n \" \"You can either install it separately on your system or as the colors extra \" \"for isort. Ex: \\n\\n \" \"$ pip install isort[colors] \\n \" ) print ( no_colorama_message , file = sys . stderr ) sys . exit ( 1 ) return ColoramaPrinter ( output ) if color else BasicPrinter ( output )","title":"Module isort.format"},{"location":"reference/isort/format/#variables","text":"ADDED_LINE_PATTERN REMOVED_LINE_PATTERN colorama_unavailable","title":"Variables"},{"location":"reference/isort/format/#functions","text":"","title":"Functions"},{"location":"reference/isort/format/#ask_whether_to_apply_changes_to_file","text":"def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool View Source def ask_whether_to_apply_changes_to_file ( file_path : str ) -> bool : answer = None while answer not in ( \"yes\" , \"y\" , \"no\" , \"n\" , \"quit\" , \"q\" ): answer = input ( f \"Apply suggested changes to '{file_path}' [y/n/q]? \" ) # nosec answer = answer . lower () if answer in ( \"no\" , \"n\" ): return False if answer in ( \"quit\" , \"q\" ): sys . exit ( 1 ) return True","title":"ask_whether_to_apply_changes_to_file"},{"location":"reference/isort/format/#create_terminal_printer","text":"def create_terminal_printer ( color : bool , output : Union [ TextIO , NoneType ] = None ) View Source def create_terminal_printer ( color : bool , output : Optional [ TextIO ] = None ) : if color and colorama_unavailable : no_colorama_message = ( \"\\n\" \"Sorry, but to use --color (color_output) the colorama python package is required.\\n\\n\" \"Reference: https://pypi.org/project/colorama/\\n\\n\" \"You can either install it separately on your system or as the colors extra \" \"for isort. Ex: \\n\\n\" \"$ pip install isort[colors]\\n\" ) print ( no_colorama_message , file = sys . stderr ) sys . exit ( 1 ) return ColoramaPrinter ( output ) if color else BasicPrinter ( output )","title":"create_terminal_printer"},{"location":"reference/isort/format/#format_natural","text":"def format_natural ( import_line : str ) -> str View Source def format_natural ( import_line : str ) -> str : import_line = import_line . strip () if not import_line . startswith ( \"from \" ) and not import_line . startswith ( \"import \" ): if \".\" not in import_line : return f \"import {import_line}\" parts = import_line . split ( \".\" ) end = parts . pop ( - 1 ) return f \"from {'.'.join(parts)} import {end}\" return import_line","title":"format_natural"},{"location":"reference/isort/format/#format_simplified","text":"def format_simplified ( import_line : str ) -> str View Source def format_simplified ( import_line : str ) -> str : import_line = import_line . strip () if import_line . startswith ( \"from \" ): import_line = import_line . replace ( \"from \" , \"\" ) import_line = import_line . replace ( \" import \" , \".\" ) elif import_line . startswith ( \"import \" ): import_line = import_line . replace ( \"import \" , \"\" ) return import_line","title":"format_simplified"},{"location":"reference/isort/format/#remove_whitespace","text":"def remove_whitespace ( content : str , line_separator : str = ' \\n ' ) -> str View Source def remove_whitespace ( content : str , line_separator : str = \"\\n\" ) -> str : content = content . replace ( line_separator , \"\" ). replace ( \" \" , \"\" ). replace ( \"\\x0c\" , \"\" ) return content","title":"remove_whitespace"},{"location":"reference/isort/format/#show_unified_diff","text":"def show_unified_diff ( * , file_input : str , file_output : str , file_path : Union [ pathlib . Path , NoneType ], output : Union [ TextIO , NoneType ] = None , color_output : bool = False ) Shows a unified_diff for the provided input and output against the provided file path. file_input : A string that represents the contents of a file before changes. file_output : A string that represents the contents of a file after changes. file_path : A Path object that represents the file path of the file being changed. output : A stream to output the diff to. If non is provided uses sys.stdout. color_output : Use color in output if True. View Source def show_unified_diff ( * , file_input : str , file_output : str , file_path : Optional [ Path ] , output : Optional [ TextIO ] = None , color_output : bool = False , ) : \"\"\"Shows a unified_diff for the provided input and output against the provided file path. - **file_input**: A string that represents the contents of a file before changes. - **file_output**: A string that represents the contents of a file after changes. - **file_path**: A Path object that represents the file path of the file being changed. - **output**: A stream to output the diff to. If non is provided uses sys.stdout. - **color_output**: Use color in output if True. \"\"\" printer = create_terminal_printer ( color_output , output ) file_name = \"\" if file_path is None else str ( file_path ) file_mtime = str ( datetime . now () if file_path is None else datetime . fromtimestamp ( file_path . stat (). st_mtime ) ) unified_diff_lines = unified_diff ( file_input . splitlines ( keepends = True ), file_output . splitlines ( keepends = True ), fromfile = file_name + \":before\" , tofile = file_name + \":after\" , fromfiledate = file_mtime , tofiledate = str ( datetime . now ()), ) for line in unified_diff_lines : printer . diff_line ( line )","title":"show_unified_diff"},{"location":"reference/isort/format/#classes","text":"","title":"Classes"},{"location":"reference/isort/format/#basicprinter","text":"class BasicPrinter ( output : Union [ TextIO , NoneType ] = None ) View Source class BasicPrinter : ERROR = \"ERROR\" SUCCESS = \"SUCCESS\" def __init__ ( self , output : Optional [ TextIO ] = None ) : self . output = output or sys . stdout def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output ) def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr ) def diff_line ( self , line : str ) -> None : self . output . write ( line )","title":"BasicPrinter"},{"location":"reference/isort/format/#descendants","text":"isort.format.ColoramaPrinter","title":"Descendants"},{"location":"reference/isort/format/#class-variables","text":"ERROR SUCCESS","title":"Class variables"},{"location":"reference/isort/format/#methods","text":"","title":"Methods"},{"location":"reference/isort/format/#diff_line","text":"def diff_line ( self , line : str ) -> None View Source def diff_line ( self , line : str ) -> None : self . output . write ( line )","title":"diff_line"},{"location":"reference/isort/format/#error","text":"def error ( self , message : str ) -> None View Source def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr )","title":"error"},{"location":"reference/isort/format/#success","text":"def success ( self , message : str ) -> None View Source def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output )","title":"success"},{"location":"reference/isort/format/#coloramaprinter","text":"class ColoramaPrinter ( output : Union [ TextIO , NoneType ] = None ) View Source class ColoramaPrinter ( BasicPrinter ) : def __init__ ( self , output : Optional [ TextIO ] = None ) : super (). __init__ ( output = output ) # Note : this constants are instance variables instead ofs class variables # because they refer to colorama which might not be installed . self . ERROR = self . style_text ( \"ERROR\" , colorama . Fore . RED ) self . SUCCESS = self . style_text ( \"SUCCESS\" , colorama . Fore . GREEN ) self . ADDED_LINE = colorama . Fore . GREEN self . REMOVED_LINE = colorama . Fore . RED @staticmethod def style_text ( text : str , style : Optional [ str ] = None ) -> str : if style is None : return text return style + text + colorama . Style . RESET_ALL def diff_line ( self , line : str ) -> None : style = None if re . match ( ADDED_LINE_PATTERN , line ) : style = self . ADDED_LINE elif re . match ( REMOVED_LINE_PATTERN , line ) : style = self . REMOVED_LINE self . output . write ( self . style_text ( line , style ))","title":"ColoramaPrinter"},{"location":"reference/isort/format/#ancestors-in-mro","text":"isort.format.BasicPrinter","title":"Ancestors (in MRO)"},{"location":"reference/isort/format/#class-variables_1","text":"ERROR SUCCESS","title":"Class variables"},{"location":"reference/isort/format/#static-methods","text":"","title":"Static methods"},{"location":"reference/isort/format/#style_text","text":"def style_text ( text : str , style : Union [ str , NoneType ] = None ) -> str View Source @staticmethod def style_text ( text : str , style : Optional [ str ] = None ) -> str : if style is None : return text return style + text + colorama . Style . RESET_ALL","title":"style_text"},{"location":"reference/isort/format/#methods_1","text":"","title":"Methods"},{"location":"reference/isort/format/#diff_line_1","text":"def diff_line ( self , line : str ) -> None View Source def diff_line ( self , line : str ) -> None : style = None if re . match ( ADDED_LINE_PATTERN , line ): style = self . ADDED_LINE elif re . match ( REMOVED_LINE_PATTERN , line ): style = self . REMOVED_LINE self . output . write ( self . style_text ( line , style ))","title":"diff_line"},{"location":"reference/isort/format/#error_1","text":"def error ( self , message : str ) -> None View Source def error ( self , message : str ) -> None : print ( f \"{self.ERROR}: {message}\" , file = sys . stderr )","title":"error"},{"location":"reference/isort/format/#success_1","text":"def success ( self , message : str ) -> None View Source def success ( self , message : str ) -> None : print ( f \"{self.SUCCESS}: {message}\" , file = self . output )","title":"success"},{"location":"reference/isort/hooks/","text":"Module isort.hooks Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) View Source \"\"\"Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) \"\"\" import os import subprocess # nosec - Needed for hook from pathlib import Path from typing import List from isort import Config , api , exceptions def get_output ( command : List [ str ]) -> str : \"\"\"Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode () def get_lines ( command : List [ str ]) -> List [ str ]: \"\"\"Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line . strip () for line in stdout . splitlines ()] def git_hook ( strict : bool = False , modify : bool = False , lazy : bool = False , settings_file : str = \"\" ) -> int : \"\"\"Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :param bool lazy - if True, also check/fix unstaged files. This is useful if you frequently use ``git commit -a`` for example. If False, ony check/fix the staged files for isort errors. :param str settings_file - A path to a file to be used as the configuration file for this run. When settings_file is the empty string, the configuration file will be searched starting at the directory containing the first staged file, if any, and going upward in the directory structure. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB\" , \"HEAD\" ] if lazy : diff_cmd . remove ( \"--cached\" ) files_modified = get_lines ( diff_cmd ) if not files_modified : return 0 errors = 0 config = Config ( settings_file = settings_file , settings_path = os . path . dirname ( os . path . abspath ( files_modified [ 0 ])), ) for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , f \":{filename}\" ] staged_contents = get_output ( staged_cmd ) try : if not api . check_code_string ( staged_contents , file_path = Path ( filename ), config = config ): errors += 1 if modify : api . sort_file ( filename , config = config ) except exceptions . FileSkipped : # pragma: no cover pass return errors if strict else 0 Functions get_lines def get_lines ( command : List [ str ] ) -> List [ str ] Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command View Source def get_lines ( command : List [ str ] ) -> List [ str ] : \"\"\"Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line.strip() for line in stdout.splitlines() ] get_output def get_output ( command : List [ str ] ) -> str Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command View Source def get_output ( command : List [ str ] ) -> str : \"\"\"Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode () git_hook def git_hook ( strict : bool = False , modify : bool = False , lazy : bool = False , settings_file : str = '' ) -> int Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :param bool lazy - if True, also check/fix unstaged files. This is useful if you frequently use git commit -a for example. If False, ony check/fix the staged files for isort errors. :param str settings_file - A path to a file to be used as the configuration file for this run. When settings_file is the empty string, the configuration file will be searched starting at the directory containing the first staged file, if any, and going upward in the directory structure. :return number of errors if in strict mode, 0 otherwise. View Source def git_hook ( strict : bool = False , modify : bool = False , lazy : bool = False , settings_file : str = \"\" ) -> int : \"\"\"Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :param bool lazy - if True, also check/fix unstaged files. This is useful if you frequently use ``git commit -a`` for example. If False, ony check/fix the staged files for isort errors. :param str settings_file - A path to a file to be used as the configuration file for this run. When settings_file is the empty string, the configuration file will be searched starting at the directory containing the first staged file, if any, and going upward in the directory structure. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB\" , \"HEAD\" ] if lazy : diff_cmd . remove ( \"--cached\" ) files_modified = get_lines ( diff_cmd ) if not files_modified : return 0 errors = 0 config = Config ( settings_file = settings_file , settings_path = os . path . dirname ( os . path . abspath ( files_modified [ 0 ])), ) for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , f \":{filename}\" ] staged_contents = get_output ( staged_cmd ) try : if not api . check_code_string ( staged_contents , file_path = Path ( filename ), config = config ): errors += 1 if modify : api . sort_file ( filename , config = config ) except exceptions . FileSkipped : # pragma : no cover pass return errors if strict else 0","title":"Hooks"},{"location":"reference/isort/hooks/#module-isorthooks","text":"Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) View Source \"\"\"Defines a git hook to allow pre-commit warnings and errors about import order. usage: exit_code = git_hook(strict=True|False, modify=True|False) \"\"\" import os import subprocess # nosec - Needed for hook from pathlib import Path from typing import List from isort import Config , api , exceptions def get_output ( command : List [ str ]) -> str : \"\"\"Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode () def get_lines ( command : List [ str ]) -> List [ str ]: \"\"\"Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line . strip () for line in stdout . splitlines ()] def git_hook ( strict : bool = False , modify : bool = False , lazy : bool = False , settings_file : str = \"\" ) -> int : \"\"\"Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :param bool lazy - if True, also check/fix unstaged files. This is useful if you frequently use ``git commit -a`` for example. If False, ony check/fix the staged files for isort errors. :param str settings_file - A path to a file to be used as the configuration file for this run. When settings_file is the empty string, the configuration file will be searched starting at the directory containing the first staged file, if any, and going upward in the directory structure. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB\" , \"HEAD\" ] if lazy : diff_cmd . remove ( \"--cached\" ) files_modified = get_lines ( diff_cmd ) if not files_modified : return 0 errors = 0 config = Config ( settings_file = settings_file , settings_path = os . path . dirname ( os . path . abspath ( files_modified [ 0 ])), ) for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , f \":{filename}\" ] staged_contents = get_output ( staged_cmd ) try : if not api . check_code_string ( staged_contents , file_path = Path ( filename ), config = config ): errors += 1 if modify : api . sort_file ( filename , config = config ) except exceptions . FileSkipped : # pragma: no cover pass return errors if strict else 0","title":"Module isort.hooks"},{"location":"reference/isort/hooks/#functions","text":"","title":"Functions"},{"location":"reference/isort/hooks/#get_lines","text":"def get_lines ( command : List [ str ] ) -> List [ str ] Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command View Source def get_lines ( command : List [ str ] ) -> List [ str ] : \"\"\"Run a command and return lines of output :param str command: the command to run :returns: list of whitespace-stripped lines output by command \"\"\" stdout = get_output ( command ) return [ line.strip() for line in stdout.splitlines() ]","title":"get_lines"},{"location":"reference/isort/hooks/#get_output","text":"def get_output ( command : List [ str ] ) -> str Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command View Source def get_output ( command : List [ str ] ) -> str : \"\"\"Run a command and return raw output :param str command: the command to run :returns: the stdout output of the command \"\"\" result = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) # nosec - trusted input return result . stdout . decode ()","title":"get_output"},{"location":"reference/isort/hooks/#git_hook","text":"def git_hook ( strict : bool = False , modify : bool = False , lazy : bool = False , settings_file : str = '' ) -> int Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :param bool lazy - if True, also check/fix unstaged files. This is useful if you frequently use git commit -a for example. If False, ony check/fix the staged files for isort errors. :param str settings_file - A path to a file to be used as the configuration file for this run. When settings_file is the empty string, the configuration file will be searched starting at the directory containing the first staged file, if any, and going upward in the directory structure. :return number of errors if in strict mode, 0 otherwise. View Source def git_hook ( strict : bool = False , modify : bool = False , lazy : bool = False , settings_file : str = \"\" ) -> int : \"\"\"Git pre-commit hook to check staged files for isort errors :param bool strict - if True, return number of errors on exit, causing the hook to fail. If False, return zero so it will just act as a warning. :param bool modify - if True, fix the sources if they are not sorted properly. If False, only report result without modifying anything. :param bool lazy - if True, also check/fix unstaged files. This is useful if you frequently use ``git commit -a`` for example. If False, ony check/fix the staged files for isort errors. :param str settings_file - A path to a file to be used as the configuration file for this run. When settings_file is the empty string, the configuration file will be searched starting at the directory containing the first staged file, if any, and going upward in the directory structure. :return number of errors if in strict mode, 0 otherwise. \"\"\" # Get list of files modified and staged diff_cmd = [ \"git\" , \"diff-index\" , \"--cached\" , \"--name-only\" , \"--diff-filter=ACMRTUXB\" , \"HEAD\" ] if lazy : diff_cmd . remove ( \"--cached\" ) files_modified = get_lines ( diff_cmd ) if not files_modified : return 0 errors = 0 config = Config ( settings_file = settings_file , settings_path = os . path . dirname ( os . path . abspath ( files_modified [ 0 ])), ) for filename in files_modified : if filename . endswith ( \".py\" ): # Get the staged contents of the file staged_cmd = [ \"git\" , \"show\" , f \":{filename}\" ] staged_contents = get_output ( staged_cmd ) try : if not api . check_code_string ( staged_contents , file_path = Path ( filename ), config = config ): errors += 1 if modify : api . sort_file ( filename , config = config ) except exceptions . FileSkipped : # pragma : no cover pass return errors if strict else 0","title":"git_hook"},{"location":"reference/isort/identify/","text":"Module isort.identify Fast stream based import identification. Eventually this will likely replace parse.py View Source \"\"\"Fast stream based import identification. Eventually this will likely replace parse.py \"\"\" from functools import partial from pathlib import Path from typing import Iterator , NamedTuple , Optional , TextIO , Tuple from isort.parse import _normalize_line , _strip_syntax , skip_line from .comments import parse as parse_comments from .settings import DEFAULT_CONFIG , Config STATEMENT_DECLARATIONS : Tuple [ str , ... ] = ( \"def \" , \"cdef \" , \"cpdef \" , \"class \" , \"@\" , \"async def\" ) class Import ( NamedTuple ): line_number : int indented : bool module : str attribute : Optional [ str ] = None alias : Optional [ str ] = None cimport : bool = False file_path : Optional [ Path ] = None def statement ( self ) -> str : import_cmd = \"cimport\" if self . cimport else \"import\" if self . attribute : import_string = f \"from {self.module} {import_cmd} {self.attribute}\" else : import_string = f \"{import_cmd} {self.module}\" if self . alias : import_string += f \" as {self.alias}\" return import_string def __str__ ( self ): return ( f \"{self.file_path or ''}:{self.line_number} \" f \"{'indented ' if self.indented else ''}{self.statement()}\" ) def imports ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , top_only : bool = False , ) -> Iterator [ Import ]: \"\"\"Parses a python file taking out and categorizing imports.\"\"\" in_quote = \"\" indexed_input = enumerate ( input_stream ) for index , raw_line in indexed_input : ( skipping_line , in_quote ) = skip_line ( raw_line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if top_only and not in_quote and raw_line . startswith ( STATEMENT_DECLARATIONS ): break if skipping_line : continue stripped_line = raw_line . strip () . split ( \"#\" )[ 0 ] if stripped_line . startswith ( \"raise\" ) or stripped_line . startswith ( \"yield\" ): if stripped_line == \"yield\" : while not stripped_line or stripped_line == \"yield\" : try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip () . split ( \"#\" )[ 0 ] while stripped_line . endswith ( \" \\\\ \" ): try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip () . split ( \"#\" )[ 0 ] continue # pragma: no cover line , * end_of_line_comment = raw_line . split ( \"#\" , 1 ) statements = [ line . strip () for line in line . split ( \";\" )] if end_of_line_comment : statements [ - 1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , _raw_line = _normalize_line ( statement ) if line . startswith (( \"import \" , \"cimport \" )): type_of_import = \"straight\" elif line . startswith ( \"from \" ): type_of_import = \"from\" else : continue # pragma: no cover import_string , _ = parse_comments ( line ) normalized_import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) cimports : bool = ( \" cimport \" in normalized_import_string or normalized_import_string . startswith ( \"cimport\" ) ) identified_import = partial ( Import , index + 1 , # line numbers use 1 based indexing raw_line . startswith (( \" \" , \" \\t \" )), cimport = cimports , file_path = file_path , ) if \"(\" in line . split ( \"#\" , 1 )[ 0 ]: while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ): try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \" \\n \" + line else : while line . strip () . endswith ( \" \\\\ \" ): try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) # Still need to check for parentheses after an escaped line if \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ]: import_string += \" \\n \" + line while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ): try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \" \\n \" + line else : if import_string . strip () . endswith ( ( \" import\" , \" cimport\" ) ) or line . strip () . startswith (( \"import \" , \"cimport \" )): import_string += \" \\n \" + line else : import_string = ( import_string . rstrip () . rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () ) if type_of_import == \"from\" : import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) parts = import_string . split ( \" cimport \" if cimports else \" import \" ) from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ) . join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 :])] + parts [ 1 :] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ) . replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ) . split () ] direct_imports = just_imports [ 1 :] top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ): while \"as\" in just_imports : attribute = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : attribute = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + attribute alias = just_imports [ as_index + 1 ] direct_imports . remove ( attribute ) direct_imports . remove ( alias ) direct_imports . remove ( \"as\" ) just_imports [ 1 :] = direct_imports if attribute == alias and config . remove_redundant_aliases : yield identified_import ( top_level_module , attribute ) else : yield identified_import ( top_level_module , attribute , alias = alias ) else : module = just_imports [ as_index - 1 ] alias = just_imports [ as_index + 1 ] just_imports . remove ( alias ) just_imports . remove ( \"as\" ) just_imports . remove ( module ) if module == alias and config . remove_redundant_aliases : yield identified_import ( module ) else : yield identified_import ( module , alias = alias ) if just_imports : if type_of_import == \"from\" : module = just_imports . pop ( 0 ) for attribute in just_imports : yield identified_import ( module , attribute ) else : for module in just_imports : yield identified_import ( module ) Variables STATEMENT_DECLARATIONS Functions imports def imports ( input_stream : < class ' TextIO '>, config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , top_only : bool = False ) -> Iterator [ isort . identify . Import ] Parses a python file taking out and categorizing imports. View Source def imports ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , top_only : bool = False , ) -> Iterator [ Import ] : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" in_quote = \"\" indexed_input = enumerate ( input_stream ) for index , raw_line in indexed_input : ( skipping_line , in_quote ) = skip_line ( raw_line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if top_only and not in_quote and raw_line . startswith ( STATEMENT_DECLARATIONS ) : break if skipping_line : continue stripped_line = raw_line . strip (). split ( \"#\" ) [ 0 ] if stripped_line . startswith ( \"raise\" ) or stripped_line . startswith ( \"yield\" ) : if stripped_line == \"yield\" : while not stripped_line or stripped_line == \"yield\" : try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip (). split ( \"#\" ) [ 0 ] while stripped_line . endswith ( \"\\\\\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip (). split ( \"#\" ) [ 0 ] continue # pragma : no cover line , * end_of_line_comment = raw_line . split ( \"#\" , 1 ) statements = [ line.strip() for line in line.split(\";\") ] if end_of_line_comment : statements [ -1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , _raw_line = _normalize_line ( statement ) if line . startswith (( \"import \" , \"cimport \" )) : type_of_import = \"straight\" elif line . startswith ( \"from \" ) : type_of_import = \"from\" else : continue # pragma : no cover import_string , _ = parse_comments ( line ) normalized_import_string = ( import_string . replace ( \"import(\" , \"import (\" ). replace ( \"\\\\\" , \" \" ). replace ( \"\\n\" , \" \" ) ) cimports : bool = ( \" cimport \" in normalized_import_string or normalized_import_string . startswith ( \"cimport\" ) ) identified_import = partial ( Import , index + 1 , # line numbers use 1 based indexing raw_line . startswith (( \" \" , \"\\t\" )), cimport = cimports , file_path = file_path , ) if \"(\" in line . split ( \"#\" , 1 ) [ 0 ] : while not line . split ( \"#\" ) [ 0 ] . strip (). endswith ( \")\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \"\\n\" + line else : while line . strip (). endswith ( \"\\\\\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) # Still need to check for parentheses after an escaped line if \"(\" in line . split ( \"#\" ) [ 0 ] and \")\" not in line . split ( \"#\" ) [ 0 ] : import_string += \"\\n\" + line while not line . split ( \"#\" ) [ 0 ] . strip (). endswith ( \")\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \"\\n\" + line else : if import_string . strip (). endswith ( ( \" import\" , \" cimport\" ) ) or line . strip (). startswith (( \"import \" , \"cimport \" )) : import_string += \"\\n\" + line else : import_string = ( import_string . rstrip (). rstrip ( \"\\\\\" ) + \" \" + line . lstrip () ) if type_of_import == \"from\" : import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \"\\\\\" , \" \" ) . replace ( \"\\n\" , \" \" ) ) parts = import_string . split ( \" cimport \" if cimports else \" import \" ) from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ). join ( [ from_import[0 ] + \" \" + \"\" . join ( from_import [ 1: ] ) ] + parts [ 1: ] ) just_imports = [ item.replace(\"{|\", \"{ \").replace(\"|}\", \" }\") for item in _strip_syntax(import_string).split() ] direct_imports = just_imports [ 1: ] top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ) : while \"as\" in just_imports : attribute = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : attribute = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + attribute alias = just_imports [ as_index + 1 ] direct_imports . remove ( attribute ) direct_imports . remove ( alias ) direct_imports . remove ( \"as\" ) just_imports [ 1: ] = direct_imports if attribute == alias and config . remove_redundant_aliases : yield identified_import ( top_level_module , attribute ) else : yield identified_import ( top_level_module , attribute , alias = alias ) else : module = just_imports [ as_index - 1 ] alias = just_imports [ as_index + 1 ] just_imports . remove ( alias ) just_imports . remove ( \"as\" ) just_imports . remove ( module ) if module == alias and config . remove_redundant_aliases : yield identified_import ( module ) else : yield identified_import ( module , alias = alias ) if just_imports : if type_of_import == \"from\" : module = just_imports . pop ( 0 ) for attribute in just_imports : yield identified_import ( module , attribute ) else : for module in just_imports : yield identified_import ( module ) Classes Import class Import ( / , * args , ** kwargs ) Import(line_number, indented, module, attribute, alias, cimport, file_path) View Source class Import ( NamedTuple ): line_number : int indented : bool module : str attribute : Optional [ str ] = None alias : Optional [ str ] = None cimport : bool = False file_path : Optional [ Path ] = None def statement ( self ) -> str : import_cmd = \"cimport\" if self . cimport else \"import\" if self . attribute : import_string = f \"from {self.module} {import_cmd} {self.attribute}\" else : import_string = f \"{import_cmd} {self.module}\" if self . alias : import_string += f \" as {self.alias}\" return import_string def __str__ ( self ): return ( f \"{self.file_path or ''}:{self.line_number} \" f \"{'indented ' if self.indented else ''}{self.statement()}\" ) Ancestors (in MRO) builtins.tuple Class variables alias attribute cimport file_path indented line_number module Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. statement def statement ( self ) -> str View Source def statement ( self ) -> str : import_cmd = \"cimport\" if self . cimport else \"import\" if self . attribute : import_string = f \"from {self.module} {import_cmd} {self.attribute}\" else : import_string = f \"{import_cmd} {self.module}\" if self . alias : import_string += f \" as {self.alias}\" return import_string","title":"Identify"},{"location":"reference/isort/identify/#module-isortidentify","text":"Fast stream based import identification. Eventually this will likely replace parse.py View Source \"\"\"Fast stream based import identification. Eventually this will likely replace parse.py \"\"\" from functools import partial from pathlib import Path from typing import Iterator , NamedTuple , Optional , TextIO , Tuple from isort.parse import _normalize_line , _strip_syntax , skip_line from .comments import parse as parse_comments from .settings import DEFAULT_CONFIG , Config STATEMENT_DECLARATIONS : Tuple [ str , ... ] = ( \"def \" , \"cdef \" , \"cpdef \" , \"class \" , \"@\" , \"async def\" ) class Import ( NamedTuple ): line_number : int indented : bool module : str attribute : Optional [ str ] = None alias : Optional [ str ] = None cimport : bool = False file_path : Optional [ Path ] = None def statement ( self ) -> str : import_cmd = \"cimport\" if self . cimport else \"import\" if self . attribute : import_string = f \"from {self.module} {import_cmd} {self.attribute}\" else : import_string = f \"{import_cmd} {self.module}\" if self . alias : import_string += f \" as {self.alias}\" return import_string def __str__ ( self ): return ( f \"{self.file_path or ''}:{self.line_number} \" f \"{'indented ' if self.indented else ''}{self.statement()}\" ) def imports ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , top_only : bool = False , ) -> Iterator [ Import ]: \"\"\"Parses a python file taking out and categorizing imports.\"\"\" in_quote = \"\" indexed_input = enumerate ( input_stream ) for index , raw_line in indexed_input : ( skipping_line , in_quote ) = skip_line ( raw_line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if top_only and not in_quote and raw_line . startswith ( STATEMENT_DECLARATIONS ): break if skipping_line : continue stripped_line = raw_line . strip () . split ( \"#\" )[ 0 ] if stripped_line . startswith ( \"raise\" ) or stripped_line . startswith ( \"yield\" ): if stripped_line == \"yield\" : while not stripped_line or stripped_line == \"yield\" : try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip () . split ( \"#\" )[ 0 ] while stripped_line . endswith ( \" \\\\ \" ): try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip () . split ( \"#\" )[ 0 ] continue # pragma: no cover line , * end_of_line_comment = raw_line . split ( \"#\" , 1 ) statements = [ line . strip () for line in line . split ( \";\" )] if end_of_line_comment : statements [ - 1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , _raw_line = _normalize_line ( statement ) if line . startswith (( \"import \" , \"cimport \" )): type_of_import = \"straight\" elif line . startswith ( \"from \" ): type_of_import = \"from\" else : continue # pragma: no cover import_string , _ = parse_comments ( line ) normalized_import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) cimports : bool = ( \" cimport \" in normalized_import_string or normalized_import_string . startswith ( \"cimport\" ) ) identified_import = partial ( Import , index + 1 , # line numbers use 1 based indexing raw_line . startswith (( \" \" , \" \\t \" )), cimport = cimports , file_path = file_path , ) if \"(\" in line . split ( \"#\" , 1 )[ 0 ]: while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ): try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \" \\n \" + line else : while line . strip () . endswith ( \" \\\\ \" ): try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) # Still need to check for parentheses after an escaped line if \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ]: import_string += \" \\n \" + line while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ): try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \" \\n \" + line else : if import_string . strip () . endswith ( ( \" import\" , \" cimport\" ) ) or line . strip () . startswith (( \"import \" , \"cimport \" )): import_string += \" \\n \" + line else : import_string = ( import_string . rstrip () . rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () ) if type_of_import == \"from\" : import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) parts = import_string . split ( \" cimport \" if cimports else \" import \" ) from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ) . join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 :])] + parts [ 1 :] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ) . replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ) . split () ] direct_imports = just_imports [ 1 :] top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ): while \"as\" in just_imports : attribute = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : attribute = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + attribute alias = just_imports [ as_index + 1 ] direct_imports . remove ( attribute ) direct_imports . remove ( alias ) direct_imports . remove ( \"as\" ) just_imports [ 1 :] = direct_imports if attribute == alias and config . remove_redundant_aliases : yield identified_import ( top_level_module , attribute ) else : yield identified_import ( top_level_module , attribute , alias = alias ) else : module = just_imports [ as_index - 1 ] alias = just_imports [ as_index + 1 ] just_imports . remove ( alias ) just_imports . remove ( \"as\" ) just_imports . remove ( module ) if module == alias and config . remove_redundant_aliases : yield identified_import ( module ) else : yield identified_import ( module , alias = alias ) if just_imports : if type_of_import == \"from\" : module = just_imports . pop ( 0 ) for attribute in just_imports : yield identified_import ( module , attribute ) else : for module in just_imports : yield identified_import ( module )","title":"Module isort.identify"},{"location":"reference/isort/identify/#variables","text":"STATEMENT_DECLARATIONS","title":"Variables"},{"location":"reference/isort/identify/#functions","text":"","title":"Functions"},{"location":"reference/isort/identify/#imports","text":"def imports ( input_stream : < class ' TextIO '>, config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), file_path : Union [ pathlib . Path , NoneType ] = None , top_only : bool = False ) -> Iterator [ isort . identify . Import ] Parses a python file taking out and categorizing imports. View Source def imports ( input_stream : TextIO , config : Config = DEFAULT_CONFIG , file_path : Optional [ Path ] = None , top_only : bool = False , ) -> Iterator [ Import ] : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" in_quote = \"\" indexed_input = enumerate ( input_stream ) for index , raw_line in indexed_input : ( skipping_line , in_quote ) = skip_line ( raw_line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if top_only and not in_quote and raw_line . startswith ( STATEMENT_DECLARATIONS ) : break if skipping_line : continue stripped_line = raw_line . strip (). split ( \"#\" ) [ 0 ] if stripped_line . startswith ( \"raise\" ) or stripped_line . startswith ( \"yield\" ) : if stripped_line == \"yield\" : while not stripped_line or stripped_line == \"yield\" : try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip (). split ( \"#\" ) [ 0 ] while stripped_line . endswith ( \"\\\\\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break stripped_line = next_line . strip (). split ( \"#\" ) [ 0 ] continue # pragma : no cover line , * end_of_line_comment = raw_line . split ( \"#\" , 1 ) statements = [ line.strip() for line in line.split(\";\") ] if end_of_line_comment : statements [ -1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , _raw_line = _normalize_line ( statement ) if line . startswith (( \"import \" , \"cimport \" )) : type_of_import = \"straight\" elif line . startswith ( \"from \" ) : type_of_import = \"from\" else : continue # pragma : no cover import_string , _ = parse_comments ( line ) normalized_import_string = ( import_string . replace ( \"import(\" , \"import (\" ). replace ( \"\\\\\" , \" \" ). replace ( \"\\n\" , \" \" ) ) cimports : bool = ( \" cimport \" in normalized_import_string or normalized_import_string . startswith ( \"cimport\" ) ) identified_import = partial ( Import , index + 1 , # line numbers use 1 based indexing raw_line . startswith (( \" \" , \"\\t\" )), cimport = cimports , file_path = file_path , ) if \"(\" in line . split ( \"#\" , 1 ) [ 0 ] : while not line . split ( \"#\" ) [ 0 ] . strip (). endswith ( \")\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \"\\n\" + line else : while line . strip (). endswith ( \"\\\\\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) # Still need to check for parentheses after an escaped line if \"(\" in line . split ( \"#\" ) [ 0 ] and \")\" not in line . split ( \"#\" ) [ 0 ] : import_string += \"\\n\" + line while not line . split ( \"#\" ) [ 0 ] . strip (). endswith ( \")\" ) : try : index , next_line = next ( indexed_input ) except StopIteration : break line , _ = parse_comments ( next_line ) import_string += \"\\n\" + line else : if import_string . strip (). endswith ( ( \" import\" , \" cimport\" ) ) or line . strip (). startswith (( \"import \" , \"cimport \" )) : import_string += \"\\n\" + line else : import_string = ( import_string . rstrip (). rstrip ( \"\\\\\" ) + \" \" + line . lstrip () ) if type_of_import == \"from\" : import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \"\\\\\" , \" \" ) . replace ( \"\\n\" , \" \" ) ) parts = import_string . split ( \" cimport \" if cimports else \" import \" ) from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ). join ( [ from_import[0 ] + \" \" + \"\" . join ( from_import [ 1: ] ) ] + parts [ 1: ] ) just_imports = [ item.replace(\"{|\", \"{ \").replace(\"|}\", \" }\") for item in _strip_syntax(import_string).split() ] direct_imports = just_imports [ 1: ] top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ) : while \"as\" in just_imports : attribute = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : attribute = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + attribute alias = just_imports [ as_index + 1 ] direct_imports . remove ( attribute ) direct_imports . remove ( alias ) direct_imports . remove ( \"as\" ) just_imports [ 1: ] = direct_imports if attribute == alias and config . remove_redundant_aliases : yield identified_import ( top_level_module , attribute ) else : yield identified_import ( top_level_module , attribute , alias = alias ) else : module = just_imports [ as_index - 1 ] alias = just_imports [ as_index + 1 ] just_imports . remove ( alias ) just_imports . remove ( \"as\" ) just_imports . remove ( module ) if module == alias and config . remove_redundant_aliases : yield identified_import ( module ) else : yield identified_import ( module , alias = alias ) if just_imports : if type_of_import == \"from\" : module = just_imports . pop ( 0 ) for attribute in just_imports : yield identified_import ( module , attribute ) else : for module in just_imports : yield identified_import ( module )","title":"imports"},{"location":"reference/isort/identify/#classes","text":"","title":"Classes"},{"location":"reference/isort/identify/#import","text":"class Import ( / , * args , ** kwargs ) Import(line_number, indented, module, attribute, alias, cimport, file_path) View Source class Import ( NamedTuple ): line_number : int indented : bool module : str attribute : Optional [ str ] = None alias : Optional [ str ] = None cimport : bool = False file_path : Optional [ Path ] = None def statement ( self ) -> str : import_cmd = \"cimport\" if self . cimport else \"import\" if self . attribute : import_string = f \"from {self.module} {import_cmd} {self.attribute}\" else : import_string = f \"{import_cmd} {self.module}\" if self . alias : import_string += f \" as {self.alias}\" return import_string def __str__ ( self ): return ( f \"{self.file_path or ''}:{self.line_number} \" f \"{'indented ' if self.indented else ''}{self.statement()}\" )","title":"Import"},{"location":"reference/isort/identify/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/isort/identify/#class-variables","text":"alias attribute cimport file_path indented line_number module","title":"Class variables"},{"location":"reference/isort/identify/#methods","text":"","title":"Methods"},{"location":"reference/isort/identify/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/isort/identify/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/isort/identify/#statement","text":"def statement ( self ) -> str View Source def statement ( self ) -> str : import_cmd = \"cimport\" if self . cimport else \"import\" if self . attribute : import_string = f \"from {self.module} {import_cmd} {self.attribute}\" else : import_string = f \"{import_cmd} {self.module}\" if self . alias : import_string += f \" as {self.alias}\" return import_string","title":"statement"},{"location":"reference/isort/io/","text":"Module isort.io Defines any IO utilities used by isort View Source \"\"\"Defines any IO utilities used by isort\"\"\" import re import tokenize from contextlib import contextmanager from io import BytesIO , StringIO , TextIOWrapper from pathlib import Path from typing import Callable , Iterator , TextIO , Union from isort._future import dataclass from isort.exceptions import UnsupportedEncoding _ENCODING_PATTERN = re . compile ( br \"^[ \\t\\f]*#.*?coding[:=][ \\t]*([-_.a-zA-Z0-9]+)\" ) @dataclass ( frozen = True ) class File : stream : TextIO path : Path encoding : str @staticmethod def detect_encoding ( filename : str , readline : Callable [[], bytes ]): try : return tokenize . detect_encoding ( readline )[ 0 ] except Exception : raise UnsupportedEncoding ( filename ) @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding = File . detect_encoding ( filename , BytesIO ( contents . encode ( \"utf-8\" )) . readline ) return File ( # type: ignore stream = StringIO ( contents ), path = Path ( filename ) . resolve (), encoding = encoding ) @property def extension ( self ): return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ): \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding = File . detect_encoding ( filename , buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type: ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str , Path ]) -> Iterator [ \"File\" ]: file_path = Path ( filename ) . resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) # type: ignore finally : if stream is not None : stream . close () class _EmptyIO ( StringIO ): def write ( self , * args , ** kwargs ): pass Empty = _EmptyIO () Variables Empty Classes File class File ( stream : < class ' TextIO '>, path : pathlib . Path , encoding : str ) File(stream: , path: pathlib.Path, encoding: str) View Source class File : stream : TextIO path : Path encoding : str @staticmethod def detect_encoding ( filename : str , readline : Callable [ [ ] , bytes ] ) : try : return tokenize . detect_encoding ( readline ) [ 0 ] except Exception : raise UnsupportedEncoding ( filename ) @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding = File . detect_encoding ( filename , BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( # type : ignore stream = StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding ) @property def extension ( self ) : return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ) : \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding = File . detect_encoding ( filename , buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type : ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) # type : ignore finally : if stream is not None : stream . close () Static methods detect_encoding def detect_encoding ( filename : str , readline : Callable [[], bytes ] ) View Source @staticmethod def detect_encoding ( filename : str , readline : Callable [ [ ] , bytes ] ) : try : return tokenize . detect_encoding ( readline ) [ 0 ] except Exception : raise UnsupportedEncoding ( filename ) from_contents def from_contents ( contents : str , filename : str ) -> 'File' View Source @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding = File . detect_encoding ( filename , BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( # type : ignore stream = StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding ) read def read ( filename : Union [ str , pathlib . Path ] ) -> Iterator [ ForwardRef ( 'File' )] View Source @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) # type : ignore finally : if stream is not None : stream . close () Instance variables extension","title":"Io"},{"location":"reference/isort/io/#module-isortio","text":"Defines any IO utilities used by isort View Source \"\"\"Defines any IO utilities used by isort\"\"\" import re import tokenize from contextlib import contextmanager from io import BytesIO , StringIO , TextIOWrapper from pathlib import Path from typing import Callable , Iterator , TextIO , Union from isort._future import dataclass from isort.exceptions import UnsupportedEncoding _ENCODING_PATTERN = re . compile ( br \"^[ \\t\\f]*#.*?coding[:=][ \\t]*([-_.a-zA-Z0-9]+)\" ) @dataclass ( frozen = True ) class File : stream : TextIO path : Path encoding : str @staticmethod def detect_encoding ( filename : str , readline : Callable [[], bytes ]): try : return tokenize . detect_encoding ( readline )[ 0 ] except Exception : raise UnsupportedEncoding ( filename ) @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding = File . detect_encoding ( filename , BytesIO ( contents . encode ( \"utf-8\" )) . readline ) return File ( # type: ignore stream = StringIO ( contents ), path = Path ( filename ) . resolve (), encoding = encoding ) @property def extension ( self ): return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ): \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding = File . detect_encoding ( filename , buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type: ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str , Path ]) -> Iterator [ \"File\" ]: file_path = Path ( filename ) . resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) # type: ignore finally : if stream is not None : stream . close () class _EmptyIO ( StringIO ): def write ( self , * args , ** kwargs ): pass Empty = _EmptyIO ()","title":"Module isort.io"},{"location":"reference/isort/io/#variables","text":"Empty","title":"Variables"},{"location":"reference/isort/io/#classes","text":"","title":"Classes"},{"location":"reference/isort/io/#file","text":"class File ( stream : < class ' TextIO '>, path : pathlib . Path , encoding : str ) File(stream: , path: pathlib.Path, encoding: str) View Source class File : stream : TextIO path : Path encoding : str @staticmethod def detect_encoding ( filename : str , readline : Callable [ [ ] , bytes ] ) : try : return tokenize . detect_encoding ( readline ) [ 0 ] except Exception : raise UnsupportedEncoding ( filename ) @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding = File . detect_encoding ( filename , BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( # type : ignore stream = StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding ) @property def extension ( self ) : return self . path . suffix . lstrip ( \".\" ) @staticmethod def _open ( filename ) : \"\"\"Open a file in read only mode using the encoding detected by detect_encoding(). \"\"\" buffer = open ( filename , \"rb\" ) try : encoding = File . detect_encoding ( filename , buffer . readline ) buffer . seek ( 0 ) text = TextIOWrapper ( buffer , encoding , line_buffering = True , newline = \"\" ) text . mode = \"r\" # type : ignore return text except Exception : buffer . close () raise @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) # type : ignore finally : if stream is not None : stream . close ()","title":"File"},{"location":"reference/isort/io/#static-methods","text":"","title":"Static methods"},{"location":"reference/isort/io/#detect_encoding","text":"def detect_encoding ( filename : str , readline : Callable [[], bytes ] ) View Source @staticmethod def detect_encoding ( filename : str , readline : Callable [ [ ] , bytes ] ) : try : return tokenize . detect_encoding ( readline ) [ 0 ] except Exception : raise UnsupportedEncoding ( filename )","title":"detect_encoding"},{"location":"reference/isort/io/#from_contents","text":"def from_contents ( contents : str , filename : str ) -> 'File' View Source @staticmethod def from_contents ( contents : str , filename : str ) -> \"File\" : encoding = File . detect_encoding ( filename , BytesIO ( contents . encode ( \"utf-8\" )). readline ) return File ( # type : ignore stream = StringIO ( contents ), path = Path ( filename ). resolve (), encoding = encoding )","title":"from_contents"},{"location":"reference/isort/io/#read","text":"def read ( filename : Union [ str , pathlib . Path ] ) -> Iterator [ ForwardRef ( 'File' )] View Source @staticmethod @contextmanager def read ( filename : Union [ str, Path ] ) -> Iterator [ \"File\" ] : file_path = Path ( filename ). resolve () stream = None try : stream = File . _open ( file_path ) yield File ( stream = stream , path = file_path , encoding = stream . encoding ) # type : ignore finally : if stream is not None : stream . close ()","title":"read"},{"location":"reference/isort/io/#instance-variables","text":"extension","title":"Instance variables"},{"location":"reference/isort/literal/","text":"Module isort.literal View Source import ast from pprint import PrettyPrinter from typing import Any , Callable , Dict , List , Set , Tuple from isort . exceptions import ( AssignmentsFormatMismatch , LiteralParsingFailure , LiteralSortTypeMismatch , ) from isort . settings import DEFAULT_CONFIG , Config class ISortPrettyPrinter ( PrettyPrinter ) : \"\"\"an isort customized pretty printer for sorted literals\"\"\" def __ init__ ( self , config : Config ) : super (). __ init__ ( width = config . line_length , compact = True ) type_mapping: Dict [ str , Tuple [ type , Callable [[ Any , ISortPrettyPrinter ], str ]]] = {} def assignments ( code : str ) -> str : values = {} for line in code . splitlines ( keepends = True ) : if not line . strip () : continue if \" = \" not in line : raise AssignmentsFormatMismatch ( code ) variable_name , value = line . split ( \" = \" , 1 ) values [ variable_name ] = value return \"\" . join ( f \"{variable_name} = {values[variable_name]}\" for variable_name in sorted ( values . keys ()) ) def assignment ( code : str , sort_type: str , extension : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Sorts the literal present within the provided code against the provided sort type, returning the sorted representation of the source code. \"\"\" if sort_type == \"assignments\" : return assignments ( code ) if sort_type not in type_mapping: raise ValueError ( \"Trying to sort using an undefined sort_type. \" f \"Defined sort types are {', '.join(type_mapping.keys())}.\" ) variable_name , literal = code . split ( \" = \" ) variable_name = variable_name . lstrip () try : value = ast . literal_eval ( literal ) except Exception as error : raise LiteralParsingFailure ( code , error ) expected_type , sort_function = type_mapping [ sort_type ] if type ( value ) ! = expected_type: raise LiteralSortTypeMismatch ( type ( value ), expected_type ) printer = ISortPrettyPrinter ( config ) sorted_value_code = f \"{variable_name} = {sort_function(value, printer)}\" if config . formatting_function: sorted_value_code = config . formatting_function ( sorted_value_code , extension , config ). rstrip () sorted_value_code += code [ len ( code . rstrip ()) : ] return sorted_value_code def register_type ( name : str , kind : type ) : \"\"\"Registers a new literal sort type.\"\"\" def wrap ( function ) : type_mapping [ name ] = ( kind , function ) return function return wrap @ register_type ( \"dict\" , dict ) def _ dict ( value : Dict [ Any , Any ], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( dict ( sorted ( value . items (), key = lambda item : item [ 1 ]))) @ register_type ( \"list\" , list ) def _ list ( value : List [ Any ], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( sorted ( value )) @ register_type ( \"unique-list\" , list ) def _ unique_list ( value : List [ Any ], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( list ( sorted ( set ( value )))) @ register_type ( \"set\" , set ) def _ set ( value : Set [ Any ], printer : ISortPrettyPrinter ) -> str : return \"{\" + printer . pformat ( tuple ( sorted ( value )))[ 1 :- 1 ] + \"}\" @ register_type ( \"tuple\" , tuple ) def _ tuple ( value : Tuple [ Any , ...], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( tuple ( sorted ( value ))) @ register_type ( \"unique-tuple\" , tuple ) def _ unique_tuple ( value : Tuple [ Any , ...], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( tuple ( sorted ( set ( value )))) Variables type_mapping Functions assignment def assignment ( code : str , sort_type : str , extension : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> str Sorts the literal present within the provided code against the provided sort type, returning the sorted representation of the source code. View Source def assignment ( code : str , sort_type : str , extension : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Sorts the literal present within the provided code against the provided sort type, returning the sorted representation of the source code. \"\"\" if sort_type == \"assignments\" : return assignments ( code ) if sort_type not in type_mapping : raise ValueError ( \"Trying to sort using an undefined sort_type. \" f \"Defined sort types are {', '.join(type_mapping.keys())}.\" ) variable_name , literal = code . split ( \" = \" ) variable_name = variable_name . lstrip () try : value = ast . literal_eval ( literal ) except Exception as error : raise LiteralParsingFailure ( code , error ) expected_type , sort_function = type_mapping [ sort_type ] if type ( value ) != expected_type : raise LiteralSortTypeMismatch ( type ( value ), expected_type ) printer = ISortPrettyPrinter ( config ) sorted_value_code = f \"{variable_name} = {sort_function(value, printer)}\" if config . formatting_function : sorted_value_code = config . formatting_function ( sorted_value_code , extension , config ). rstrip () sorted_value_code += code [ len(code.rstrip()) : ] return sorted_value_code assignments def assignments ( code : str ) -> str View Source def assignments ( code : str ) -> str : values = {} for line in code . splitlines ( keepends = True ) : if not line . strip () : continue if \" = \" not in line : raise AssignmentsFormatMismatch ( code ) variable_name , value = line . split ( \" = \" , 1 ) values [ variable_name ] = value return \"\" . join ( f \"{variable_name} = {values[variable_name]}\" for variable_name in sorted ( values . keys ()) ) register_type def register_type ( name : str , kind : type ) Registers a new literal sort type. View Source def register_type ( name : str , kind : type ) : \"\"\"Registers a new literal sort type.\"\"\" def wrap ( function ) : type_mapping [ name ] = ( kind , function ) return function return wrap Classes ISortPrettyPrinter class ISortPrettyPrinter ( config : isort . settings . Config ) an isort customized pretty printer for sorted literals View Source class ISortPrettyPrinter ( PrettyPrinter ): \"\"\"an isort customized pretty printer for sorted literals\"\"\" def __init__ ( self , config: Config ): super (). __init__ ( width = config . line_length , compact = True ) Ancestors (in MRO) pprint.PrettyPrinter Methods format def format ( self , object , context , maxlevels , level ) Format object for a specific context, returning a string and flags indicating whether the representation is 'readable' and whether the object represents a recursive construct. View Source def format ( self , object , context , maxlevels , level ): \"\"\"Format object for a specific context, returning a string and flags indicating whether the representation is 'readable' and whether the object represents a recursive construct. \"\"\" return _safe_repr ( object , context , maxlevels , level , self . _sort_dicts ) isreadable def isreadable ( self , object ) View Source def isreadable ( self , object ): s , readable , recursive = self . format ( object , {} , 0 , 0 ) return readable and not recursive isrecursive def isrecursive ( self , object ) View Source def isrecursive ( self , object ): return self . format ( object , {} , 0 , 0 )[ 2 ] pformat def pformat ( self , object ) View Source def pformat ( self , object ): sio = _StringIO () self . _format ( object , sio , 0 , 0 , {} , 0 ) return sio . getvalue () pprint def pprint ( self , object ) View Source def pprint ( self , object ): self . _format ( object , self . _stream , 0 , 0 , {} , 0 ) self . _stream . write ( \"\\n\" )","title":"Literal"},{"location":"reference/isort/literal/#module-isortliteral","text":"View Source import ast from pprint import PrettyPrinter from typing import Any , Callable , Dict , List , Set , Tuple from isort . exceptions import ( AssignmentsFormatMismatch , LiteralParsingFailure , LiteralSortTypeMismatch , ) from isort . settings import DEFAULT_CONFIG , Config class ISortPrettyPrinter ( PrettyPrinter ) : \"\"\"an isort customized pretty printer for sorted literals\"\"\" def __ init__ ( self , config : Config ) : super (). __ init__ ( width = config . line_length , compact = True ) type_mapping: Dict [ str , Tuple [ type , Callable [[ Any , ISortPrettyPrinter ], str ]]] = {} def assignments ( code : str ) -> str : values = {} for line in code . splitlines ( keepends = True ) : if not line . strip () : continue if \" = \" not in line : raise AssignmentsFormatMismatch ( code ) variable_name , value = line . split ( \" = \" , 1 ) values [ variable_name ] = value return \"\" . join ( f \"{variable_name} = {values[variable_name]}\" for variable_name in sorted ( values . keys ()) ) def assignment ( code : str , sort_type: str , extension : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Sorts the literal present within the provided code against the provided sort type, returning the sorted representation of the source code. \"\"\" if sort_type == \"assignments\" : return assignments ( code ) if sort_type not in type_mapping: raise ValueError ( \"Trying to sort using an undefined sort_type. \" f \"Defined sort types are {', '.join(type_mapping.keys())}.\" ) variable_name , literal = code . split ( \" = \" ) variable_name = variable_name . lstrip () try : value = ast . literal_eval ( literal ) except Exception as error : raise LiteralParsingFailure ( code , error ) expected_type , sort_function = type_mapping [ sort_type ] if type ( value ) ! = expected_type: raise LiteralSortTypeMismatch ( type ( value ), expected_type ) printer = ISortPrettyPrinter ( config ) sorted_value_code = f \"{variable_name} = {sort_function(value, printer)}\" if config . formatting_function: sorted_value_code = config . formatting_function ( sorted_value_code , extension , config ). rstrip () sorted_value_code += code [ len ( code . rstrip ()) : ] return sorted_value_code def register_type ( name : str , kind : type ) : \"\"\"Registers a new literal sort type.\"\"\" def wrap ( function ) : type_mapping [ name ] = ( kind , function ) return function return wrap @ register_type ( \"dict\" , dict ) def _ dict ( value : Dict [ Any , Any ], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( dict ( sorted ( value . items (), key = lambda item : item [ 1 ]))) @ register_type ( \"list\" , list ) def _ list ( value : List [ Any ], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( sorted ( value )) @ register_type ( \"unique-list\" , list ) def _ unique_list ( value : List [ Any ], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( list ( sorted ( set ( value )))) @ register_type ( \"set\" , set ) def _ set ( value : Set [ Any ], printer : ISortPrettyPrinter ) -> str : return \"{\" + printer . pformat ( tuple ( sorted ( value )))[ 1 :- 1 ] + \"}\" @ register_type ( \"tuple\" , tuple ) def _ tuple ( value : Tuple [ Any , ...], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( tuple ( sorted ( value ))) @ register_type ( \"unique-tuple\" , tuple ) def _ unique_tuple ( value : Tuple [ Any , ...], printer : ISortPrettyPrinter ) -> str : return printer . pformat ( tuple ( sorted ( set ( value ))))","title":"Module isort.literal"},{"location":"reference/isort/literal/#variables","text":"type_mapping","title":"Variables"},{"location":"reference/isort/literal/#functions","text":"","title":"Functions"},{"location":"reference/isort/literal/#assignment","text":"def assignment ( code : str , sort_type : str , extension : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> str Sorts the literal present within the provided code against the provided sort type, returning the sorted representation of the source code. View Source def assignment ( code : str , sort_type : str , extension : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Sorts the literal present within the provided code against the provided sort type, returning the sorted representation of the source code. \"\"\" if sort_type == \"assignments\" : return assignments ( code ) if sort_type not in type_mapping : raise ValueError ( \"Trying to sort using an undefined sort_type. \" f \"Defined sort types are {', '.join(type_mapping.keys())}.\" ) variable_name , literal = code . split ( \" = \" ) variable_name = variable_name . lstrip () try : value = ast . literal_eval ( literal ) except Exception as error : raise LiteralParsingFailure ( code , error ) expected_type , sort_function = type_mapping [ sort_type ] if type ( value ) != expected_type : raise LiteralSortTypeMismatch ( type ( value ), expected_type ) printer = ISortPrettyPrinter ( config ) sorted_value_code = f \"{variable_name} = {sort_function(value, printer)}\" if config . formatting_function : sorted_value_code = config . formatting_function ( sorted_value_code , extension , config ). rstrip () sorted_value_code += code [ len(code.rstrip()) : ] return sorted_value_code","title":"assignment"},{"location":"reference/isort/literal/#assignments","text":"def assignments ( code : str ) -> str View Source def assignments ( code : str ) -> str : values = {} for line in code . splitlines ( keepends = True ) : if not line . strip () : continue if \" = \" not in line : raise AssignmentsFormatMismatch ( code ) variable_name , value = line . split ( \" = \" , 1 ) values [ variable_name ] = value return \"\" . join ( f \"{variable_name} = {values[variable_name]}\" for variable_name in sorted ( values . keys ()) )","title":"assignments"},{"location":"reference/isort/literal/#register_type","text":"def register_type ( name : str , kind : type ) Registers a new literal sort type. View Source def register_type ( name : str , kind : type ) : \"\"\"Registers a new literal sort type.\"\"\" def wrap ( function ) : type_mapping [ name ] = ( kind , function ) return function return wrap","title":"register_type"},{"location":"reference/isort/literal/#classes","text":"","title":"Classes"},{"location":"reference/isort/literal/#isortprettyprinter","text":"class ISortPrettyPrinter ( config : isort . settings . Config ) an isort customized pretty printer for sorted literals View Source class ISortPrettyPrinter ( PrettyPrinter ): \"\"\"an isort customized pretty printer for sorted literals\"\"\" def __init__ ( self , config: Config ): super (). __init__ ( width = config . line_length , compact = True )","title":"ISortPrettyPrinter"},{"location":"reference/isort/literal/#ancestors-in-mro","text":"pprint.PrettyPrinter","title":"Ancestors (in MRO)"},{"location":"reference/isort/literal/#methods","text":"","title":"Methods"},{"location":"reference/isort/literal/#format","text":"def format ( self , object , context , maxlevels , level ) Format object for a specific context, returning a string and flags indicating whether the representation is 'readable' and whether the object represents a recursive construct. View Source def format ( self , object , context , maxlevels , level ): \"\"\"Format object for a specific context, returning a string and flags indicating whether the representation is 'readable' and whether the object represents a recursive construct. \"\"\" return _safe_repr ( object , context , maxlevels , level , self . _sort_dicts )","title":"format"},{"location":"reference/isort/literal/#isreadable","text":"def isreadable ( self , object ) View Source def isreadable ( self , object ): s , readable , recursive = self . format ( object , {} , 0 , 0 ) return readable and not recursive","title":"isreadable"},{"location":"reference/isort/literal/#isrecursive","text":"def isrecursive ( self , object ) View Source def isrecursive ( self , object ): return self . format ( object , {} , 0 , 0 )[ 2 ]","title":"isrecursive"},{"location":"reference/isort/literal/#pformat","text":"def pformat ( self , object ) View Source def pformat ( self , object ): sio = _StringIO () self . _format ( object , sio , 0 , 0 , {} , 0 ) return sio . getvalue ()","title":"pformat"},{"location":"reference/isort/literal/#pprint","text":"def pprint ( self , object ) View Source def pprint ( self , object ): self . _format ( object , self . _stream , 0 , 0 , {} , 0 ) self . _stream . write ( \"\\n\" )","title":"pprint"},{"location":"reference/isort/logo/","text":"Module isort.logo _ _ ( _ ) ___ ___ _ __ | | _ | |/ _ / / _ \\ / '__ _/ | | \\ __ \\ / \\ _ \\ /| | | | _ | _ | \\ ___ / \\ ___ / \\ _ / \\ _ / isort your imports , so you don 't have to. VERSION 5.7 . 0 View Source from ._version import __version__ ASCII_ART = rf \"\"\" _ _ (_) ___ ___ _ __| |_ | |/ _/ / _ \\/ '__ _/ | |\\__ \\/\\_\\/| | | |_ |_|\\___/\\___/\\_/ \\_/ isort your imports, so you don't have to. VERSION {__version__} \"\"\" __doc__ = f \"\"\" ```python {ASCII_ART} ``` \"\"\" Variables ASCII_ART","title":"Logo"},{"location":"reference/isort/logo/#module-isortlogo","text":"_ _ ( _ ) ___ ___ _ __ | | _ | |/ _ / / _ \\ / '__ _/ | | \\ __ \\ / \\ _ \\ /| | | | _ | _ | \\ ___ / \\ ___ / \\ _ / \\ _ / isort your imports , so you don 't have to. VERSION 5.7 . 0 View Source from ._version import __version__ ASCII_ART = rf \"\"\" _ _ (_) ___ ___ _ __| |_ | |/ _/ / _ \\/ '__ _/ | |\\__ \\/\\_\\/| | | |_ |_|\\___/\\___/\\_/ \\_/ isort your imports, so you don't have to. VERSION {__version__} \"\"\" __doc__ = f \"\"\" ```python {ASCII_ART} ``` \"\"\"","title":"Module isort.logo"},{"location":"reference/isort/logo/#variables","text":"ASCII_ART","title":"Variables"},{"location":"reference/isort/main/","text":"Module isort.main Tool for sorting imports alphabetically, and automatically separated into sections. View Source \"\"\"Tool for sorting imports alphabetically, and automatically separated into sections.\"\"\" import argparse import functools import json import os import sys from gettext import gettext as _ from io import TextIOWrapper from pathlib import Path from typing import Any , Dict , List , Optional , Sequence from warnings import warn from . import __version__ , api , files , sections from .exceptions import FileSkipped , ISortError , UnsupportedEncoding from .format import create_terminal_printer from .logo import ASCII_ART from .profiles import profiles from .settings import VALID_PY_TARGETS , Config , WrapModes try : from .setuptools_commands import ISortCommand # noqa: F401 except ImportError : pass DEPRECATED_SINGLE_DASH_ARGS = { \"-ac\" , \"-af\" , \"-ca\" , \"-cs\" , \"-df\" , \"-ds\" , \"-dt\" , \"-fas\" , \"-fass\" , \"-ff\" , \"-fgw\" , \"-fss\" , \"-lai\" , \"-lbt\" , \"-le\" , \"-ls\" , \"-nis\" , \"-nlb\" , \"-ot\" , \"-rr\" , \"-sd\" , \"-sg\" , \"-sl\" , \"-sp\" , \"-tc\" , \"-wl\" , \"-ws\" , } QUICK_GUIDE = f \"\"\" {ASCII_ART} Nothing to do: no files or paths have have been passed in! Try one of the following: `isort .` - sort all Python files, starting from the current directory, recursively. `isort . --interactive` - Do the same, but ask before making any changes. `isort . --check --diff` - Check to see if imports are correctly sorted within this project. `isort --help` - In-depth information about isort's available command-line options. Visit https://pycqa.github.io/isort/ for complete information about how to use isort. \"\"\" class SortAttempt : def __init__ ( self , incorrectly_sorted : bool , skipped : bool , supported_encoding : bool ) -> None : self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped self . supported_encoding = supported_encoding def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ]: incorrectly_sorted : bool = False skipped : bool = False try : if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None except UnsupportedEncoding : if config . verbose : warn ( f \"Encoding not supported for {file_name}\" ) return SortAttempt ( incorrectly_sorted , skipped , False ) except ISortError as error : _print_hard_fail ( config , message = str ( error )) sys . exit ( 1 ) except Exception : _print_hard_fail ( config , offending_file = file_name ) raise def _print_hard_fail ( config : Config , offending_file : Optional [ str ] = None , message : Optional [ str ] = None ) -> None : \"\"\"Fail on unrecoverable exception with custom message.\"\"\" message = message or ( f \"Unrecoverable exception thrown when parsing {offending_file or ''}!\" \"This should NEVER happen. \\n \" \"If encountered, please open an issue: https://github.com/PyCQA/isort/issues/new\" ) printer = create_terminal_printer ( color = config . color_output ) printer . error ( message ) def _build_arg_parser () -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( description = \"Sort Python import definitions alphabetically \" \"within logical sections. Run with no arguments to see a quick \" \"start guide, otherwise, one or more files/directories/stdin must be provided. \" \"Use `-` as the first argument to represent stdin. Use --interactive to use the pre 5.0.0 \" \"interactive behavior.\" \" \" \"If you've used isort 4 but are new to isort 5, see the upgrading guide:\" \"https://pycqa.github.io/isort/docs/upgrade_guides/5.0.0/.\" , add_help = False , # prevent help option from appearing in \"optional arguments\" group ) general_group = parser . add_argument_group ( \"general options\" ) target_group = parser . add_argument_group ( \"target options\" ) output_group = parser . add_argument_group ( \"general output options\" ) inline_args_group = output_group . add_mutually_exclusive_group () section_group = parser . add_argument_group ( \"section output options\" ) deprecated_group = parser . add_argument_group ( \"deprecated options\" ) general_group . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = _ ( \"show this help message and exit\" ), ) general_group . add_argument ( \"-V\" , \"--version\" , action = \"store_true\" , dest = \"show_version\" , help = \"Displays the currently installed version of isort.\" , ) general_group . add_argument ( \"--vn\" , \"--version-number\" , action = \"version\" , version = __version__ , help = \"Returns just the current version number without the logo\" , ) general_group . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , dest = \"verbose\" , help = \"Shows verbose output, such as when files are skipped or when a check is successful.\" , ) general_group . add_argument ( \"--only-modified\" , \"--om\" , dest = \"only_modified\" , action = \"store_true\" , help = \"Suppresses verbose output for non-modified files.\" , ) general_group . add_argument ( \"--dedup-headings\" , dest = \"dedup_headings\" , action = \"store_true\" , help = \"Tells isort to only show an identical custom import heading comment once, even if\" \" there are multiple sections with the comment set.\" , ) general_group . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , dest = \"quiet\" , help = \"Shows extra quiet output, only errors are outputted.\" , ) general_group . add_argument ( \"-d\" , \"--stdout\" , help = \"Force resulting output to stdout, instead of in-place.\" , dest = \"write_to_stdout\" , action = \"store_true\" , ) general_group . add_argument ( \"--show-config\" , dest = \"show_config\" , action = \"store_true\" , help = \"See isort's determined config, as well as sources of config options.\" , ) general_group . add_argument ( \"--show-files\" , dest = \"show_files\" , action = \"store_true\" , help = \"See the files isort will be ran against with the current config options.\" , ) general_group . add_argument ( \"--df\" , \"--diff\" , dest = \"show_diff\" , action = \"store_true\" , help = \"Prints a diff of all the changes isort would make to a file, instead of \" \"changing it in place\" , ) general_group . add_argument ( \"-c\" , \"--check-only\" , \"--check\" , action = \"store_true\" , dest = \"check\" , help = \"Checks the file for unsorted / unformatted imports and prints them to the \" \"command line without modifying the file. Returns 0 when nothing would change and \" \"returns 1 when the file would be reformatted.\" , ) general_group . add_argument ( \"--ws\" , \"--ignore-whitespace\" , action = \"store_true\" , dest = \"ignore_whitespace\" , help = \"Tells isort to ignore whitespace differences when --check-only is being used.\" , ) general_group . add_argument ( \"--sp\" , \"--settings-path\" , \"--settings-file\" , \"--settings\" , dest = \"settings_path\" , help = \"Explicitly set the settings path or file instead of auto determining \" \"based on file location.\" , ) general_group . add_argument ( \"--profile\" , dest = \"profile\" , type = str , help = \"Base profile type to use for configuration. \" f \"Profiles include: {', '.join(profiles.keys())}. As well as any shared profiles.\" , ) general_group . add_argument ( \"--old-finders\" , \"--magic-placement\" , dest = \"old_finders\" , action = \"store_true\" , help = \"Use the old deprecated finder logic that relies on environment introspection magic.\" , ) general_group . add_argument ( \"-j\" , \"--jobs\" , help = \"Number of files to process in parallel.\" , dest = \"jobs\" , type = int ) general_group . add_argument ( \"--ac\" , \"--atomic\" , dest = \"atomic\" , action = \"store_true\" , help = \"Ensures the output doesn't save if the resulting file contains syntax errors.\" , ) general_group . add_argument ( \"--interactive\" , dest = \"ask_to_apply\" , action = \"store_true\" , help = \"Tells isort to apply changes interactively.\" , ) target_group . add_argument ( \"files\" , nargs = \"*\" , help = \"One or more Python source files that need their imports sorted.\" ) target_group . add_argument ( \"--filter-files\" , dest = \"filter_files\" , action = \"store_true\" , help = \"Tells isort to filter files even when they are explicitly passed in as \" \"part of the CLI command.\" , ) target_group . add_argument ( \"-s\" , \"--skip\" , help = \"Files that sort imports should skip over. If you want to skip multiple \" \"files you should specify twice: --skip file1 --skip file2.\" , dest = \"skip\" , action = \"append\" , ) target_group . add_argument ( \"--sg\" , \"--skip-glob\" , help = \"Files that sort imports should skip over.\" , dest = \"skip_glob\" , action = \"append\" , ) target_group . add_argument ( \"--gitignore\" , \"--skip-gitignore\" , action = \"store_true\" , dest = \"skip_gitignore\" , help = \"Treat project as a git repository and ignore files listed in .gitignore\" , ) target_group . add_argument ( \"--ext\" , \"--extension\" , \"--supported-extension\" , dest = \"supported_extensions\" , action = \"append\" , help = \"Specifies what extensions isort can be ran against.\" , ) target_group . add_argument ( \"--blocked-extension\" , dest = \"blocked_extensions\" , action = \"append\" , help = \"Specifies what extensions isort can never be ran against.\" , ) target_group . add_argument ( \"--dont-follow-links\" , dest = \"dont_follow_links\" , action = \"store_true\" , help = \"Tells isort not to follow symlinks that are encountered when running recursively.\" , ) target_group . add_argument ( \"--filename\" , dest = \"filename\" , help = \"Provide the filename associated with a stream.\" , ) output_group . add_argument ( \"-a\" , \"--add-import\" , dest = \"add_imports\" , action = \"append\" , help = \"Adds the specified import line to all files, \" \"automatically determining correct placement.\" , ) output_group . add_argument ( \"--append\" , \"--append-only\" , dest = \"append_only\" , action = \"store_true\" , help = \"Only adds the imports specified in --add-import if the file\" \" contains existing imports.\" , ) output_group . add_argument ( \"--af\" , \"--force-adds\" , dest = \"force_adds\" , action = \"store_true\" , help = \"Forces import adds even if the original file is empty.\" , ) output_group . add_argument ( \"--rm\" , \"--remove-import\" , dest = \"remove_imports\" , action = \"append\" , help = \"Removes the specified import from all files.\" , ) output_group . add_argument ( \"--float-to-top\" , dest = \"float_to_top\" , action = \"store_true\" , help = \"Causes all non-indented imports to float to the top of the file having its imports \" \"sorted (immediately below the top of file comment). \\n \" \"This can be an excellent shortcut for collecting imports every once in a while \" \"when you place them in the middle of a file to avoid context switching. \\n\\n \" \"*NOTE*: It currently doesn't work with cimports and introduces some extra over-head \" \"and a performance penalty.\" , ) output_group . add_argument ( \"--dont-float-to-top\" , dest = \"dont_float_to_top\" , action = \"store_true\" , help = \"Forces --float-to-top setting off. See --float-to-top for more information.\" , ) output_group . add_argument ( \"--ca\" , \"--combine-as\" , dest = \"combine_as_imports\" , action = \"store_true\" , help = \"Combines as imports on the same line.\" , ) output_group . add_argument ( \"--cs\" , \"--combine-star\" , dest = \"combine_star\" , action = \"store_true\" , help = \"Ensures that if a star import is present, \" \"nothing else is imported from that namespace.\" , ) output_group . add_argument ( \"-e\" , \"--balanced\" , dest = \"balanced_wrapping\" , action = \"store_true\" , help = \"Balances wrapping to produce the most consistent line length possible\" , ) output_group . add_argument ( \"--ff\" , \"--from-first\" , dest = \"from_first\" , help = \"Switches the typical ordering preference, \" \"showing from imports first then straight ones.\" , ) output_group . add_argument ( \"--fgw\" , \"--force-grid-wrap\" , nargs = \"?\" , const = 2 , type = int , dest = \"force_grid_wrap\" , help = \"Force number of from imports (defaults to 2 when passed as CLI flag without value)\" \"to be grid wrapped regardless of line \" \"length. If 0 is passed in (the global default) only line length is considered.\" , ) output_group . add_argument ( \"-i\" , \"--indent\" , help = 'String to place for indents defaults to \" \" (4 spaces).' , dest = \"indent\" , type = str , ) output_group . add_argument ( \"--lai\" , \"--lines-after-imports\" , dest = \"lines_after_imports\" , type = int ) output_group . add_argument ( \"--lbt\" , \"--lines-between-types\" , dest = \"lines_between_types\" , type = int ) output_group . add_argument ( \"--le\" , \"--line-ending\" , dest = \"line_ending\" , help = \"Forces line endings to the specified value. \" \"If not set, values will be guessed per-file.\" , ) output_group . add_argument ( \"--ls\" , \"--length-sort\" , help = \"Sort imports by their string length.\" , dest = \"length_sort\" , action = \"store_true\" , ) output_group . add_argument ( \"--lss\" , \"--length-sort-straight\" , help = \"Sort straight imports by their string length. Similar to `length_sort` \" \"but applies only to straight imports and doesn't affect from imports.\" , dest = \"length_sort_straight\" , action = \"store_true\" , ) output_group . add_argument ( \"-m\" , \"--multi-line\" , dest = \"multi_line_output\" , choices = list ( WrapModes . __members__ . keys ()) + [ str ( mode . value ) for mode in WrapModes . __members__ . values ()], type = str , help = \"Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, \" \"5-vert-grid-grouped, 6-deprecated-alias-for-5, 7-noqa, \" \"8-vertical-hanging-indent-bracket, 9-vertical-prefix-from-module-import, \" \"10-hanging-indent-with-parentheses).\" , ) output_group . add_argument ( \"-n\" , \"--ensure-newline-before-comments\" , dest = \"ensure_newline_before_comments\" , action = \"store_true\" , help = \"Inserts a blank line before a comment following an import.\" , ) inline_args_group . add_argument ( \"--nis\" , \"--no-inline-sort\" , dest = \"no_inline_sort\" , action = \"store_true\" , help = \"Leaves `from` imports with multiple imports 'as-is' \" \"(e.g. `from foo import a, c ,b`).\" , ) output_group . add_argument ( \"--ot\" , \"--order-by-type\" , dest = \"order_by_type\" , action = \"store_true\" , help = \"Order imports by type, which is determined by case, in addition to alphabetically. \\n \" \" \\n **NOTE**: type here refers to the implied type from the import name capitalization. \\n \" ' isort does not do type introspection for the imports. These \"types\" are simply: ' \"CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8\" \" or a related coding standard and has many imports this is a good default, otherwise you \" \"likely will want to turn it off. From the CLI the `--dont-order-by-type` option will turn \" \"this off.\" , ) output_group . add_argument ( \"--dt\" , \"--dont-order-by-type\" , dest = \"dont_order_by_type\" , action = \"store_true\" , help = \"Don't order imports by type, which is determined by case, in addition to \" \"alphabetically. \\n\\n \" \"**NOTE**: type here refers to the implied type from the import name capitalization. \\n \" ' isort does not do type introspection for the imports. These \"types\" are simply: ' \"CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8\" \" or a related coding standard and has many imports this is a good default. You can turn \" \"this on from the CLI using `--order-by-type`.\" , ) output_group . add_argument ( \"--rr\" , \"--reverse-relative\" , dest = \"reverse_relative\" , action = \"store_true\" , help = \"Reverse order of relative imports.\" , ) inline_args_group . add_argument ( \"--sl\" , \"--force-single-line-imports\" , dest = \"force_single_line\" , action = \"store_true\" , help = \"Forces all from imports to appear on their own line\" , ) output_group . add_argument ( \"--nsl\" , \"--single-line-exclusions\" , help = \"One or more modules to exclude from the single line rule.\" , dest = \"single_line_exclusions\" , action = \"append\" , ) output_group . add_argument ( \"--tc\" , \"--trailing-comma\" , dest = \"include_trailing_comma\" , action = \"store_true\" , help = \"Includes a trailing comma on multi line imports that include parentheses.\" , ) output_group . add_argument ( \"--up\" , \"--use-parentheses\" , dest = \"use_parentheses\" , action = \"store_true\" , help = \"Use parentheses for line continuation on length limit instead of slashes.\" \" **NOTE**: This is separate from wrap modes, and only affects how individual lines that \" \" are too long get continued, not sections of multiple imports.\" , ) output_group . add_argument ( \"-l\" , \"-w\" , \"--line-length\" , \"--line-width\" , help = \"The max length of an import line (used for wrapping long imports).\" , dest = \"line_length\" , type = int , ) output_group . add_argument ( \"--wl\" , \"--wrap-length\" , dest = \"wrap_length\" , type = int , help = \"Specifies how long lines that are wrapped should be, if not set line_length is used.\" \" \\n NOTE: wrap_length must be LOWER than or equal to line_length.\" , ) output_group . add_argument ( \"--case-sensitive\" , dest = \"case_sensitive\" , action = \"store_true\" , help = \"Tells isort to include casing when sorting module names\" , ) output_group . add_argument ( \"--remove-redundant-aliases\" , dest = \"remove_redundant_aliases\" , action = \"store_true\" , help = ( \"Tells isort to remove redundant aliases from imports, such as `import os as os`.\" \" This defaults to `False` simply because some projects use these seemingly useless \" \" aliases to signify intent and change behaviour.\" ), ) output_group . add_argument ( \"--honor-noqa\" , dest = \"honor_noqa\" , action = \"store_true\" , help = \"Tells isort to honor noqa comments to enforce skipping those comments.\" , ) output_group . add_argument ( \"--treat-comment-as-code\" , dest = \"treat_comments_as_code\" , action = \"append\" , help = \"Tells isort to treat the specified single line comment(s) as if they are code.\" , ) output_group . add_argument ( \"--treat-all-comment-as-code\" , dest = \"treat_all_comments_as_code\" , action = \"store_true\" , help = \"Tells isort to treat all single line comments as if they are code.\" , ) output_group . add_argument ( \"--formatter\" , dest = \"formatter\" , type = str , help = \"Specifies the name of a formatting plugin to use when producing output.\" , ) output_group . add_argument ( \"--color\" , dest = \"color_output\" , action = \"store_true\" , help = \"Tells isort to use color in terminal output.\" , ) output_group . add_argument ( \"--ext-format\" , dest = \"ext_format\" , help = \"Tells isort to format the given files according to an extensions formatting rules.\" , ) section_group . add_argument ( \"--sd\" , \"--section-default\" , dest = \"default_section\" , help = \"Sets the default section for import options: \" + str ( sections . DEFAULT ), ) section_group . add_argument ( \"--only-sections\" , \"--os\" , dest = \"only_sections\" , action = \"store_true\" , help = \"Causes imports to be sorted only based on their sections like STDLIB,THIRDPARTY etc. \" \"Imports are unaltered and keep their relative positions within the different sections.\" , ) section_group . add_argument ( \"--ds\" , \"--no-sections\" , help = \"Put all imports into the same section bucket\" , dest = \"no_sections\" , action = \"store_true\" , ) section_group . add_argument ( \"--fas\" , \"--force-alphabetical-sort\" , action = \"store_true\" , dest = \"force_alphabetical_sort\" , help = \"Force all imports to be sorted as a single section\" , ) section_group . add_argument ( \"--fss\" , \"--force-sort-within-sections\" , action = \"store_true\" , dest = \"force_sort_within_sections\" , help = \"Don't sort straight-style imports (like import sys) before from-style imports \" \"(like from itertools import groupby). Instead, sort the imports by module, \" \"independent of import style.\" , ) section_group . add_argument ( \"--hcss\" , \"--honor-case-in-force-sorted-sections\" , action = \"store_true\" , dest = \"honor_case_in_force_sorted_sections\" , help = \"Honor `--case-sensitive` when `--force-sort-within-sections` is being used. \" \"Without this option set, `--order-by-type` decides module name ordering too.\" , ) section_group . add_argument ( \"--fass\" , \"--force-alphabetical-sort-within-sections\" , action = \"store_true\" , dest = \"force_alphabetical_sort_within_sections\" , help = \"Force all imports to be sorted alphabetically within a section\" , ) section_group . add_argument ( \"-t\" , \"--top\" , help = \"Force specific imports to the top of their appropriate section.\" , dest = \"force_to_top\" , action = \"append\" , ) section_group . add_argument ( \"--combine-straight-imports\" , \"--csi\" , dest = \"combine_straight_imports\" , action = \"store_true\" , help = \"Combines all the bare straight imports of the same section in a single line. \" \"Won't work with sections which have 'as' imports\" , ) section_group . add_argument ( \"--nlb\" , \"--no-lines-before\" , help = \"Sections which should not be split with previous by empty lines\" , dest = \"no_lines_before\" , action = \"append\" , ) section_group . add_argument ( \"--src\" , \"--src-path\" , dest = \"src_paths\" , action = \"append\" , help = \"Add an explicitly defined source path \" \"(modules within src paths have their imports automatically categorized as first_party).\" , ) section_group . add_argument ( \"-b\" , \"--builtin\" , dest = \"known_standard_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of Python's standard library.\" , ) section_group . add_argument ( \"--extra-builtin\" , dest = \"extra_standard_library\" , action = \"append\" , help = \"Extra modules to be included in the list of ones in Python's standard library.\" , ) section_group . add_argument ( \"-f\" , \"--future\" , dest = \"known_future_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of Python's internal future compatibility \" \"libraries. WARNING: this overrides the behavior of __future__ handling and therefore\" \" can result in code that can't execute. If you're looking to add dependencies such \" \"as six a better option is to create a another section below --future using custom \" \"sections. See: https://github.com/PyCQA/isort#custom-sections-and-ordering and the \" \"discussion here: https://github.com/PyCQA/isort/issues/1463.\" , ) section_group . add_argument ( \"-o\" , \"--thirdparty\" , dest = \"known_third_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of a third party library.\" , ) section_group . add_argument ( \"-p\" , \"--project\" , dest = \"known_first_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of the current python project.\" , ) section_group . add_argument ( \"--known-local-folder\" , dest = \"known_local_folder\" , action = \"append\" , help = \"Force isort to recognize a module as being a local folder. \" \"Generally, this is reserved for relative imports (from . import module).\" , ) section_group . add_argument ( \"--virtual-env\" , dest = \"virtual_env\" , help = \"Virtual environment to use for determining whether a package is third-party\" , ) section_group . add_argument ( \"--conda-env\" , dest = \"conda_env\" , help = \"Conda environment to use for determining whether a package is third-party\" , ) section_group . add_argument ( \"--py\" , \"--python-version\" , action = \"store\" , dest = \"py_version\" , choices = tuple ( VALID_PY_TARGETS ) + ( \"auto\" ,), help = \"Tells isort to set the known standard library based on the specified Python \" \"version. Default is to assume any Python 3 version could be the target, and use a union \" \"of all stdlib modules across versions. If auto is specified, the version of the \" \"interpreter used to run isort \" f \"(currently: {sys.version_info.major}{sys.version_info.minor}) will be used.\" , ) # deprecated options deprecated_group . add_argument ( \"--recursive\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--recursive\" , help = argparse . SUPPRESS , ) deprecated_group . add_argument ( \"-rc\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"-rc\" , help = argparse . SUPPRESS ) deprecated_group . add_argument ( \"--dont-skip\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--dont-skip\" , help = argparse . SUPPRESS , ) deprecated_group . add_argument ( \"-ns\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"-ns\" , help = argparse . SUPPRESS ) deprecated_group . add_argument ( \"--apply\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--apply\" , help = argparse . SUPPRESS , ) deprecated_group . add_argument ( \"-k\" , \"--keep-direct-and-as\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--keep-direct-and-as\" , help = argparse . SUPPRESS , ) return parser def parse_args ( argv : Optional [ Sequence [ str ]] = None ) -> Dict [ str , Any ]: argv = sys . argv [ 1 :] if argv is None else list ( argv ) remapped_deprecated_args = [] for index , arg in enumerate ( argv ): if arg in DEPRECATED_SINGLE_DASH_ARGS : remapped_deprecated_args . append ( arg ) argv [ index ] = f \"-{arg}\" parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )) . items () if value } if remapped_deprecated_args : arguments [ \"remapped_deprecated_args\" ] = remapped_deprecated_args if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False del arguments [ \"dont_order_by_type\" ] if \"dont_follow_links\" in arguments : arguments [ \"follow_links\" ] = False del arguments [ \"dont_follow_links\" ] if \"dont_float_to_top\" in arguments : del arguments [ \"dont_float_to_top\" ] if arguments . get ( \"float_to_top\" , False ): sys . exit ( \"Can't set both --float-to-top and --dont-float-to-top.\" ) else : arguments [ \"float_to_top\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit (): arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments def _preconvert ( item ): \"\"\"Preconverts objects from native types into JSONifyiable types\"\"\" if isinstance ( item , ( set , frozenset )): return list ( item ) if isinstance ( item , WrapModes ): return item . name if isinstance ( item , Path ): return str ( item ) if callable ( item ) and hasattr ( item , \"__name__\" ): return item . __name__ raise TypeError ( \"Unserializable object {} of type {}\" . format ( item , type ( item ))) def identify_imports_main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : parser = argparse . ArgumentParser ( description = \"Get all import definitions from a given file.\" \"Use `-` as the first argument to represent stdin.\" ) parser . add_argument ( \"files\" , nargs = \"+\" , help = \"One or more Python source files that need their imports sorted.\" ) parser . add_argument ( \"--top-only\" , action = \"store_true\" , default = False , help = \"Only identify imports that occur in before functions or classes.\" , ) target_group = parser . add_argument_group ( \"target options\" ) target_group . add_argument ( \"--follow-links\" , action = \"store_true\" , default = False , help = \"Tells isort to follow symlinks that are encountered when running recursively.\" , ) uniqueness = parser . add_mutually_exclusive_group () uniqueness . add_argument ( \"--unique\" , action = \"store_true\" , default = False , help = \"If true, isort will only identify unique imports.\" , ) uniqueness . add_argument ( \"--packages\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . PACKAGE , default = False , help = \"If true, isort will only identify the unique top level modules imported.\" , ) uniqueness . add_argument ( \"--modules\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . MODULE , default = False , help = \"If true, isort will only identify the unique modules imported.\" , ) uniqueness . add_argument ( \"--attributes\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . ATTRIBUTE , default = False , help = \"If true, isort will only identify the unique attributes imported.\" , ) arguments = parser . parse_args ( argv ) file_names = arguments . files if file_names == [ \"-\" ]: identified_imports = api . find_imports_in_stream ( sys . stdin if stdin is None else stdin , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) else : identified_imports = api . find_imports_in_paths ( file_names , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) for identified_import in identified_imports : if arguments . unique == api . ImportKey . PACKAGE : print ( identified_import . module . split ( \".\" )[ 0 ]) elif arguments . unique == api . ImportKey . MODULE : print ( identified_import . module ) elif arguments . unique == api . ImportKey . ATTRIBUTE : print ( f \"{identified_import.module}.{identified_import.attribute}\" ) else : print ( str ( identified_import )) def main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ): print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) show_files : bool = arguments . pop ( \"show_files\" , False ) if show_config and show_files : sys . exit ( \"Error: either specify show-config or show-files not both.\" ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ]): arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ]) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ]): warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , []) if not file_names and not show_config : print ( QUICK_GUIDE ) if arguments : sys . exit ( \"Error: arguments passed in without any paths or content.\" ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ]): arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ]) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) deprecated_flags = config_dict . pop ( \"deprecated_flags\" , False ) remapped_deprecated_args = config_dict . pop ( \"remapped_deprecated_args\" , False ) stream_filename = config_dict . pop ( \"filename\" , None ) ext_format = config_dict . pop ( \"ext_format\" , None ) wrong_sorted_files = False all_attempt_broken = False no_valid_encodings = False if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ) . resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return if file_names == [ \"-\" ]: file_path = Path ( stream_filename ) if stream_filename else None if show_files : sys . exit ( \"Error: can't show files for streaming input.\" ) if check : incorrectly_sorted = not api . check_stream ( input_stream = sys . stdin if stdin is None else stdin , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) wrong_sorted_files = incorrectly_sorted else : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) else : if stream_filename : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"Filename override is intended only for stream (-) sorting.\" ) sys . exit ( 1 ) skipped : List [ str ] = [] broken : List [ str ] = [] if config . filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )): skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = files . find ( file_names , config , skipped , broken ) if show_files : for file_name in file_names : print ( file_name ) return num_skipped = 0 num_broken = 0 num_invalid_encoding = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , extension = ext_format , ), file_names , ) else : # https://github.com/python/typeshed/pull/2814 attempt_iterator = ( sort_imports ( # type: ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , extension = ext_format , ) for file_name in file_names ) # If any files passed in are missing considered as error, should be removed is_no_attempt = True any_encoding_valid = False for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma: no cover - shouldn't happen, satisfies type constraint incorrectly_sorted = sort_attempt . incorrectly_sorted if arguments . get ( \"check\" , False ) and incorrectly_sorted : wrong_sorted_files = True if sort_attempt . skipped : num_skipped += ( 1 # pragma: no cover - shouldn't happen, due to skip in iter_source_code ) if not sort_attempt . supported_encoding : num_invalid_encoding += 1 else : any_encoding_valid = True is_no_attempt = False num_skipped += len ( skipped ) if num_skipped and not config . quiet : if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) num_broken += len ( broken ) if num_broken and not config . quiet : if config . verbose : for was_broken in broken : warn ( f \"{was_broken} was broken path, make sure it exists correctly\" ) print ( f \"Broken {num_broken} paths\" ) if num_broken > 0 and is_no_attempt : all_attempt_broken = True if num_invalid_encoding > 0 and not any_encoding_valid : no_valid_encodings = True if not config . quiet and ( remapped_deprecated_args or deprecated_flags ): if remapped_deprecated_args : warn ( \"W0502: The following deprecated single dash CLI flags were used and translated: \" f \"{', '.join(remapped_deprecated_args)}!\" ) if deprecated_flags : warn ( \"W0501: The following deprecated CLI flags were used and ignored: \" f \"{', '.join(deprecated_flags)}!\" ) warn ( \"W0500: Please see the 5.0.0 Upgrade guide: \" \"https://pycqa.github.io/isort/docs/upgrade_guides/5.0.0/\" ) if wrong_sorted_files : sys . exit ( 1 ) if all_attempt_broken : sys . exit ( 1 ) if no_valid_encodings : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"No valid encodings.\" ) sys . exit ( 1 ) if __name__ == \"__main__\" : main () Variables ASCII_ART DEPRECATED_SINGLE_DASH_ARGS QUICK_GUIDE VALID_PY_TARGETS profiles Functions identify_imports_main def identify_imports_main ( argv : Union [ Sequence [ str ], NoneType ] = None , stdin : Union [ _io . TextIOWrapper , NoneType ] = None ) -> None View Source def identify_imports_main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : parser = argparse . ArgumentParser ( description = \"Get all import definitions from a given file.\" \"Use `-` as the first argument to represent stdin.\" ) parser . add_argument ( \"files\" , nargs = \"+\" , help = \"One or more Python source files that need their imports sorted.\" ) parser . add_argument ( \"--top-only\" , action = \"store_true\" , default = False , help = \"Only identify imports that occur in before functions or classes.\" , ) target_group = parser . add_argument_group ( \"target options\" ) target_group . add_argument ( \"--follow-links\" , action = \"store_true\" , default = False , help = \"Tells isort to follow symlinks that are encountered when running recursively.\" , ) uniqueness = parser . add_mutually_exclusive_group () uniqueness . add_argument ( \"--unique\" , action = \"store_true\" , default = False , help = \"If true, isort will only identify unique imports.\" , ) uniqueness . add_argument ( \"--packages\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . PACKAGE , default = False , help = \"If true, isort will only identify the unique top level modules imported.\" , ) uniqueness . add_argument ( \"--modules\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . MODULE , default = False , help = \"If true, isort will only identify the unique modules imported.\" , ) uniqueness . add_argument ( \"--attributes\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . ATTRIBUTE , default = False , help = \"If true, isort will only identify the unique attributes imported.\" , ) arguments = parser . parse_args ( argv ) file_names = arguments . files if file_names == [ \"-\" ]: identified_imports = api . find_imports_in_stream ( sys . stdin if stdin is None else stdin , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) else : identified_imports = api . find_imports_in_paths ( file_names , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) for identified_import in identified_imports : if arguments . unique == api . ImportKey . PACKAGE : print ( identified_import . module . split ( \".\" )[ 0 ]) elif arguments . unique == api . ImportKey . MODULE : print ( identified_import . module ) elif arguments . unique == api . ImportKey . ATTRIBUTE : print ( f \"{identified_import.module}.{identified_import.attribute}\" ) else : print ( str ( identified_import )) main def main ( argv : Union [ Sequence [ str ], NoneType ] = None , stdin : Union [ _io . TextIOWrapper , NoneType ] = None ) -> None View Source def main ( argv : Optional [ Sequence[str ] ] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ) : print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) show_files : bool = arguments . pop ( \"show_files\" , False ) if show_config and show_files : sys . exit ( \"Error: either specify show-config or show-files not both.\" ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ] ) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ] ) : warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , [] ) if not file_names and not show_config : print ( QUICK_GUIDE ) if arguments : sys . exit ( \"Error: arguments passed in without any paths or content.\" ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ] ) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) deprecated_flags = config_dict . pop ( \"deprecated_flags\" , False ) remapped_deprecated_args = config_dict . pop ( \"remapped_deprecated_args\" , False ) stream_filename = config_dict . pop ( \"filename\" , None ) ext_format = config_dict . pop ( \"ext_format\" , None ) wrong_sorted_files = False all_attempt_broken = False no_valid_encodings = False if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ). resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return if file_names == [ \"-\" ] : file_path = Path ( stream_filename ) if stream_filename else None if show_files : sys . exit ( \"Error: can't show files for streaming input.\" ) if check : incorrectly_sorted = not api . check_stream ( input_stream = sys . stdin if stdin is None else stdin , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) wrong_sorted_files = incorrectly_sorted else : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) else : if stream_filename : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"Filename override is intended only for stream (-) sorting.\" ) sys . exit ( 1 ) skipped : List [ str ] = [] broken : List [ str ] = [] if config . filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )) : skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = files . find ( file_names , config , skipped , broken ) if show_files : for file_name in file_names : print ( file_name ) return num_skipped = 0 num_broken = 0 num_invalid_encoding = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , extension = ext_format , ), file_names , ) else : # https : // github . com / python / typeshed / pull / 2814 attempt_iterator = ( sort_imports ( # type : ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , extension = ext_format , ) for file_name in file_names ) # If any files passed in are missing considered as error , should be removed is_no_attempt = True any_encoding_valid = False for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma : no cover - shouldn 't happen, satisfies type constraint incorrectly_sorted = sort_attempt.incorrectly_sorted if arguments.get(\"check\", False) and incorrectly_sorted: wrong_sorted_files = True if sort_attempt.skipped: num_skipped += ( 1 # pragma: no cover - shouldn' t happen , due to skip in iter_source_code ) if not sort_attempt . supported_encoding : num_invalid_encoding += 1 else : any_encoding_valid = True is_no_attempt = False num_skipped += len ( skipped ) if num_skipped and not config . quiet : if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) num_broken += len ( broken ) if num_broken and not config . quiet : if config . verbose : for was_broken in broken : warn ( f \"{was_broken} was broken path, make sure it exists correctly\" ) print ( f \"Broken {num_broken} paths\" ) if num_broken > 0 and is_no_attempt : all_attempt_broken = True if num_invalid_encoding > 0 and not any_encoding_valid : no_valid_encodings = True if not config . quiet and ( remapped_deprecated_args or deprecated_flags ) : if remapped_deprecated_args : warn ( \"W0502: The following deprecated single dash CLI flags were used and translated: \" f \"{', '.join(remapped_deprecated_args)}!\" ) if deprecated_flags : warn ( \"W0501: The following deprecated CLI flags were used and ignored: \" f \"{', '.join(deprecated_flags)}!\" ) warn ( \"W0500: Please see the 5.0.0 Upgrade guide: \" \"https://pycqa.github.io/isort/docs/upgrade_guides/5.0.0/\" ) if wrong_sorted_files : sys . exit ( 1 ) if all_attempt_broken : sys . exit ( 1 ) if no_valid_encodings : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"No valid encodings.\" ) sys . exit ( 1 ) parse_args def parse_args ( argv : Union [ Sequence [ str ], NoneType ] = None ) -> Dict [ str , Any ] View Source def parse_args ( argv : Optional [ Sequence[str ] ] = None ) -> Dict [ str, Any ] : argv = sys . argv [ 1: ] if argv is None else list ( argv ) remapped_deprecated_args = [] for index , arg in enumerate ( argv ) : if arg in DEPRECATED_SINGLE_DASH_ARGS : remapped_deprecated_args . append ( arg ) argv [ index ] = f \"-{arg}\" parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )). items () if value } if remapped_deprecated_args : arguments [ \"remapped_deprecated_args\" ] = remapped_deprecated_args if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False del arguments [ \"dont_order_by_type\" ] if \"dont_follow_links\" in arguments : arguments [ \"follow_links\" ] = False del arguments [ \"dont_follow_links\" ] if \"dont_float_to_top\" in arguments : del arguments [ \"dont_float_to_top\" ] if arguments . get ( \"float_to_top\" , False ) : sys . exit ( \"Can't set both --float-to-top and --dont-float-to-top.\" ) else : arguments [ \"float_to_top\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit () : arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments sort_imports def sort_imports ( file_name : str , config : isort . settings . Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any ) -> Union [ isort . main . SortAttempt , NoneType ] View Source def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ] : incorrectly_sorted : bool = False skipped : bool = False try : if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None except UnsupportedEncoding : if config . verbose : warn ( f \"Encoding not supported for {file_name}\" ) return SortAttempt ( incorrectly_sorted , skipped , False ) except ISortError as error : _print_hard_fail ( config , message = str ( error )) sys . exit ( 1 ) except Exception : _print_hard_fail ( config , offending_file = file_name ) raise Classes SortAttempt class SortAttempt ( incorrectly_sorted : bool , skipped : bool , supported_encoding : bool ) View Source class SortAttempt: def __init__ ( self , incorrectly_sorted: bool , skipped: bool , supported_encoding: bool ) -> None: self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped self . supported_encoding = supported_encoding","title":"Main"},{"location":"reference/isort/main/#module-isortmain","text":"Tool for sorting imports alphabetically, and automatically separated into sections. View Source \"\"\"Tool for sorting imports alphabetically, and automatically separated into sections.\"\"\" import argparse import functools import json import os import sys from gettext import gettext as _ from io import TextIOWrapper from pathlib import Path from typing import Any , Dict , List , Optional , Sequence from warnings import warn from . import __version__ , api , files , sections from .exceptions import FileSkipped , ISortError , UnsupportedEncoding from .format import create_terminal_printer from .logo import ASCII_ART from .profiles import profiles from .settings import VALID_PY_TARGETS , Config , WrapModes try : from .setuptools_commands import ISortCommand # noqa: F401 except ImportError : pass DEPRECATED_SINGLE_DASH_ARGS = { \"-ac\" , \"-af\" , \"-ca\" , \"-cs\" , \"-df\" , \"-ds\" , \"-dt\" , \"-fas\" , \"-fass\" , \"-ff\" , \"-fgw\" , \"-fss\" , \"-lai\" , \"-lbt\" , \"-le\" , \"-ls\" , \"-nis\" , \"-nlb\" , \"-ot\" , \"-rr\" , \"-sd\" , \"-sg\" , \"-sl\" , \"-sp\" , \"-tc\" , \"-wl\" , \"-ws\" , } QUICK_GUIDE = f \"\"\" {ASCII_ART} Nothing to do: no files or paths have have been passed in! Try one of the following: `isort .` - sort all Python files, starting from the current directory, recursively. `isort . --interactive` - Do the same, but ask before making any changes. `isort . --check --diff` - Check to see if imports are correctly sorted within this project. `isort --help` - In-depth information about isort's available command-line options. Visit https://pycqa.github.io/isort/ for complete information about how to use isort. \"\"\" class SortAttempt : def __init__ ( self , incorrectly_sorted : bool , skipped : bool , supported_encoding : bool ) -> None : self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped self . supported_encoding = supported_encoding def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ]: incorrectly_sorted : bool = False skipped : bool = False try : if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None except UnsupportedEncoding : if config . verbose : warn ( f \"Encoding not supported for {file_name}\" ) return SortAttempt ( incorrectly_sorted , skipped , False ) except ISortError as error : _print_hard_fail ( config , message = str ( error )) sys . exit ( 1 ) except Exception : _print_hard_fail ( config , offending_file = file_name ) raise def _print_hard_fail ( config : Config , offending_file : Optional [ str ] = None , message : Optional [ str ] = None ) -> None : \"\"\"Fail on unrecoverable exception with custom message.\"\"\" message = message or ( f \"Unrecoverable exception thrown when parsing {offending_file or ''}!\" \"This should NEVER happen. \\n \" \"If encountered, please open an issue: https://github.com/PyCQA/isort/issues/new\" ) printer = create_terminal_printer ( color = config . color_output ) printer . error ( message ) def _build_arg_parser () -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( description = \"Sort Python import definitions alphabetically \" \"within logical sections. Run with no arguments to see a quick \" \"start guide, otherwise, one or more files/directories/stdin must be provided. \" \"Use `-` as the first argument to represent stdin. Use --interactive to use the pre 5.0.0 \" \"interactive behavior.\" \" \" \"If you've used isort 4 but are new to isort 5, see the upgrading guide:\" \"https://pycqa.github.io/isort/docs/upgrade_guides/5.0.0/.\" , add_help = False , # prevent help option from appearing in \"optional arguments\" group ) general_group = parser . add_argument_group ( \"general options\" ) target_group = parser . add_argument_group ( \"target options\" ) output_group = parser . add_argument_group ( \"general output options\" ) inline_args_group = output_group . add_mutually_exclusive_group () section_group = parser . add_argument_group ( \"section output options\" ) deprecated_group = parser . add_argument_group ( \"deprecated options\" ) general_group . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = _ ( \"show this help message and exit\" ), ) general_group . add_argument ( \"-V\" , \"--version\" , action = \"store_true\" , dest = \"show_version\" , help = \"Displays the currently installed version of isort.\" , ) general_group . add_argument ( \"--vn\" , \"--version-number\" , action = \"version\" , version = __version__ , help = \"Returns just the current version number without the logo\" , ) general_group . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , dest = \"verbose\" , help = \"Shows verbose output, such as when files are skipped or when a check is successful.\" , ) general_group . add_argument ( \"--only-modified\" , \"--om\" , dest = \"only_modified\" , action = \"store_true\" , help = \"Suppresses verbose output for non-modified files.\" , ) general_group . add_argument ( \"--dedup-headings\" , dest = \"dedup_headings\" , action = \"store_true\" , help = \"Tells isort to only show an identical custom import heading comment once, even if\" \" there are multiple sections with the comment set.\" , ) general_group . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , dest = \"quiet\" , help = \"Shows extra quiet output, only errors are outputted.\" , ) general_group . add_argument ( \"-d\" , \"--stdout\" , help = \"Force resulting output to stdout, instead of in-place.\" , dest = \"write_to_stdout\" , action = \"store_true\" , ) general_group . add_argument ( \"--show-config\" , dest = \"show_config\" , action = \"store_true\" , help = \"See isort's determined config, as well as sources of config options.\" , ) general_group . add_argument ( \"--show-files\" , dest = \"show_files\" , action = \"store_true\" , help = \"See the files isort will be ran against with the current config options.\" , ) general_group . add_argument ( \"--df\" , \"--diff\" , dest = \"show_diff\" , action = \"store_true\" , help = \"Prints a diff of all the changes isort would make to a file, instead of \" \"changing it in place\" , ) general_group . add_argument ( \"-c\" , \"--check-only\" , \"--check\" , action = \"store_true\" , dest = \"check\" , help = \"Checks the file for unsorted / unformatted imports and prints them to the \" \"command line without modifying the file. Returns 0 when nothing would change and \" \"returns 1 when the file would be reformatted.\" , ) general_group . add_argument ( \"--ws\" , \"--ignore-whitespace\" , action = \"store_true\" , dest = \"ignore_whitespace\" , help = \"Tells isort to ignore whitespace differences when --check-only is being used.\" , ) general_group . add_argument ( \"--sp\" , \"--settings-path\" , \"--settings-file\" , \"--settings\" , dest = \"settings_path\" , help = \"Explicitly set the settings path or file instead of auto determining \" \"based on file location.\" , ) general_group . add_argument ( \"--profile\" , dest = \"profile\" , type = str , help = \"Base profile type to use for configuration. \" f \"Profiles include: {', '.join(profiles.keys())}. As well as any shared profiles.\" , ) general_group . add_argument ( \"--old-finders\" , \"--magic-placement\" , dest = \"old_finders\" , action = \"store_true\" , help = \"Use the old deprecated finder logic that relies on environment introspection magic.\" , ) general_group . add_argument ( \"-j\" , \"--jobs\" , help = \"Number of files to process in parallel.\" , dest = \"jobs\" , type = int ) general_group . add_argument ( \"--ac\" , \"--atomic\" , dest = \"atomic\" , action = \"store_true\" , help = \"Ensures the output doesn't save if the resulting file contains syntax errors.\" , ) general_group . add_argument ( \"--interactive\" , dest = \"ask_to_apply\" , action = \"store_true\" , help = \"Tells isort to apply changes interactively.\" , ) target_group . add_argument ( \"files\" , nargs = \"*\" , help = \"One or more Python source files that need their imports sorted.\" ) target_group . add_argument ( \"--filter-files\" , dest = \"filter_files\" , action = \"store_true\" , help = \"Tells isort to filter files even when they are explicitly passed in as \" \"part of the CLI command.\" , ) target_group . add_argument ( \"-s\" , \"--skip\" , help = \"Files that sort imports should skip over. If you want to skip multiple \" \"files you should specify twice: --skip file1 --skip file2.\" , dest = \"skip\" , action = \"append\" , ) target_group . add_argument ( \"--sg\" , \"--skip-glob\" , help = \"Files that sort imports should skip over.\" , dest = \"skip_glob\" , action = \"append\" , ) target_group . add_argument ( \"--gitignore\" , \"--skip-gitignore\" , action = \"store_true\" , dest = \"skip_gitignore\" , help = \"Treat project as a git repository and ignore files listed in .gitignore\" , ) target_group . add_argument ( \"--ext\" , \"--extension\" , \"--supported-extension\" , dest = \"supported_extensions\" , action = \"append\" , help = \"Specifies what extensions isort can be ran against.\" , ) target_group . add_argument ( \"--blocked-extension\" , dest = \"blocked_extensions\" , action = \"append\" , help = \"Specifies what extensions isort can never be ran against.\" , ) target_group . add_argument ( \"--dont-follow-links\" , dest = \"dont_follow_links\" , action = \"store_true\" , help = \"Tells isort not to follow symlinks that are encountered when running recursively.\" , ) target_group . add_argument ( \"--filename\" , dest = \"filename\" , help = \"Provide the filename associated with a stream.\" , ) output_group . add_argument ( \"-a\" , \"--add-import\" , dest = \"add_imports\" , action = \"append\" , help = \"Adds the specified import line to all files, \" \"automatically determining correct placement.\" , ) output_group . add_argument ( \"--append\" , \"--append-only\" , dest = \"append_only\" , action = \"store_true\" , help = \"Only adds the imports specified in --add-import if the file\" \" contains existing imports.\" , ) output_group . add_argument ( \"--af\" , \"--force-adds\" , dest = \"force_adds\" , action = \"store_true\" , help = \"Forces import adds even if the original file is empty.\" , ) output_group . add_argument ( \"--rm\" , \"--remove-import\" , dest = \"remove_imports\" , action = \"append\" , help = \"Removes the specified import from all files.\" , ) output_group . add_argument ( \"--float-to-top\" , dest = \"float_to_top\" , action = \"store_true\" , help = \"Causes all non-indented imports to float to the top of the file having its imports \" \"sorted (immediately below the top of file comment). \\n \" \"This can be an excellent shortcut for collecting imports every once in a while \" \"when you place them in the middle of a file to avoid context switching. \\n\\n \" \"*NOTE*: It currently doesn't work with cimports and introduces some extra over-head \" \"and a performance penalty.\" , ) output_group . add_argument ( \"--dont-float-to-top\" , dest = \"dont_float_to_top\" , action = \"store_true\" , help = \"Forces --float-to-top setting off. See --float-to-top for more information.\" , ) output_group . add_argument ( \"--ca\" , \"--combine-as\" , dest = \"combine_as_imports\" , action = \"store_true\" , help = \"Combines as imports on the same line.\" , ) output_group . add_argument ( \"--cs\" , \"--combine-star\" , dest = \"combine_star\" , action = \"store_true\" , help = \"Ensures that if a star import is present, \" \"nothing else is imported from that namespace.\" , ) output_group . add_argument ( \"-e\" , \"--balanced\" , dest = \"balanced_wrapping\" , action = \"store_true\" , help = \"Balances wrapping to produce the most consistent line length possible\" , ) output_group . add_argument ( \"--ff\" , \"--from-first\" , dest = \"from_first\" , help = \"Switches the typical ordering preference, \" \"showing from imports first then straight ones.\" , ) output_group . add_argument ( \"--fgw\" , \"--force-grid-wrap\" , nargs = \"?\" , const = 2 , type = int , dest = \"force_grid_wrap\" , help = \"Force number of from imports (defaults to 2 when passed as CLI flag without value)\" \"to be grid wrapped regardless of line \" \"length. If 0 is passed in (the global default) only line length is considered.\" , ) output_group . add_argument ( \"-i\" , \"--indent\" , help = 'String to place for indents defaults to \" \" (4 spaces).' , dest = \"indent\" , type = str , ) output_group . add_argument ( \"--lai\" , \"--lines-after-imports\" , dest = \"lines_after_imports\" , type = int ) output_group . add_argument ( \"--lbt\" , \"--lines-between-types\" , dest = \"lines_between_types\" , type = int ) output_group . add_argument ( \"--le\" , \"--line-ending\" , dest = \"line_ending\" , help = \"Forces line endings to the specified value. \" \"If not set, values will be guessed per-file.\" , ) output_group . add_argument ( \"--ls\" , \"--length-sort\" , help = \"Sort imports by their string length.\" , dest = \"length_sort\" , action = \"store_true\" , ) output_group . add_argument ( \"--lss\" , \"--length-sort-straight\" , help = \"Sort straight imports by their string length. Similar to `length_sort` \" \"but applies only to straight imports and doesn't affect from imports.\" , dest = \"length_sort_straight\" , action = \"store_true\" , ) output_group . add_argument ( \"-m\" , \"--multi-line\" , dest = \"multi_line_output\" , choices = list ( WrapModes . __members__ . keys ()) + [ str ( mode . value ) for mode in WrapModes . __members__ . values ()], type = str , help = \"Multi line output (0-grid, 1-vertical, 2-hanging, 3-vert-hanging, 4-vert-grid, \" \"5-vert-grid-grouped, 6-deprecated-alias-for-5, 7-noqa, \" \"8-vertical-hanging-indent-bracket, 9-vertical-prefix-from-module-import, \" \"10-hanging-indent-with-parentheses).\" , ) output_group . add_argument ( \"-n\" , \"--ensure-newline-before-comments\" , dest = \"ensure_newline_before_comments\" , action = \"store_true\" , help = \"Inserts a blank line before a comment following an import.\" , ) inline_args_group . add_argument ( \"--nis\" , \"--no-inline-sort\" , dest = \"no_inline_sort\" , action = \"store_true\" , help = \"Leaves `from` imports with multiple imports 'as-is' \" \"(e.g. `from foo import a, c ,b`).\" , ) output_group . add_argument ( \"--ot\" , \"--order-by-type\" , dest = \"order_by_type\" , action = \"store_true\" , help = \"Order imports by type, which is determined by case, in addition to alphabetically. \\n \" \" \\n **NOTE**: type here refers to the implied type from the import name capitalization. \\n \" ' isort does not do type introspection for the imports. These \"types\" are simply: ' \"CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8\" \" or a related coding standard and has many imports this is a good default, otherwise you \" \"likely will want to turn it off. From the CLI the `--dont-order-by-type` option will turn \" \"this off.\" , ) output_group . add_argument ( \"--dt\" , \"--dont-order-by-type\" , dest = \"dont_order_by_type\" , action = \"store_true\" , help = \"Don't order imports by type, which is determined by case, in addition to \" \"alphabetically. \\n\\n \" \"**NOTE**: type here refers to the implied type from the import name capitalization. \\n \" ' isort does not do type introspection for the imports. These \"types\" are simply: ' \"CONSTANT_VARIABLE, CamelCaseClass, variable_or_function. If your project follows PEP8\" \" or a related coding standard and has many imports this is a good default. You can turn \" \"this on from the CLI using `--order-by-type`.\" , ) output_group . add_argument ( \"--rr\" , \"--reverse-relative\" , dest = \"reverse_relative\" , action = \"store_true\" , help = \"Reverse order of relative imports.\" , ) inline_args_group . add_argument ( \"--sl\" , \"--force-single-line-imports\" , dest = \"force_single_line\" , action = \"store_true\" , help = \"Forces all from imports to appear on their own line\" , ) output_group . add_argument ( \"--nsl\" , \"--single-line-exclusions\" , help = \"One or more modules to exclude from the single line rule.\" , dest = \"single_line_exclusions\" , action = \"append\" , ) output_group . add_argument ( \"--tc\" , \"--trailing-comma\" , dest = \"include_trailing_comma\" , action = \"store_true\" , help = \"Includes a trailing comma on multi line imports that include parentheses.\" , ) output_group . add_argument ( \"--up\" , \"--use-parentheses\" , dest = \"use_parentheses\" , action = \"store_true\" , help = \"Use parentheses for line continuation on length limit instead of slashes.\" \" **NOTE**: This is separate from wrap modes, and only affects how individual lines that \" \" are too long get continued, not sections of multiple imports.\" , ) output_group . add_argument ( \"-l\" , \"-w\" , \"--line-length\" , \"--line-width\" , help = \"The max length of an import line (used for wrapping long imports).\" , dest = \"line_length\" , type = int , ) output_group . add_argument ( \"--wl\" , \"--wrap-length\" , dest = \"wrap_length\" , type = int , help = \"Specifies how long lines that are wrapped should be, if not set line_length is used.\" \" \\n NOTE: wrap_length must be LOWER than or equal to line_length.\" , ) output_group . add_argument ( \"--case-sensitive\" , dest = \"case_sensitive\" , action = \"store_true\" , help = \"Tells isort to include casing when sorting module names\" , ) output_group . add_argument ( \"--remove-redundant-aliases\" , dest = \"remove_redundant_aliases\" , action = \"store_true\" , help = ( \"Tells isort to remove redundant aliases from imports, such as `import os as os`.\" \" This defaults to `False` simply because some projects use these seemingly useless \" \" aliases to signify intent and change behaviour.\" ), ) output_group . add_argument ( \"--honor-noqa\" , dest = \"honor_noqa\" , action = \"store_true\" , help = \"Tells isort to honor noqa comments to enforce skipping those comments.\" , ) output_group . add_argument ( \"--treat-comment-as-code\" , dest = \"treat_comments_as_code\" , action = \"append\" , help = \"Tells isort to treat the specified single line comment(s) as if they are code.\" , ) output_group . add_argument ( \"--treat-all-comment-as-code\" , dest = \"treat_all_comments_as_code\" , action = \"store_true\" , help = \"Tells isort to treat all single line comments as if they are code.\" , ) output_group . add_argument ( \"--formatter\" , dest = \"formatter\" , type = str , help = \"Specifies the name of a formatting plugin to use when producing output.\" , ) output_group . add_argument ( \"--color\" , dest = \"color_output\" , action = \"store_true\" , help = \"Tells isort to use color in terminal output.\" , ) output_group . add_argument ( \"--ext-format\" , dest = \"ext_format\" , help = \"Tells isort to format the given files according to an extensions formatting rules.\" , ) section_group . add_argument ( \"--sd\" , \"--section-default\" , dest = \"default_section\" , help = \"Sets the default section for import options: \" + str ( sections . DEFAULT ), ) section_group . add_argument ( \"--only-sections\" , \"--os\" , dest = \"only_sections\" , action = \"store_true\" , help = \"Causes imports to be sorted only based on their sections like STDLIB,THIRDPARTY etc. \" \"Imports are unaltered and keep their relative positions within the different sections.\" , ) section_group . add_argument ( \"--ds\" , \"--no-sections\" , help = \"Put all imports into the same section bucket\" , dest = \"no_sections\" , action = \"store_true\" , ) section_group . add_argument ( \"--fas\" , \"--force-alphabetical-sort\" , action = \"store_true\" , dest = \"force_alphabetical_sort\" , help = \"Force all imports to be sorted as a single section\" , ) section_group . add_argument ( \"--fss\" , \"--force-sort-within-sections\" , action = \"store_true\" , dest = \"force_sort_within_sections\" , help = \"Don't sort straight-style imports (like import sys) before from-style imports \" \"(like from itertools import groupby). Instead, sort the imports by module, \" \"independent of import style.\" , ) section_group . add_argument ( \"--hcss\" , \"--honor-case-in-force-sorted-sections\" , action = \"store_true\" , dest = \"honor_case_in_force_sorted_sections\" , help = \"Honor `--case-sensitive` when `--force-sort-within-sections` is being used. \" \"Without this option set, `--order-by-type` decides module name ordering too.\" , ) section_group . add_argument ( \"--fass\" , \"--force-alphabetical-sort-within-sections\" , action = \"store_true\" , dest = \"force_alphabetical_sort_within_sections\" , help = \"Force all imports to be sorted alphabetically within a section\" , ) section_group . add_argument ( \"-t\" , \"--top\" , help = \"Force specific imports to the top of their appropriate section.\" , dest = \"force_to_top\" , action = \"append\" , ) section_group . add_argument ( \"--combine-straight-imports\" , \"--csi\" , dest = \"combine_straight_imports\" , action = \"store_true\" , help = \"Combines all the bare straight imports of the same section in a single line. \" \"Won't work with sections which have 'as' imports\" , ) section_group . add_argument ( \"--nlb\" , \"--no-lines-before\" , help = \"Sections which should not be split with previous by empty lines\" , dest = \"no_lines_before\" , action = \"append\" , ) section_group . add_argument ( \"--src\" , \"--src-path\" , dest = \"src_paths\" , action = \"append\" , help = \"Add an explicitly defined source path \" \"(modules within src paths have their imports automatically categorized as first_party).\" , ) section_group . add_argument ( \"-b\" , \"--builtin\" , dest = \"known_standard_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of Python's standard library.\" , ) section_group . add_argument ( \"--extra-builtin\" , dest = \"extra_standard_library\" , action = \"append\" , help = \"Extra modules to be included in the list of ones in Python's standard library.\" , ) section_group . add_argument ( \"-f\" , \"--future\" , dest = \"known_future_library\" , action = \"append\" , help = \"Force isort to recognize a module as part of Python's internal future compatibility \" \"libraries. WARNING: this overrides the behavior of __future__ handling and therefore\" \" can result in code that can't execute. If you're looking to add dependencies such \" \"as six a better option is to create a another section below --future using custom \" \"sections. See: https://github.com/PyCQA/isort#custom-sections-and-ordering and the \" \"discussion here: https://github.com/PyCQA/isort/issues/1463.\" , ) section_group . add_argument ( \"-o\" , \"--thirdparty\" , dest = \"known_third_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of a third party library.\" , ) section_group . add_argument ( \"-p\" , \"--project\" , dest = \"known_first_party\" , action = \"append\" , help = \"Force isort to recognize a module as being part of the current python project.\" , ) section_group . add_argument ( \"--known-local-folder\" , dest = \"known_local_folder\" , action = \"append\" , help = \"Force isort to recognize a module as being a local folder. \" \"Generally, this is reserved for relative imports (from . import module).\" , ) section_group . add_argument ( \"--virtual-env\" , dest = \"virtual_env\" , help = \"Virtual environment to use for determining whether a package is third-party\" , ) section_group . add_argument ( \"--conda-env\" , dest = \"conda_env\" , help = \"Conda environment to use for determining whether a package is third-party\" , ) section_group . add_argument ( \"--py\" , \"--python-version\" , action = \"store\" , dest = \"py_version\" , choices = tuple ( VALID_PY_TARGETS ) + ( \"auto\" ,), help = \"Tells isort to set the known standard library based on the specified Python \" \"version. Default is to assume any Python 3 version could be the target, and use a union \" \"of all stdlib modules across versions. If auto is specified, the version of the \" \"interpreter used to run isort \" f \"(currently: {sys.version_info.major}{sys.version_info.minor}) will be used.\" , ) # deprecated options deprecated_group . add_argument ( \"--recursive\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--recursive\" , help = argparse . SUPPRESS , ) deprecated_group . add_argument ( \"-rc\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"-rc\" , help = argparse . SUPPRESS ) deprecated_group . add_argument ( \"--dont-skip\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--dont-skip\" , help = argparse . SUPPRESS , ) deprecated_group . add_argument ( \"-ns\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"-ns\" , help = argparse . SUPPRESS ) deprecated_group . add_argument ( \"--apply\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--apply\" , help = argparse . SUPPRESS , ) deprecated_group . add_argument ( \"-k\" , \"--keep-direct-and-as\" , dest = \"deprecated_flags\" , action = \"append_const\" , const = \"--keep-direct-and-as\" , help = argparse . SUPPRESS , ) return parser def parse_args ( argv : Optional [ Sequence [ str ]] = None ) -> Dict [ str , Any ]: argv = sys . argv [ 1 :] if argv is None else list ( argv ) remapped_deprecated_args = [] for index , arg in enumerate ( argv ): if arg in DEPRECATED_SINGLE_DASH_ARGS : remapped_deprecated_args . append ( arg ) argv [ index ] = f \"-{arg}\" parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )) . items () if value } if remapped_deprecated_args : arguments [ \"remapped_deprecated_args\" ] = remapped_deprecated_args if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False del arguments [ \"dont_order_by_type\" ] if \"dont_follow_links\" in arguments : arguments [ \"follow_links\" ] = False del arguments [ \"dont_follow_links\" ] if \"dont_float_to_top\" in arguments : del arguments [ \"dont_float_to_top\" ] if arguments . get ( \"float_to_top\" , False ): sys . exit ( \"Can't set both --float-to-top and --dont-float-to-top.\" ) else : arguments [ \"float_to_top\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit (): arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments def _preconvert ( item ): \"\"\"Preconverts objects from native types into JSONifyiable types\"\"\" if isinstance ( item , ( set , frozenset )): return list ( item ) if isinstance ( item , WrapModes ): return item . name if isinstance ( item , Path ): return str ( item ) if callable ( item ) and hasattr ( item , \"__name__\" ): return item . __name__ raise TypeError ( \"Unserializable object {} of type {}\" . format ( item , type ( item ))) def identify_imports_main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : parser = argparse . ArgumentParser ( description = \"Get all import definitions from a given file.\" \"Use `-` as the first argument to represent stdin.\" ) parser . add_argument ( \"files\" , nargs = \"+\" , help = \"One or more Python source files that need their imports sorted.\" ) parser . add_argument ( \"--top-only\" , action = \"store_true\" , default = False , help = \"Only identify imports that occur in before functions or classes.\" , ) target_group = parser . add_argument_group ( \"target options\" ) target_group . add_argument ( \"--follow-links\" , action = \"store_true\" , default = False , help = \"Tells isort to follow symlinks that are encountered when running recursively.\" , ) uniqueness = parser . add_mutually_exclusive_group () uniqueness . add_argument ( \"--unique\" , action = \"store_true\" , default = False , help = \"If true, isort will only identify unique imports.\" , ) uniqueness . add_argument ( \"--packages\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . PACKAGE , default = False , help = \"If true, isort will only identify the unique top level modules imported.\" , ) uniqueness . add_argument ( \"--modules\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . MODULE , default = False , help = \"If true, isort will only identify the unique modules imported.\" , ) uniqueness . add_argument ( \"--attributes\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . ATTRIBUTE , default = False , help = \"If true, isort will only identify the unique attributes imported.\" , ) arguments = parser . parse_args ( argv ) file_names = arguments . files if file_names == [ \"-\" ]: identified_imports = api . find_imports_in_stream ( sys . stdin if stdin is None else stdin , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) else : identified_imports = api . find_imports_in_paths ( file_names , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) for identified_import in identified_imports : if arguments . unique == api . ImportKey . PACKAGE : print ( identified_import . module . split ( \".\" )[ 0 ]) elif arguments . unique == api . ImportKey . MODULE : print ( identified_import . module ) elif arguments . unique == api . ImportKey . ATTRIBUTE : print ( f \"{identified_import.module}.{identified_import.attribute}\" ) else : print ( str ( identified_import )) def main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ): print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) show_files : bool = arguments . pop ( \"show_files\" , False ) if show_config and show_files : sys . exit ( \"Error: either specify show-config or show-files not both.\" ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ]): arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ]) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ]) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ]): warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , []) if not file_names and not show_config : print ( QUICK_GUIDE ) if arguments : sys . exit ( \"Error: arguments passed in without any paths or content.\" ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ]): arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ]) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) deprecated_flags = config_dict . pop ( \"deprecated_flags\" , False ) remapped_deprecated_args = config_dict . pop ( \"remapped_deprecated_args\" , False ) stream_filename = config_dict . pop ( \"filename\" , None ) ext_format = config_dict . pop ( \"ext_format\" , None ) wrong_sorted_files = False all_attempt_broken = False no_valid_encodings = False if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ) . resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return if file_names == [ \"-\" ]: file_path = Path ( stream_filename ) if stream_filename else None if show_files : sys . exit ( \"Error: can't show files for streaming input.\" ) if check : incorrectly_sorted = not api . check_stream ( input_stream = sys . stdin if stdin is None else stdin , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) wrong_sorted_files = incorrectly_sorted else : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) else : if stream_filename : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"Filename override is intended only for stream (-) sorting.\" ) sys . exit ( 1 ) skipped : List [ str ] = [] broken : List [ str ] = [] if config . filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )): skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = files . find ( file_names , config , skipped , broken ) if show_files : for file_name in file_names : print ( file_name ) return num_skipped = 0 num_broken = 0 num_invalid_encoding = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , extension = ext_format , ), file_names , ) else : # https://github.com/python/typeshed/pull/2814 attempt_iterator = ( sort_imports ( # type: ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , extension = ext_format , ) for file_name in file_names ) # If any files passed in are missing considered as error, should be removed is_no_attempt = True any_encoding_valid = False for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma: no cover - shouldn't happen, satisfies type constraint incorrectly_sorted = sort_attempt . incorrectly_sorted if arguments . get ( \"check\" , False ) and incorrectly_sorted : wrong_sorted_files = True if sort_attempt . skipped : num_skipped += ( 1 # pragma: no cover - shouldn't happen, due to skip in iter_source_code ) if not sort_attempt . supported_encoding : num_invalid_encoding += 1 else : any_encoding_valid = True is_no_attempt = False num_skipped += len ( skipped ) if num_skipped and not config . quiet : if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) num_broken += len ( broken ) if num_broken and not config . quiet : if config . verbose : for was_broken in broken : warn ( f \"{was_broken} was broken path, make sure it exists correctly\" ) print ( f \"Broken {num_broken} paths\" ) if num_broken > 0 and is_no_attempt : all_attempt_broken = True if num_invalid_encoding > 0 and not any_encoding_valid : no_valid_encodings = True if not config . quiet and ( remapped_deprecated_args or deprecated_flags ): if remapped_deprecated_args : warn ( \"W0502: The following deprecated single dash CLI flags were used and translated: \" f \"{', '.join(remapped_deprecated_args)}!\" ) if deprecated_flags : warn ( \"W0501: The following deprecated CLI flags were used and ignored: \" f \"{', '.join(deprecated_flags)}!\" ) warn ( \"W0500: Please see the 5.0.0 Upgrade guide: \" \"https://pycqa.github.io/isort/docs/upgrade_guides/5.0.0/\" ) if wrong_sorted_files : sys . exit ( 1 ) if all_attempt_broken : sys . exit ( 1 ) if no_valid_encodings : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"No valid encodings.\" ) sys . exit ( 1 ) if __name__ == \"__main__\" : main ()","title":"Module isort.main"},{"location":"reference/isort/main/#variables","text":"ASCII_ART DEPRECATED_SINGLE_DASH_ARGS QUICK_GUIDE VALID_PY_TARGETS profiles","title":"Variables"},{"location":"reference/isort/main/#functions","text":"","title":"Functions"},{"location":"reference/isort/main/#identify_imports_main","text":"def identify_imports_main ( argv : Union [ Sequence [ str ], NoneType ] = None , stdin : Union [ _io . TextIOWrapper , NoneType ] = None ) -> None View Source def identify_imports_main ( argv : Optional [ Sequence [ str ]] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : parser = argparse . ArgumentParser ( description = \"Get all import definitions from a given file.\" \"Use `-` as the first argument to represent stdin.\" ) parser . add_argument ( \"files\" , nargs = \"+\" , help = \"One or more Python source files that need their imports sorted.\" ) parser . add_argument ( \"--top-only\" , action = \"store_true\" , default = False , help = \"Only identify imports that occur in before functions or classes.\" , ) target_group = parser . add_argument_group ( \"target options\" ) target_group . add_argument ( \"--follow-links\" , action = \"store_true\" , default = False , help = \"Tells isort to follow symlinks that are encountered when running recursively.\" , ) uniqueness = parser . add_mutually_exclusive_group () uniqueness . add_argument ( \"--unique\" , action = \"store_true\" , default = False , help = \"If true, isort will only identify unique imports.\" , ) uniqueness . add_argument ( \"--packages\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . PACKAGE , default = False , help = \"If true, isort will only identify the unique top level modules imported.\" , ) uniqueness . add_argument ( \"--modules\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . MODULE , default = False , help = \"If true, isort will only identify the unique modules imported.\" , ) uniqueness . add_argument ( \"--attributes\" , dest = \"unique\" , action = \"store_const\" , const = api . ImportKey . ATTRIBUTE , default = False , help = \"If true, isort will only identify the unique attributes imported.\" , ) arguments = parser . parse_args ( argv ) file_names = arguments . files if file_names == [ \"-\" ]: identified_imports = api . find_imports_in_stream ( sys . stdin if stdin is None else stdin , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) else : identified_imports = api . find_imports_in_paths ( file_names , unique = arguments . unique , top_only = arguments . top_only , follow_links = arguments . follow_links , ) for identified_import in identified_imports : if arguments . unique == api . ImportKey . PACKAGE : print ( identified_import . module . split ( \".\" )[ 0 ]) elif arguments . unique == api . ImportKey . MODULE : print ( identified_import . module ) elif arguments . unique == api . ImportKey . ATTRIBUTE : print ( f \"{identified_import.module}.{identified_import.attribute}\" ) else : print ( str ( identified_import ))","title":"identify_imports_main"},{"location":"reference/isort/main/#main","text":"def main ( argv : Union [ Sequence [ str ], NoneType ] = None , stdin : Union [ _io . TextIOWrapper , NoneType ] = None ) -> None View Source def main ( argv : Optional [ Sequence[str ] ] = None , stdin : Optional [ TextIOWrapper ] = None ) -> None : arguments = parse_args ( argv ) if arguments . get ( \"show_version\" ) : print ( ASCII_ART ) return show_config : bool = arguments . pop ( \"show_config\" , False ) show_files : bool = arguments . pop ( \"show_files\" , False ) if show_config and show_files : sys . exit ( \"Error: either specify show-config or show-files not both.\" ) if \"settings_path\" in arguments : if os . path . isfile ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_file\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_file\" ] ) else : arguments [ \"settings_path\" ] = os . path . abspath ( arguments [ \"settings_path\" ] ) if \"virtual_env\" in arguments : venv = arguments [ \"virtual_env\" ] arguments [ \"virtual_env\" ] = os . path . abspath ( venv ) if not os . path . isdir ( arguments [ \"virtual_env\" ] ) : warn ( f \"virtual_env dir does not exist: {arguments['virtual_env']}\" ) file_names = arguments . pop ( \"files\" , [] ) if not file_names and not show_config : print ( QUICK_GUIDE ) if arguments : sys . exit ( \"Error: arguments passed in without any paths or content.\" ) return if \"settings_path\" not in arguments : arguments [ \"settings_path\" ] = ( os . path . abspath ( file_names [ 0 ] if file_names else \".\" ) or os . getcwd () ) if not os . path . isdir ( arguments [ \"settings_path\" ] ) : arguments [ \"settings_path\" ] = os . path . dirname ( arguments [ \"settings_path\" ] ) config_dict = arguments . copy () ask_to_apply = config_dict . pop ( \"ask_to_apply\" , False ) jobs = config_dict . pop ( \"jobs\" , ()) check = config_dict . pop ( \"check\" , False ) show_diff = config_dict . pop ( \"show_diff\" , False ) write_to_stdout = config_dict . pop ( \"write_to_stdout\" , False ) deprecated_flags = config_dict . pop ( \"deprecated_flags\" , False ) remapped_deprecated_args = config_dict . pop ( \"remapped_deprecated_args\" , False ) stream_filename = config_dict . pop ( \"filename\" , None ) ext_format = config_dict . pop ( \"ext_format\" , None ) wrong_sorted_files = False all_attempt_broken = False no_valid_encodings = False if \"src_paths\" in config_dict : config_dict [ \"src_paths\" ] = { Path ( src_path ). resolve () for src_path in config_dict . get ( \"src_paths\" , ()) } config = Config ( ** config_dict ) if show_config : print ( json . dumps ( config . __dict__ , indent = 4 , separators = ( \",\" , \": \" ), default = _preconvert )) return if file_names == [ \"-\" ] : file_path = Path ( stream_filename ) if stream_filename else None if show_files : sys . exit ( \"Error: can't show files for streaming input.\" ) if check : incorrectly_sorted = not api . check_stream ( input_stream = sys . stdin if stdin is None else stdin , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) wrong_sorted_files = incorrectly_sorted else : api . sort_stream ( input_stream = sys . stdin if stdin is None else stdin , output_stream = sys . stdout , config = config , show_diff = show_diff , file_path = file_path , extension = ext_format , ) else : if stream_filename : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"Filename override is intended only for stream (-) sorting.\" ) sys . exit ( 1 ) skipped : List [ str ] = [] broken : List [ str ] = [] if config . filter_files : filtered_files = [] for file_name in file_names : if config . is_skipped ( Path ( file_name )) : skipped . append ( file_name ) else : filtered_files . append ( file_name ) file_names = filtered_files file_names = files . find ( file_names , config , skipped , broken ) if show_files : for file_name in file_names : print ( file_name ) return num_skipped = 0 num_broken = 0 num_invalid_encoding = 0 if config . verbose : print ( ASCII_ART ) if jobs : import multiprocessing executor = multiprocessing . Pool ( jobs ) attempt_iterator = executor . imap ( functools . partial ( sort_imports , config = config , check = check , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , extension = ext_format , ), file_names , ) else : # https : // github . com / python / typeshed / pull / 2814 attempt_iterator = ( sort_imports ( # type : ignore file_name , config = config , check = check , ask_to_apply = ask_to_apply , show_diff = show_diff , write_to_stdout = write_to_stdout , extension = ext_format , ) for file_name in file_names ) # If any files passed in are missing considered as error , should be removed is_no_attempt = True any_encoding_valid = False for sort_attempt in attempt_iterator : if not sort_attempt : continue # pragma : no cover - shouldn 't happen, satisfies type constraint incorrectly_sorted = sort_attempt.incorrectly_sorted if arguments.get(\"check\", False) and incorrectly_sorted: wrong_sorted_files = True if sort_attempt.skipped: num_skipped += ( 1 # pragma: no cover - shouldn' t happen , due to skip in iter_source_code ) if not sort_attempt . supported_encoding : num_invalid_encoding += 1 else : any_encoding_valid = True is_no_attempt = False num_skipped += len ( skipped ) if num_skipped and not config . quiet : if config . verbose : for was_skipped in skipped : warn ( f \"{was_skipped} was skipped as it's listed in 'skip' setting\" \" or matches a glob in 'skip_glob' setting\" ) print ( f \"Skipped {num_skipped} files\" ) num_broken += len ( broken ) if num_broken and not config . quiet : if config . verbose : for was_broken in broken : warn ( f \"{was_broken} was broken path, make sure it exists correctly\" ) print ( f \"Broken {num_broken} paths\" ) if num_broken > 0 and is_no_attempt : all_attempt_broken = True if num_invalid_encoding > 0 and not any_encoding_valid : no_valid_encodings = True if not config . quiet and ( remapped_deprecated_args or deprecated_flags ) : if remapped_deprecated_args : warn ( \"W0502: The following deprecated single dash CLI flags were used and translated: \" f \"{', '.join(remapped_deprecated_args)}!\" ) if deprecated_flags : warn ( \"W0501: The following deprecated CLI flags were used and ignored: \" f \"{', '.join(deprecated_flags)}!\" ) warn ( \"W0500: Please see the 5.0.0 Upgrade guide: \" \"https://pycqa.github.io/isort/docs/upgrade_guides/5.0.0/\" ) if wrong_sorted_files : sys . exit ( 1 ) if all_attempt_broken : sys . exit ( 1 ) if no_valid_encodings : printer = create_terminal_printer ( color = config . color_output ) printer . error ( \"No valid encodings.\" ) sys . exit ( 1 )","title":"main"},{"location":"reference/isort/main/#parse_args","text":"def parse_args ( argv : Union [ Sequence [ str ], NoneType ] = None ) -> Dict [ str , Any ] View Source def parse_args ( argv : Optional [ Sequence[str ] ] = None ) -> Dict [ str, Any ] : argv = sys . argv [ 1: ] if argv is None else list ( argv ) remapped_deprecated_args = [] for index , arg in enumerate ( argv ) : if arg in DEPRECATED_SINGLE_DASH_ARGS : remapped_deprecated_args . append ( arg ) argv [ index ] = f \"-{arg}\" parser = _build_arg_parser () arguments = { key : value for key , value in vars ( parser . parse_args ( argv )). items () if value } if remapped_deprecated_args : arguments [ \"remapped_deprecated_args\" ] = remapped_deprecated_args if \"dont_order_by_type\" in arguments : arguments [ \"order_by_type\" ] = False del arguments [ \"dont_order_by_type\" ] if \"dont_follow_links\" in arguments : arguments [ \"follow_links\" ] = False del arguments [ \"dont_follow_links\" ] if \"dont_float_to_top\" in arguments : del arguments [ \"dont_float_to_top\" ] if arguments . get ( \"float_to_top\" , False ) : sys . exit ( \"Can't set both --float-to-top and --dont-float-to-top.\" ) else : arguments [ \"float_to_top\" ] = False multi_line_output = arguments . get ( \"multi_line_output\" , None ) if multi_line_output : if multi_line_output . isdigit () : arguments [ \"multi_line_output\" ] = WrapModes ( int ( multi_line_output )) else : arguments [ \"multi_line_output\" ] = WrapModes [ multi_line_output ] return arguments","title":"parse_args"},{"location":"reference/isort/main/#sort_imports","text":"def sort_imports ( file_name : str , config : isort . settings . Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any ) -> Union [ isort . main . SortAttempt , NoneType ] View Source def sort_imports ( file_name : str , config : Config , check : bool = False , ask_to_apply : bool = False , write_to_stdout : bool = False , ** kwargs : Any , ) -> Optional [ SortAttempt ] : incorrectly_sorted : bool = False skipped : bool = False try : if check : try : incorrectly_sorted = not api . check_file ( file_name , config = config , ** kwargs ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) try : incorrectly_sorted = not api . sort_file ( file_name , config = config , ask_to_apply = ask_to_apply , write_to_stdout = write_to_stdout , ** kwargs , ) except FileSkipped : skipped = True return SortAttempt ( incorrectly_sorted , skipped , True ) except ( OSError , ValueError ) as error : warn ( f \"Unable to parse file {file_name} due to {error}\" ) return None except UnsupportedEncoding : if config . verbose : warn ( f \"Encoding not supported for {file_name}\" ) return SortAttempt ( incorrectly_sorted , skipped , False ) except ISortError as error : _print_hard_fail ( config , message = str ( error )) sys . exit ( 1 ) except Exception : _print_hard_fail ( config , offending_file = file_name ) raise","title":"sort_imports"},{"location":"reference/isort/main/#classes","text":"","title":"Classes"},{"location":"reference/isort/main/#sortattempt","text":"class SortAttempt ( incorrectly_sorted : bool , skipped : bool , supported_encoding : bool ) View Source class SortAttempt: def __init__ ( self , incorrectly_sorted: bool , skipped: bool , supported_encoding: bool ) -> None: self . incorrectly_sorted = incorrectly_sorted self . skipped = skipped self . supported_encoding = supported_encoding","title":"SortAttempt"},{"location":"reference/isort/output/","text":"Module isort.output View Source import copy import itertools from functools import partial from typing import Iterable , List , Set , Tuple from isort.format import format_simplified from . import parse , sorting , wrap from .comments import add_to_line as with_comments from .identify import STATEMENT_DECLARATIONS from .settings import DEFAULT_CONFIG , Config def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups \"\"\" if parsed . import_index == - 1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ... ] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ] . update ( parsed . imports [ section ] . get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ] . update ( parsed . imports [ section ] . get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] seen_headings : Set [ str ] = set () pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] if not config . only_sections : straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section , straight_import = True ), ) from_modules = parsed . imports [ section ][ \"from\" ] if not config . only_sections : from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) straight_imports = _with_straight_imports ( parsed , config , straight_modules , section , remove_imports , import_type ) from_imports = _with_from_imports ( parsed , config , from_modules , section , remove_imports , import_type ) lines_between = [ \"\" ] * ( config . lines_between_types if from_modules and straight_modules else 0 ) if config . from_first : section_output = from_imports + lines_between + straight_imports else : section_output = straight_imports + lines_between + from_imports if config . force_sort_within_sections : # collapse comments comments_above = [] new_section_output : List [ str ] = [] for line in section_output : if not line : continue if line . startswith ( \"#\" ): comments_above . append ( line ) elif comments_above : new_section_output . append ( _LineWithComments ( line , comments_above )) comments_above = [] else : new_section_output . append ( line ) # only_sections options is not imposed if force_sort_within_sections is True new_section_output = sorting . naturally ( new_section_output , key = partial ( sorting . section_key , config = config ), ) # uncollapse comments section_output = [] for line in new_section_output : comments = getattr ( line , \"comments\" , ()) if comments : section_output . extend ( comments ) section_output . append ( str ( line )) section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title and section_title not in seen_headings : if config . dedup_headings : seen_headings . add ( section_title ) section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ]: section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before if config . ensure_newline_before_comments : output = _ensure_newline_before_comment ( output ) while output and output [ - 1 ] . strip () == \"\" : output . pop () # pragma: no cover while output and output [ 0 ] . strip () == \"\" : output . pop ( 0 ) if config . formatting_function : output = config . formatting_function ( parsed . line_separator . join ( output ), extension , config ) . splitlines () output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ]: formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ): should_skip , in_quote , * _ = parse . skip_line ( line , in_quote = \"\" , index = len ( formatted_output ), section_comments = config . section_comments , needs_import = False , ) if not should_skip and line . strip (): if ( line . strip () . startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ] . strip () ): continue next_construct = line break if in_quote : next_construct = line break if config . lines_after_imports != - 1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLARATIONS ): formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ): new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if ( len ( formatted_output ) <= ( index + 1 ) or formatted_output [ index + 1 ] . strip () != \"\" ): new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator ) def _with_from_imports ( parsed : parse . ParsedContent , config : Config , from_modules : Iterable [ str ], section : str , remove_imports : List [ str ], import_type : str , ) -> List [ str ]: output : List [ str ] = [] for module in from_modules : if module in remove_imports : continue import_start = f \"from {module} {import_type} \" from_imports = list ( parsed . imports [ section ][ \"from\" ][ module ]) if not config . no_inline_sort or ( config . force_single_line and module not in config . single_line_exclusions ): if not config . only_sections : from_imports = sorting . naturally ( from_imports , key = lambda key : sorting . module_key ( key , config , True , config . force_alphabetical_sort_within_sections , section_name = section , ), ) if remove_imports : from_imports = [ line for line in from_imports if f \"{module}.{line}\" not in remove_imports ] sub_modules = [ f \"{module}.{from_import}\" for from_import in from_imports ] as_imports = { from_import : [ f \"{from_import} as {as_module}\" for as_module in parsed . as_map [ \"from\" ][ sub_module ] ] for from_import , sub_module in zip ( from_imports , sub_modules ) if sub_module in parsed . as_map [ \"from\" ] } if config . combine_as_imports and not ( \"*\" in from_imports and config . combine_star ): if not config . no_inline_sort : for as_import in as_imports : if not config . only_sections : as_imports [ as_import ] = sorting . naturally ( as_imports [ as_import ]) for from_import in copy . copy ( from_imports ): if from_import in as_imports : idx = from_imports . index ( from_import ) if parsed . imports [ section ][ \"from\" ][ module ][ from_import ]: from_imports [( idx + 1 ) : ( idx + 1 )] = as_imports . pop ( from_import ) else : from_imports [ idx : ( idx + 1 )] = as_imports . pop ( from_import ) only_show_as_imports = False comments = parsed . categorized_comments [ \"from\" ] . pop ( module , ()) above_comments = parsed . categorized_comments [ \"above\" ][ \"from\" ] . pop ( module , None ) while from_imports : if above_comments : output . extend ( above_comments ) above_comments = None if \"*\" in from_imports and config . combine_star : import_statement = wrap . line ( with_comments ( _with_star_comments ( parsed , module , list ( comments or ())), f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) from_imports = [ from_import for from_import in from_imports if from_import in as_imports ] only_show_as_imports = True elif config . force_single_line and module not in config . single_line_exclusions : import_statement = \"\" while from_imports : from_import = from_imports . pop ( 0 ) single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) if from_import in as_imports : if ( parsed . imports [ section ][ \"from\" ][ module ][ from_import ] and not only_show_as_imports ): output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) from_comments = parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) if not config . only_sections : output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in sorting . naturally ( as_imports [ from_import ]) ) else : output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in as_imports [ from_import ] ) else : output . append ( wrap . line ( single_import_line , parsed . line_separator , config )) comments = None else : while from_imports and from_imports [ 0 ] in as_imports : from_import = from_imports . pop ( 0 ) if not config . only_sections : as_imports [ from_import ] = sorting . naturally ( as_imports [ from_import ]) from_comments = ( parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) or [] ) if ( parsed . imports [ section ][ \"from\" ][ module ][ from_import ] and not only_show_as_imports ): specific_comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if specific_comment : from_comments . append ( specific_comment ) output . append ( wrap . line ( with_comments ( from_comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) ) from_comments = [] for as_import in as_imports [ from_import ]: specific_comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( as_import , None ) ) if specific_comment : from_comments . append ( specific_comment ) output . append ( wrap . line ( with_comments ( from_comments , import_start + as_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) ) from_comments = [] if \"*\" in from_imports : output . append ( with_comments ( _with_star_comments ( parsed , module , list ( comments or ())), f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) ) from_imports . remove ( \"*\" ) comments = None for from_import in copy . copy ( from_imports ): comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) output . append ( wrap . line ( single_import_line , parsed . line_separator , config )) from_imports . remove ( from_import ) comments = None from_import_section = [] while from_imports and ( from_imports [ 0 ] not in as_imports or ( config . combine_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ) ): from_import_section . append ( from_imports . pop ( 0 )) if config . combine_as_imports : comments = ( comments or []) + list ( parsed . categorized_comments [ \"from\" ] . pop ( f \"{module}.__combined_as__\" , ()) ) import_statement = with_comments ( comments , import_start + ( \", \" ) . join ( from_import_section ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) if not from_import_section : import_statement = \"\" do_multiline_reformat = False force_grid_wrap = config . force_grid_wrap if force_grid_wrap and len ( from_import_section ) >= force_grid_wrap : do_multiline_reformat = True if len ( import_statement ) > config . line_length and len ( from_import_section ) > 1 : do_multiline_reformat = True # If line too long AND have imports AND we are # NOT using GRID or VERTICAL wrap modes if ( len ( import_statement ) > config . line_length and len ( from_import_section ) > 0 and config . multi_line_output not in ( wrap . Modes . GRID , wrap . Modes . VERTICAL ) # type: ignore ): do_multiline_reformat = True if do_multiline_reformat : import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , ) if config . multi_line_output == wrap . Modes . GRID : # type: ignore other_import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , multi_line_output = wrap . Modes . VERTICAL_GRID , # type: ignore ) if max ( len ( x ) for x in import_statement . split ( \" \\n \" )) > config . line_length : import_statement = other_import_statement if not do_multiline_reformat and len ( import_statement ) > config . line_length : import_statement = wrap . line ( import_statement , parsed . line_separator , config ) if import_statement : output . append ( import_statement ) return output def _with_straight_imports ( parsed : parse . ParsedContent , config : Config , straight_modules : Iterable [ str ], section : str , remove_imports : List [ str ], import_type : str , ) -> List [ str ]: output : List [ str ] = [] as_imports = any (( module in parsed . as_map [ \"straight\" ] for module in straight_modules )) # combine_straight_imports only works for bare imports, 'as' imports not included if config . combine_straight_imports and not as_imports : if not straight_modules : return [] above_comments : List [ str ] = [] inline_comments : List [ str ] = [] for module in straight_modules : if module in parsed . categorized_comments [ \"above\" ][ \"straight\" ]: above_comments . extend ( parsed . categorized_comments [ \"above\" ][ \"straight\" ] . pop ( module )) if module in parsed . categorized_comments [ \"straight\" ]: inline_comments . extend ( parsed . categorized_comments [ \"straight\" ][ module ]) combined_straight_imports = \", \" . join ( straight_modules ) if inline_comments : combined_inline_comments = \" \" . join ( inline_comments ) else : combined_inline_comments = \"\" output . extend ( above_comments ) if combined_inline_comments : output . append ( f \"{import_type} {combined_straight_imports} # {combined_inline_comments}\" ) else : output . append ( f \"{import_type} {combined_straight_imports}\" ) return output for module in straight_modules : if module in remove_imports : continue import_definition = [] if module in parsed . as_map [ \"straight\" ]: if parsed . imports [ section ][ \"straight\" ][ module ]: import_definition . append (( f \"{import_type} {module}\" , module )) import_definition . extend ( ( f \"{import_type} {module} as {as_import}\" , f \"{module} as {as_import}\" ) for as_import in parsed . as_map [ \"straight\" ][ module ] ) else : import_definition . append (( f \"{import_type} {module}\" , module )) comments_above = parsed . categorized_comments [ \"above\" ][ \"straight\" ] . pop ( module , None ) if comments_above : output . extend ( comments_above ) output . extend ( with_comments ( parsed . categorized_comments [ \"straight\" ] . get ( imodule ), idef , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for idef , imodule in import_definition ) return output def _output_as_string ( lines : List [ str ], line_separator : str ) -> str : return line_separator . join ( _normalize_empty_lines ( lines )) def _normalize_empty_lines ( lines : List [ str ]) -> List [ str ]: while lines and lines [ - 1 ] . strip () == \"\" : lines . pop ( - 1 ) lines . append ( \"\" ) return lines class _LineWithComments ( str ): def __new__ ( cls , value , comments ): instance = super () . __new__ ( cls , value ) # type: ignore instance . comments = comments return instance def _ensure_newline_before_comment ( output ): new_output : List [ str ] = [] def is_comment ( line ): return line and line . startswith ( \"#\" ) for line , prev_line in zip ( output , [ None ] + output ): if is_comment ( line ) and prev_line != \"\" and not is_comment ( prev_line ): new_output . append ( \"\" ) new_output . append ( line ) return new_output def _with_star_comments ( parsed : parse . ParsedContent , module : str , comments : List [ str ]) -> List [ str ]: star_comment = parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( \"*\" , None ) if star_comment : return comments + [ star_comment ] return comments Variables STATEMENT_DECLARATIONS Functions sorted_imports def sorted_imports ( parsed : isort . parse . ParsedContent , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), extension : str = 'py' , import_type : str = 'import' ) -> str Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups View Source def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. ( at the index of the first import ) sorted alphabetically and split between groups \"\"\" if parsed . import_index == -1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ...] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ]. update ( parsed . imports [ section ]. get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ]. update ( parsed . imports [ section ]. get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] seen_headings : Set [ str ] = set () pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] if not config . only_sections : straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section , straight_import = True ), ) from_modules = parsed . imports [ section ][ \"from\" ] if not config . only_sections : from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) straight_imports = _with_straight_imports ( parsed , config , straight_modules , section , remove_imports , import_type ) from_imports = _with_from_imports ( parsed , config , from_modules , section , remove_imports , import_type ) lines_between = [ \"\" ] * ( config . lines_between_types if from_modules and straight_modules else 0 ) if config . from_first : section_output = from_imports + lines_between + straight_imports else : section_output = straight_imports + lines_between + from_imports if config . force_sort_within_sections : # collapse comments comments_above = [] new_section_output : List [ str ] = [] for line in section_output : if not line : continue if line . startswith ( \"#\" ) : comments_above . append ( line ) elif comments_above : new_section_output . append ( _LineWithComments ( line , comments_above )) comments_above = [] else : new_section_output . append ( line ) # only_sections options is not imposed if force_sort_within_sections is True new_section_output = sorting . naturally ( new_section_output , key = partial ( sorting . section_key , config = config ), ) # uncollapse comments section_output = [] for line in new_section_output : comments = getattr ( line , \"comments\" , ()) if comments : section_output . extend ( comments ) section_output . append ( str ( line )) section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title and section_title not in seen_headings : if config . dedup_headings : seen_headings . add ( section_title ) section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ] : section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before if config . ensure_newline_before_comments : output = _ensure_newline_before_comment ( output ) while output and output [ -1 ]. strip () == \"\" : output . pop () # pragma : no cover while output and output [ 0 ]. strip () == \"\" : output . pop ( 0 ) if config . formatting_function : output = config . formatting_function ( parsed . line_separator . join ( output ), extension , config ). splitlines () output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ] : formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ) : should_skip , in_quote , * _ = parse . skip_line ( line , in_quote = \"\" , index = len ( formatted_output ), section_comments = config . section_comments , needs_import = False , ) if not should_skip and line . strip () : if ( line . strip (). startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ]. strip () ) : continue next_construct = line break if in_quote : next_construct = line break if config . lines_after_imports != -1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLARATIONS ) : formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ) : new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if ( len ( formatted_output ) <= ( index + 1 ) or formatted_output [ index + 1 ]. strip () != \"\" ) : new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator )","title":"Output"},{"location":"reference/isort/output/#module-isortoutput","text":"View Source import copy import itertools from functools import partial from typing import Iterable , List , Set , Tuple from isort.format import format_simplified from . import parse , sorting , wrap from .comments import add_to_line as with_comments from .identify import STATEMENT_DECLARATIONS from .settings import DEFAULT_CONFIG , Config def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups \"\"\" if parsed . import_index == - 1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ... ] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ] . update ( parsed . imports [ section ] . get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ] . update ( parsed . imports [ section ] . get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] seen_headings : Set [ str ] = set () pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] if not config . only_sections : straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section , straight_import = True ), ) from_modules = parsed . imports [ section ][ \"from\" ] if not config . only_sections : from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) straight_imports = _with_straight_imports ( parsed , config , straight_modules , section , remove_imports , import_type ) from_imports = _with_from_imports ( parsed , config , from_modules , section , remove_imports , import_type ) lines_between = [ \"\" ] * ( config . lines_between_types if from_modules and straight_modules else 0 ) if config . from_first : section_output = from_imports + lines_between + straight_imports else : section_output = straight_imports + lines_between + from_imports if config . force_sort_within_sections : # collapse comments comments_above = [] new_section_output : List [ str ] = [] for line in section_output : if not line : continue if line . startswith ( \"#\" ): comments_above . append ( line ) elif comments_above : new_section_output . append ( _LineWithComments ( line , comments_above )) comments_above = [] else : new_section_output . append ( line ) # only_sections options is not imposed if force_sort_within_sections is True new_section_output = sorting . naturally ( new_section_output , key = partial ( sorting . section_key , config = config ), ) # uncollapse comments section_output = [] for line in new_section_output : comments = getattr ( line , \"comments\" , ()) if comments : section_output . extend ( comments ) section_output . append ( str ( line )) section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title and section_title not in seen_headings : if config . dedup_headings : seen_headings . add ( section_title ) section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ]: section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before if config . ensure_newline_before_comments : output = _ensure_newline_before_comment ( output ) while output and output [ - 1 ] . strip () == \"\" : output . pop () # pragma: no cover while output and output [ 0 ] . strip () == \"\" : output . pop ( 0 ) if config . formatting_function : output = config . formatting_function ( parsed . line_separator . join ( output ), extension , config ) . splitlines () output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ]: formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ): should_skip , in_quote , * _ = parse . skip_line ( line , in_quote = \"\" , index = len ( formatted_output ), section_comments = config . section_comments , needs_import = False , ) if not should_skip and line . strip (): if ( line . strip () . startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ] . strip () ): continue next_construct = line break if in_quote : next_construct = line break if config . lines_after_imports != - 1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLARATIONS ): formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ): new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if ( len ( formatted_output ) <= ( index + 1 ) or formatted_output [ index + 1 ] . strip () != \"\" ): new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator ) def _with_from_imports ( parsed : parse . ParsedContent , config : Config , from_modules : Iterable [ str ], section : str , remove_imports : List [ str ], import_type : str , ) -> List [ str ]: output : List [ str ] = [] for module in from_modules : if module in remove_imports : continue import_start = f \"from {module} {import_type} \" from_imports = list ( parsed . imports [ section ][ \"from\" ][ module ]) if not config . no_inline_sort or ( config . force_single_line and module not in config . single_line_exclusions ): if not config . only_sections : from_imports = sorting . naturally ( from_imports , key = lambda key : sorting . module_key ( key , config , True , config . force_alphabetical_sort_within_sections , section_name = section , ), ) if remove_imports : from_imports = [ line for line in from_imports if f \"{module}.{line}\" not in remove_imports ] sub_modules = [ f \"{module}.{from_import}\" for from_import in from_imports ] as_imports = { from_import : [ f \"{from_import} as {as_module}\" for as_module in parsed . as_map [ \"from\" ][ sub_module ] ] for from_import , sub_module in zip ( from_imports , sub_modules ) if sub_module in parsed . as_map [ \"from\" ] } if config . combine_as_imports and not ( \"*\" in from_imports and config . combine_star ): if not config . no_inline_sort : for as_import in as_imports : if not config . only_sections : as_imports [ as_import ] = sorting . naturally ( as_imports [ as_import ]) for from_import in copy . copy ( from_imports ): if from_import in as_imports : idx = from_imports . index ( from_import ) if parsed . imports [ section ][ \"from\" ][ module ][ from_import ]: from_imports [( idx + 1 ) : ( idx + 1 )] = as_imports . pop ( from_import ) else : from_imports [ idx : ( idx + 1 )] = as_imports . pop ( from_import ) only_show_as_imports = False comments = parsed . categorized_comments [ \"from\" ] . pop ( module , ()) above_comments = parsed . categorized_comments [ \"above\" ][ \"from\" ] . pop ( module , None ) while from_imports : if above_comments : output . extend ( above_comments ) above_comments = None if \"*\" in from_imports and config . combine_star : import_statement = wrap . line ( with_comments ( _with_star_comments ( parsed , module , list ( comments or ())), f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) from_imports = [ from_import for from_import in from_imports if from_import in as_imports ] only_show_as_imports = True elif config . force_single_line and module not in config . single_line_exclusions : import_statement = \"\" while from_imports : from_import = from_imports . pop ( 0 ) single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) if from_import in as_imports : if ( parsed . imports [ section ][ \"from\" ][ module ][ from_import ] and not only_show_as_imports ): output . append ( wrap . line ( single_import_line , parsed . line_separator , config ) ) from_comments = parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) if not config . only_sections : output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in sorting . naturally ( as_imports [ from_import ]) ) else : output . extend ( with_comments ( from_comments , wrap . line ( import_start + as_import , parsed . line_separator , config ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for as_import in as_imports [ from_import ] ) else : output . append ( wrap . line ( single_import_line , parsed . line_separator , config )) comments = None else : while from_imports and from_imports [ 0 ] in as_imports : from_import = from_imports . pop ( 0 ) if not config . only_sections : as_imports [ from_import ] = sorting . naturally ( as_imports [ from_import ]) from_comments = ( parsed . categorized_comments [ \"straight\" ] . get ( f \"{module}.{from_import}\" ) or [] ) if ( parsed . imports [ section ][ \"from\" ][ module ][ from_import ] and not only_show_as_imports ): specific_comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if specific_comment : from_comments . append ( specific_comment ) output . append ( wrap . line ( with_comments ( from_comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) ) from_comments = [] for as_import in as_imports [ from_import ]: specific_comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( as_import , None ) ) if specific_comment : from_comments . append ( specific_comment ) output . append ( wrap . line ( with_comments ( from_comments , import_start + as_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ), parsed . line_separator , config , ) ) from_comments = [] if \"*\" in from_imports : output . append ( with_comments ( _with_star_comments ( parsed , module , list ( comments or ())), f \"{import_start}*\" , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) ) from_imports . remove ( \"*\" ) comments = None for from_import in copy . copy ( from_imports ): comment = ( parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( from_import , None ) ) if comment : single_import_line = with_comments ( comments , import_start + from_import , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) single_import_line += ( f \"{comments and ';' or config.comment_prefix} \" f \"{comment}\" ) output . append ( wrap . line ( single_import_line , parsed . line_separator , config )) from_imports . remove ( from_import ) comments = None from_import_section = [] while from_imports and ( from_imports [ 0 ] not in as_imports or ( config . combine_as_imports and parsed . imports [ section ][ \"from\" ][ module ][ from_import ] ) ): from_import_section . append ( from_imports . pop ( 0 )) if config . combine_as_imports : comments = ( comments or []) + list ( parsed . categorized_comments [ \"from\" ] . pop ( f \"{module}.__combined_as__\" , ()) ) import_statement = with_comments ( comments , import_start + ( \", \" ) . join ( from_import_section ), removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) if not from_import_section : import_statement = \"\" do_multiline_reformat = False force_grid_wrap = config . force_grid_wrap if force_grid_wrap and len ( from_import_section ) >= force_grid_wrap : do_multiline_reformat = True if len ( import_statement ) > config . line_length and len ( from_import_section ) > 1 : do_multiline_reformat = True # If line too long AND have imports AND we are # NOT using GRID or VERTICAL wrap modes if ( len ( import_statement ) > config . line_length and len ( from_import_section ) > 0 and config . multi_line_output not in ( wrap . Modes . GRID , wrap . Modes . VERTICAL ) # type: ignore ): do_multiline_reformat = True if do_multiline_reformat : import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , ) if config . multi_line_output == wrap . Modes . GRID : # type: ignore other_import_statement = wrap . import_statement ( import_start = import_start , from_imports = from_import_section , comments = comments , line_separator = parsed . line_separator , config = config , multi_line_output = wrap . Modes . VERTICAL_GRID , # type: ignore ) if max ( len ( x ) for x in import_statement . split ( \" \\n \" )) > config . line_length : import_statement = other_import_statement if not do_multiline_reformat and len ( import_statement ) > config . line_length : import_statement = wrap . line ( import_statement , parsed . line_separator , config ) if import_statement : output . append ( import_statement ) return output def _with_straight_imports ( parsed : parse . ParsedContent , config : Config , straight_modules : Iterable [ str ], section : str , remove_imports : List [ str ], import_type : str , ) -> List [ str ]: output : List [ str ] = [] as_imports = any (( module in parsed . as_map [ \"straight\" ] for module in straight_modules )) # combine_straight_imports only works for bare imports, 'as' imports not included if config . combine_straight_imports and not as_imports : if not straight_modules : return [] above_comments : List [ str ] = [] inline_comments : List [ str ] = [] for module in straight_modules : if module in parsed . categorized_comments [ \"above\" ][ \"straight\" ]: above_comments . extend ( parsed . categorized_comments [ \"above\" ][ \"straight\" ] . pop ( module )) if module in parsed . categorized_comments [ \"straight\" ]: inline_comments . extend ( parsed . categorized_comments [ \"straight\" ][ module ]) combined_straight_imports = \", \" . join ( straight_modules ) if inline_comments : combined_inline_comments = \" \" . join ( inline_comments ) else : combined_inline_comments = \"\" output . extend ( above_comments ) if combined_inline_comments : output . append ( f \"{import_type} {combined_straight_imports} # {combined_inline_comments}\" ) else : output . append ( f \"{import_type} {combined_straight_imports}\" ) return output for module in straight_modules : if module in remove_imports : continue import_definition = [] if module in parsed . as_map [ \"straight\" ]: if parsed . imports [ section ][ \"straight\" ][ module ]: import_definition . append (( f \"{import_type} {module}\" , module )) import_definition . extend ( ( f \"{import_type} {module} as {as_import}\" , f \"{module} as {as_import}\" ) for as_import in parsed . as_map [ \"straight\" ][ module ] ) else : import_definition . append (( f \"{import_type} {module}\" , module )) comments_above = parsed . categorized_comments [ \"above\" ][ \"straight\" ] . pop ( module , None ) if comments_above : output . extend ( comments_above ) output . extend ( with_comments ( parsed . categorized_comments [ \"straight\" ] . get ( imodule ), idef , removed = config . ignore_comments , comment_prefix = config . comment_prefix , ) for idef , imodule in import_definition ) return output def _output_as_string ( lines : List [ str ], line_separator : str ) -> str : return line_separator . join ( _normalize_empty_lines ( lines )) def _normalize_empty_lines ( lines : List [ str ]) -> List [ str ]: while lines and lines [ - 1 ] . strip () == \"\" : lines . pop ( - 1 ) lines . append ( \"\" ) return lines class _LineWithComments ( str ): def __new__ ( cls , value , comments ): instance = super () . __new__ ( cls , value ) # type: ignore instance . comments = comments return instance def _ensure_newline_before_comment ( output ): new_output : List [ str ] = [] def is_comment ( line ): return line and line . startswith ( \"#\" ) for line , prev_line in zip ( output , [ None ] + output ): if is_comment ( line ) and prev_line != \"\" and not is_comment ( prev_line ): new_output . append ( \"\" ) new_output . append ( line ) return new_output def _with_star_comments ( parsed : parse . ParsedContent , module : str , comments : List [ str ]) -> List [ str ]: star_comment = parsed . categorized_comments [ \"nested\" ] . get ( module , {}) . pop ( \"*\" , None ) if star_comment : return comments + [ star_comment ] return comments","title":"Module isort.output"},{"location":"reference/isort/output/#variables","text":"STATEMENT_DECLARATIONS","title":"Variables"},{"location":"reference/isort/output/#functions","text":"","title":"Functions"},{"location":"reference/isort/output/#sorted_imports","text":"def sorted_imports ( parsed : isort . parse . ParsedContent , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), extension : str = 'py' , import_type : str = 'import' ) -> str Adds the imports back to the file. (at the index of the first import) sorted alphabetically and split between groups View Source def sorted_imports ( parsed : parse . ParsedContent , config : Config = DEFAULT_CONFIG , extension : str = \"py\" , import_type : str = \"import\" , ) -> str : \"\"\"Adds the imports back to the file. ( at the index of the first import ) sorted alphabetically and split between groups \"\"\" if parsed . import_index == -1 : return _output_as_string ( parsed . lines_without_imports , parsed . line_separator ) formatted_output : List [ str ] = parsed . lines_without_imports . copy () remove_imports = [ format_simplified ( removal ) for removal in config . remove_imports ] sections : Iterable [ str ] = itertools . chain ( parsed . sections , config . forced_separate ) if config . no_sections : parsed . imports [ \"no_sections\" ] = { \"straight\" : {}, \"from\" : {}} base_sections : Tuple [ str , ...] = () for section in sections : if section == \"FUTURE\" : base_sections = ( \"FUTURE\" ,) continue parsed . imports [ \"no_sections\" ][ \"straight\" ]. update ( parsed . imports [ section ]. get ( \"straight\" , {}) ) parsed . imports [ \"no_sections\" ][ \"from\" ]. update ( parsed . imports [ section ]. get ( \"from\" , {})) sections = base_sections + ( \"no_sections\" ,) output : List [ str ] = [] seen_headings : Set [ str ] = set () pending_lines_before = False for section in sections : straight_modules = parsed . imports [ section ][ \"straight\" ] if not config . only_sections : straight_modules = sorting . naturally ( straight_modules , key = lambda key : sorting . module_key ( key , config , section_name = section , straight_import = True ), ) from_modules = parsed . imports [ section ][ \"from\" ] if not config . only_sections : from_modules = sorting . naturally ( from_modules , key = lambda key : sorting . module_key ( key , config , section_name = section ) ) straight_imports = _with_straight_imports ( parsed , config , straight_modules , section , remove_imports , import_type ) from_imports = _with_from_imports ( parsed , config , from_modules , section , remove_imports , import_type ) lines_between = [ \"\" ] * ( config . lines_between_types if from_modules and straight_modules else 0 ) if config . from_first : section_output = from_imports + lines_between + straight_imports else : section_output = straight_imports + lines_between + from_imports if config . force_sort_within_sections : # collapse comments comments_above = [] new_section_output : List [ str ] = [] for line in section_output : if not line : continue if line . startswith ( \"#\" ) : comments_above . append ( line ) elif comments_above : new_section_output . append ( _LineWithComments ( line , comments_above )) comments_above = [] else : new_section_output . append ( line ) # only_sections options is not imposed if force_sort_within_sections is True new_section_output = sorting . naturally ( new_section_output , key = partial ( sorting . section_key , config = config ), ) # uncollapse comments section_output = [] for line in new_section_output : comments = getattr ( line , \"comments\" , ()) if comments : section_output . extend ( comments ) section_output . append ( str ( line )) section_name = section no_lines_before = section_name in config . no_lines_before if section_output : if section_name in parsed . place_imports : parsed . place_imports [ section_name ] = section_output continue section_title = config . import_headings . get ( section_name . lower (), \"\" ) if section_title and section_title not in seen_headings : if config . dedup_headings : seen_headings . add ( section_title ) section_comment = f \"# {section_title}\" if section_comment not in parsed . lines_without_imports [ 0 : 1 ] : section_output . insert ( 0 , section_comment ) if pending_lines_before or not no_lines_before : output += [ \"\" ] * config . lines_between_sections output += section_output pending_lines_before = False else : pending_lines_before = pending_lines_before or not no_lines_before if config . ensure_newline_before_comments : output = _ensure_newline_before_comment ( output ) while output and output [ -1 ]. strip () == \"\" : output . pop () # pragma : no cover while output and output [ 0 ]. strip () == \"\" : output . pop ( 0 ) if config . formatting_function : output = config . formatting_function ( parsed . line_separator . join ( output ), extension , config ). splitlines () output_at = 0 if parsed . import_index < parsed . original_line_count : output_at = parsed . import_index formatted_output [ output_at : 0 ] = output imports_tail = output_at + len ( output ) while [ character . strip () for character in formatted_output [ imports_tail : imports_tail + 1 ] ] == [ \"\" ] : formatted_output . pop ( imports_tail ) if len ( formatted_output ) > imports_tail : next_construct = \"\" tail = formatted_output [ imports_tail :] for index , line in enumerate ( tail ) : should_skip , in_quote , * _ = parse . skip_line ( line , in_quote = \"\" , index = len ( formatted_output ), section_comments = config . section_comments , needs_import = False , ) if not should_skip and line . strip () : if ( line . strip (). startswith ( \"#\" ) and len ( tail ) > ( index + 1 ) and tail [ index + 1 ]. strip () ) : continue next_construct = line break if in_quote : next_construct = line break if config . lines_after_imports != -1 : formatted_output [ imports_tail : 0 ] = [ \"\" for line in range ( config . lines_after_imports )] elif extension != \"pyi\" and next_construct . startswith ( STATEMENT_DECLARATIONS ) : formatted_output [ imports_tail : 0 ] = [ \"\" , \"\" ] else : formatted_output [ imports_tail : 0 ] = [ \"\" ] if parsed . place_imports : new_out_lines = [] for index , line in enumerate ( formatted_output ) : new_out_lines . append ( line ) if line in parsed . import_placements : new_out_lines . extend ( parsed . place_imports [ parsed . import_placements [ line ]]) if ( len ( formatted_output ) <= ( index + 1 ) or formatted_output [ index + 1 ]. strip () != \"\" ) : new_out_lines . append ( \"\" ) formatted_output = new_out_lines return _output_as_string ( formatted_output , parsed . line_separator )","title":"sorted_imports"},{"location":"reference/isort/parse/","text":"Module isort.parse Defines parsing functions used by isort for parsing import definitions View Source \"\"\"Defines parsing functions used by isort for parsing import definitions\"\"\" from collections import OrderedDict , defaultdict from functools import partial from itertools import chain from typing import TYPE_CHECKING , Any , Dict , List , NamedTuple , Optional , Tuple from warnings import warn from . import place from .comments import parse as parse_comments from .deprecated.finders import FindersManager from .exceptions import MissingSection from .settings import DEFAULT_CONFIG , Config if TYPE_CHECKING : from mypy_extensions import TypedDict CommentsAboveDict = TypedDict ( \"CommentsAboveDict\" , { \"straight\" : Dict [ str , Any ], \"from\" : Dict [ str , Any ]} ) CommentsDict = TypedDict ( \"CommentsDict\" , { \"from\" : Dict [ str , Any ], \"straight\" : Dict [ str , Any ], \"nested\" : Dict [ str , Any ], \"above\" : CommentsAboveDict , }, ) def _infer_line_separator ( contents : str ) -> str : if \" \\r\\n \" in contents : return \" \\r\\n \" if \" \\r \" in contents : return \" \\r \" return \" \\n \" def _normalize_line ( raw_line : str ) -> Tuple [ str , str ]: \"\"\"Normalizes import related statements in the provided line. Returns (normalized_line: str, raw_line: str) \"\"\" line = raw_line . replace ( \"from.import \" , \"from . import \" ) line = line . replace ( \"from.cimport \" , \"from . cimport \" ) line = line . replace ( \"import*\" , \"import *\" ) line = line . replace ( \" .import \" , \" . import \" ) line = line . replace ( \" .cimport \" , \" . cimport \" ) line = line . replace ( \" \\t \" , \" \" ) return ( line , raw_line ) def import_type ( line : str , config : Config = DEFAULT_CONFIG ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if config . honor_noqa and line . lower () . rstrip () . endswith ( \"noqa\" ): return None if \"isort:skip\" in line or \"isort: skip\" in line or \"isort: split\" in line : return None if line . startswith (( \"import \" , \"cimport \" )): return \"straight\" if line . startswith ( \"from \" ): return \"from\" return None def _strip_syntax ( import_string : str ) -> str : import_string = import_string . replace ( \"_import\" , \"[[i]]\" ) import_string = import_string . replace ( \"_cimport\" , \"[[ci]]\" ) for remove_syntax in [ \" \\\\ \" , \"(\" , \")\" , \",\" ]: import_string = import_string . replace ( remove_syntax , \" \" ) import_list = import_string . split () for key in ( \"from\" , \"import\" , \"cimport\" ): if key in import_list : import_list . remove ( key ) import_string = \" \" . join ( import_list ) import_string = import_string . replace ( \"[[i]]\" , \"_import\" ) import_string = import_string . replace ( \"[[ci]]\" , \"_cimport\" ) return import_string . replace ( \"{ \" , \"{|\" ) . replace ( \" }\" , \"|}\" ) def skip_line ( line : str , in_quote : str , index : int , section_comments : Tuple [ str , ... ], needs_import : bool = True , ) -> Tuple [ bool , str ]: \"\"\"Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ): if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ): long_quote = line [ char_index : char_index + 3 ] if long_quote in ( '\"\"\"' , \"'''\" ): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \";\" in line . split ( \"#\" )[ 0 ] and needs_import : for part in ( part . strip () for part in line . split ( \";\" )): if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ): should_skip = True return ( bool ( should_skip or in_quote ), in_quote ) class ParsedContent ( NamedTuple ): in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str , List [ str ]] import_placements : Dict [ str , str ] as_map : Dict [ str , Dict [ str , List [ str ]]] imports : Dict [ str , Dict [ str , Any ]] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any verbose_output : List [ str ] def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . splitlines () if contents and contents [ - 1 ] in ( \" \\n \" , \" \\r \" ): in_lines . append ( \"\" ) out_lines = [] original_line_count = len ( in_lines ) if config . old_finders : finder = FindersManager ( config = config ) . find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , Dict [ str , List [ str ]]] = { \"straight\" : defaultdict ( list ), \"from\" : defaultdict ( list ), } imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () verbose_output : List [ str ] = [] for section in chain ( config . sections , config . forced_separate ): imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = - 1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if line in config . section_comments and not skipping_line : if import_index == - 1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort:imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort: imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue lstripped_line = line . lstrip () if ( config . float_to_top and import_index == - 1 and line and not in_quote and not lstripped_line . startswith ( \"#\" ) and not lstripped_line . startswith ( \"'''\" ) and not lstripped_line . startswith ( '\"\"\"' ) ): if not lstripped_line . startswith ( \"import\" ) and not lstripped_line . startswith ( \"from\" ): import_index = index - 1 while import_index and not in_lines [ import_index - 1 ]: import_index -= 1 else : commentless = line . split ( \"#\" , 1 )[ 0 ] . strip () if ( ( \"isort:skip\" in line or \"isort: skip\" in line ) and \"(\" in commentless and \")\" not in commentless ): import_index = index starting_line = line while \"isort:skip\" in starting_line or \"isort: skip\" in starting_line : commentless = starting_line . split ( \"#\" , 1 )[ 0 ] if ( \"(\" in commentless and not commentless . rstrip () . endswith ( \")\" ) and import_index < line_count ): while import_index < line_count and not commentless . rstrip () . endswith ( \")\" ): commentless = in_lines [ import_index ] . split ( \"#\" , 1 )[ 0 ] import_index += 1 else : import_index += 1 if import_index >= line_count : break starting_line = in_lines [ import_index ] line , * end_of_line_comment = line . split ( \"#\" , 1 ) if \";\" in line : statements = [ line . strip () for line in line . split ( \";\" )] else : statements = [ line ] if end_of_line_comment : statements [ - 1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , raw_line = _normalize_line ( statement ) type_of_import = import_type ( line , config ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == - 1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ) . strip () . split ( \" \" ) if part ] if type_of_import == \"from\" and len ( line_parts ) == 2 and comments : nested_comments [ line_parts [ - 1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" , 1 )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line else : while line . strip () . endswith ( \" \\\\ \" ): line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ): stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] if import_string . strip () . endswith ( ( \" import\" , \" cimport\" ) ) or line . strip () . startswith (( \"import \" , \"cimport \" )): import_string += line_separator + line else : import_string = import_string . rstrip () . rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ) . join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 :])] + parts [ 1 :] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ) . replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ) . split () ] attach_comments_to : Optional [ List [ Any ]] = None direct_imports = just_imports [ 1 :] straight_import = True top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ): straight_import = False while \"as\" in just_imports : nested_module = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : nested_module = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + nested_module as_name = just_imports [ as_index + 1 ] direct_imports . remove ( nested_module ) direct_imports . remove ( as_name ) direct_imports . remove ( \"as\" ) if nested_module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"from\" ][ module ]: as_map [ \"from\" ][ module ] . append ( as_name ) full_name = f \"{nested_module} as {as_name}\" associated_comment = nested_comments . get ( full_name ) if associated_comment : categorized_comments [ \"nested\" ] . setdefault ( top_level_module , {})[ full_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"straight\" ][ module ]: as_map [ \"straight\" ][ module ] . append ( as_name ) if comments and attach_comments_to is None : if nested_module and config . combine_as_imports : attach_comments_to = categorized_comments [ \"from\" ] . setdefault ( f \"{top_level_module}.__combined_as__\" , [] ) else : if type_of_import == \"from\" or ( config . remove_redundant_aliases and as_name == module . split ( \".\" )[ - 1 ] ): attach_comments_to = categorized_comments [ \"straight\" ] . setdefault ( module , [] ) else : attach_comments_to = categorized_comments [ \"straight\" ] . setdefault ( f \"{module} as {as_name}\" , [] ) del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose and not config . only_modified : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type: ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ] . setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments and attach_comments_to is None : attach_comments_to = categorized_comments [ \"from\" ] . setdefault ( import_from , []) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines [ - 1 ] . rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ): categorized_comments [ \"above\" ][ \"from\" ] . setdefault ( import_from , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if statement_index - 1 == import_index : # pragma: no cover import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ] . get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , module in direct_imports ) for module in just_imports ) else : root [ import_from ] . update ( ( module , root [ import_from ] . get ( module , False ) or module in direct_imports ) for module in just_imports ) if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) else : if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) comments = [] for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines [ - 1 ] . rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ): categorized_comments [ \"above\" ][ \"straight\" ] . setdefault ( module , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ] . get ( module , []) ) placed_module = finder ( module ) if config . verbose and not config . only_modified : print ( f \"else-type place_module for {module} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) if placed_module and placed_module not in imports : raise MissingSection ( import_module = module , section = placed_module ) straight_import |= imports [ placed_module ][ type_of_import ] . get ( # type: ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type: ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , verbose_output = verbose_output , ) Variables TYPE_CHECKING Functions file_contents def file_contents ( contents : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> isort . parse . ParsedContent Parses a python file taking out and categorizing imports. View Source def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . splitlines () if contents and contents [ -1 ] in ( \" \\n \" , \" \\r \" ) : in_lines . append ( \"\" ) out_lines = [] original_line_count = len ( in_lines ) if config . old_finders : finder = FindersManager ( config = config ). find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , Dict [ str , List [ str ]]] = { \"straight\" : defaultdict ( list ), \"from\" : defaultdict ( list ), } imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () verbose_output : List [ str ] = [] for section in chain ( config . sections , config . forced_separate ) : imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = -1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if line in config . section_comments and not skipping_line : if import_index == -1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort:imports-\" )[ -1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort: imports-\" )[ -1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue lstripped_line = line . lstrip () if ( config . float_to_top and import_index == -1 and line and not in_quote and not lstripped_line . startswith ( \"#\" ) and not lstripped_line . startswith ( \"'''\" ) and not lstripped_line . startswith ( ' \"\"\"') ) : if not lstripped_line . startswith ( \"import\" ) and not lstripped_line . startswith ( \"from\" ) : import_index = index - 1 while import_index and not in_lines [ import_index - 1 ] : import_index -= 1 else : commentless = line . split ( \"#\" , 1 )[ 0 ]. strip () if ( ( \"isort:skip\" in line or \"isort: skip\" in line ) and \"(\" in commentless and \")\" not in commentless ) : import_index = index starting_line = line while \"isort:skip\" in starting_line or \"isort: skip\" in starting_line : commentless = starting_line . split ( \"#\" , 1 )[ 0 ] if ( \"(\" in commentless and not commentless . rstrip (). endswith ( \")\" ) and import_index < line_count ) : while import_index < line_count and not commentless . rstrip (). endswith ( \")\" ) : commentless = in_lines [ import_index ]. split ( \"#\" , 1 )[ 0 ] import_index += 1 else : import_index += 1 if import_index >= line_count : break starting_line = in_lines [ import_index ] line , * end_of_line_comment = line . split ( \"#\" , 1 ) if \";\" in line : statements = [ line . strip () for line in line . split ( \";\" )] else : statements = [ line ] if end_of_line_comment : statements [ -1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , raw_line = _normalize_line ( statement ) type_of_import = import_type ( line , config ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == -1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ). strip (). split ( \" \" ) if part ] if type_of_import == \"from\" and len ( line_parts ) == 2 and comments : nested_comments [ line_parts [ -1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" , 1 )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] import_string += line_separator + line else : while line . strip (). endswith ( \" \\\\ \" ) : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ) : stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] if import_string . strip (). endswith ( ( \" import\" , \" cimport\" ) ) or line . strip (). startswith (( \"import \" , \"cimport \" )) : import_string += line_separator + line else : import_string = import_string . rstrip (). rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ]. split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ). join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 : ])] + parts [ 1 : ] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ). replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ). split () ] attach_comments_to : Optional [ List [ Any ]] = None direct_imports = just_imports [ 1 : ] straight_import = True top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ) : straight_import = False while \"as\" in just_imports : nested_module = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : nested_module = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + nested_module as_name = just_imports [ as_index + 1 ] direct_imports . remove ( nested_module ) direct_imports . remove ( as_name ) direct_imports . remove ( \"as\" ) if nested_module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"from\" ][ module ] : as_map [ \"from\" ][ module ]. append ( as_name ) full_name = f \"{nested_module} as {as_name}\" associated_comment = nested_comments . get ( full_name ) if associated_comment : categorized_comments [ \"nested\" ]. setdefault ( top_level_module , {})[ full_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"straight\" ][ module ] : as_map [ \"straight\" ][ module ]. append ( as_name ) if comments and attach_comments_to is None : if nested_module and config . combine_as_imports : attach_comments_to = categorized_comments [ \"from\" ]. setdefault ( f \"{top_level_module}.__combined_as__\" , [] ) else : if type_of_import == \"from\" or ( config . remove_redundant_aliases and as_name == module . split ( \".\" )[ -1 ] ) : attach_comments_to = categorized_comments [ \"straight\" ]. setdefault ( module , [] ) else : attach_comments_to = categorized_comments [ \"straight\" ]. setdefault ( f \"{module} as {as_name}\" , [] ) del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose and not config . only_modified : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type : ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ]. setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments and attach_comments_to is None : attach_comments_to = categorized_comments [ \"from\" ]. setdefault ( import_from , []) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines [ -1 ]. rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ) : categorized_comments [ \"above\" ][ \"from\" ]. setdefault ( import_from , []). insert ( 0 , out_lines . pop ( -1 ) ) if out_lines : last = out_lines [ -1 ]. rstrip () else : last = \"\" if statement_index - 1 == import_index : # pragma : no cover import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ]. get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , module in direct_imports ) for module in just_imports ) else : root [ import_from ]. update ( ( module , root [ import_from ]. get ( module , False ) or module in direct_imports ) for module in just_imports ) if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) else : if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) comments = [] for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines [ -1 ]. rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ) : categorized_comments [ \"above\" ][ \"straight\" ]. setdefault ( module , []). insert ( 0 , out_lines . pop ( -1 ) ) if out_lines : last = out_lines [ -1 ]. rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ]. get ( module , []) ) placed_module = finder ( module ) if config . verbose and not config . only_modified : print ( f \"else-type place_module for {module} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) if placed_module and placed_module not in imports : raise MissingSection ( import_module = module , section = placed_module ) straight_import |= imports [ placed_module ][ type_of_import ]. get ( # type : ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type : ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , verbose_output = verbose_output , ) import_type def import_type ( line : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> Union [ str , NoneType ] If the current line is an import line it will return its type (from or straight) View Source def import_type ( line : str , config : Config = DEFAULT_CONFIG ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if config . honor_noqa and line . lower () . rstrip () . endswith ( \"noqa\" ): return None if \"isort:skip\" in line or \"isort: skip\" in line or \"isort: split\" in line : return None if line . startswith (( \"import \" , \"cimport \" )): return \"straight\" if line . startswith ( \"from \" ): return \"from\" return None skip_line def skip_line ( line : str , in_quote : str , index : int , section_comments : Tuple [ str , ... ], needs_import : bool = True ) -> Tuple [ bool , str ] Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) View Source def skip_line ( line : str , in_quote : str , index : int , section_comments : Tuple [ str , ...], needs_import : bool = True , ) -> Tuple [ bool , str ] : \"\"\"Determine if a given line should be skipped. Returns back a tuple containing : ( skip_line : bool , in_quote : str ,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ) : long_quote = line [ char_index : char_index + 3 ] if long_quote in ( ' \"\"\"', \" ''' \"): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \" ; \" in line.split(\" # \")[0] and needs_import: for part in ( part . strip () for part in line . split ( \";\" )) : if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ) : should_skip = True return ( bool ( should_skip or in_quote ), in_quote ) Classes ParsedContent class ParsedContent ( / , * args , ** kwargs ) ParsedContent(in_lines, lines_without_imports, import_index, place_imports, import_placements, as_map, imports, categorized_comments, change_count, original_line_count, line_separator, sections, verbose_output) View Source class ParsedContent ( NamedTuple ) : in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str, List[str ] ] import_placements : Dict [ str, str ] as_map : Dict [ str, Dict[str, List[str ] ]] imports : Dict [ str, Dict[str, Any ] ] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any verbose_output : List [ str ] Ancestors (in MRO) builtins.tuple Class variables as_map categorized_comments change_count import_index import_placements imports in_lines line_separator lines_without_imports original_line_count place_imports sections verbose_output Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"Parse"},{"location":"reference/isort/parse/#module-isortparse","text":"Defines parsing functions used by isort for parsing import definitions View Source \"\"\"Defines parsing functions used by isort for parsing import definitions\"\"\" from collections import OrderedDict , defaultdict from functools import partial from itertools import chain from typing import TYPE_CHECKING , Any , Dict , List , NamedTuple , Optional , Tuple from warnings import warn from . import place from .comments import parse as parse_comments from .deprecated.finders import FindersManager from .exceptions import MissingSection from .settings import DEFAULT_CONFIG , Config if TYPE_CHECKING : from mypy_extensions import TypedDict CommentsAboveDict = TypedDict ( \"CommentsAboveDict\" , { \"straight\" : Dict [ str , Any ], \"from\" : Dict [ str , Any ]} ) CommentsDict = TypedDict ( \"CommentsDict\" , { \"from\" : Dict [ str , Any ], \"straight\" : Dict [ str , Any ], \"nested\" : Dict [ str , Any ], \"above\" : CommentsAboveDict , }, ) def _infer_line_separator ( contents : str ) -> str : if \" \\r\\n \" in contents : return \" \\r\\n \" if \" \\r \" in contents : return \" \\r \" return \" \\n \" def _normalize_line ( raw_line : str ) -> Tuple [ str , str ]: \"\"\"Normalizes import related statements in the provided line. Returns (normalized_line: str, raw_line: str) \"\"\" line = raw_line . replace ( \"from.import \" , \"from . import \" ) line = line . replace ( \"from.cimport \" , \"from . cimport \" ) line = line . replace ( \"import*\" , \"import *\" ) line = line . replace ( \" .import \" , \" . import \" ) line = line . replace ( \" .cimport \" , \" . cimport \" ) line = line . replace ( \" \\t \" , \" \" ) return ( line , raw_line ) def import_type ( line : str , config : Config = DEFAULT_CONFIG ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if config . honor_noqa and line . lower () . rstrip () . endswith ( \"noqa\" ): return None if \"isort:skip\" in line or \"isort: skip\" in line or \"isort: split\" in line : return None if line . startswith (( \"import \" , \"cimport \" )): return \"straight\" if line . startswith ( \"from \" ): return \"from\" return None def _strip_syntax ( import_string : str ) -> str : import_string = import_string . replace ( \"_import\" , \"[[i]]\" ) import_string = import_string . replace ( \"_cimport\" , \"[[ci]]\" ) for remove_syntax in [ \" \\\\ \" , \"(\" , \")\" , \",\" ]: import_string = import_string . replace ( remove_syntax , \" \" ) import_list = import_string . split () for key in ( \"from\" , \"import\" , \"cimport\" ): if key in import_list : import_list . remove ( key ) import_string = \" \" . join ( import_list ) import_string = import_string . replace ( \"[[i]]\" , \"_import\" ) import_string = import_string . replace ( \"[[ci]]\" , \"_cimport\" ) return import_string . replace ( \"{ \" , \"{|\" ) . replace ( \" }\" , \"|}\" ) def skip_line ( line : str , in_quote : str , index : int , section_comments : Tuple [ str , ... ], needs_import : bool = True , ) -> Tuple [ bool , str ]: \"\"\"Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ): if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ): long_quote = line [ char_index : char_index + 3 ] if long_quote in ( '\"\"\"' , \"'''\" ): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \";\" in line . split ( \"#\" )[ 0 ] and needs_import : for part in ( part . strip () for part in line . split ( \";\" )): if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ): should_skip = True return ( bool ( should_skip or in_quote ), in_quote ) class ParsedContent ( NamedTuple ): in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str , List [ str ]] import_placements : Dict [ str , str ] as_map : Dict [ str , Dict [ str , List [ str ]]] imports : Dict [ str , Dict [ str , Any ]] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any verbose_output : List [ str ] def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . splitlines () if contents and contents [ - 1 ] in ( \" \\n \" , \" \\r \" ): in_lines . append ( \"\" ) out_lines = [] original_line_count = len ( in_lines ) if config . old_finders : finder = FindersManager ( config = config ) . find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , Dict [ str , List [ str ]]] = { \"straight\" : defaultdict ( list ), \"from\" : defaultdict ( list ), } imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () verbose_output : List [ str ] = [] for section in chain ( config . sections , config . forced_separate ): imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = - 1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if line in config . section_comments and not skipping_line : if import_index == - 1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort:imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ): section = line . split ( \"isort: imports-\" )[ - 1 ] . split ()[ 0 ] . upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue lstripped_line = line . lstrip () if ( config . float_to_top and import_index == - 1 and line and not in_quote and not lstripped_line . startswith ( \"#\" ) and not lstripped_line . startswith ( \"'''\" ) and not lstripped_line . startswith ( '\"\"\"' ) ): if not lstripped_line . startswith ( \"import\" ) and not lstripped_line . startswith ( \"from\" ): import_index = index - 1 while import_index and not in_lines [ import_index - 1 ]: import_index -= 1 else : commentless = line . split ( \"#\" , 1 )[ 0 ] . strip () if ( ( \"isort:skip\" in line or \"isort: skip\" in line ) and \"(\" in commentless and \")\" not in commentless ): import_index = index starting_line = line while \"isort:skip\" in starting_line or \"isort: skip\" in starting_line : commentless = starting_line . split ( \"#\" , 1 )[ 0 ] if ( \"(\" in commentless and not commentless . rstrip () . endswith ( \")\" ) and import_index < line_count ): while import_index < line_count and not commentless . rstrip () . endswith ( \")\" ): commentless = in_lines [ import_index ] . split ( \"#\" , 1 )[ 0 ] import_index += 1 else : import_index += 1 if import_index >= line_count : break starting_line = in_lines [ import_index ] line , * end_of_line_comment = line . split ( \"#\" , 1 ) if \";\" in line : statements = [ line . strip () for line in line . split ( \";\" )] else : statements = [ line ] if end_of_line_comment : statements [ - 1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , raw_line = _normalize_line ( statement ) type_of_import = import_type ( line , config ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == - 1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ) . strip () . split ( \" \" ) if part ] if type_of_import == \"from\" and len ( line_parts ) == 2 and comments : nested_comments [ line_parts [ - 1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" , 1 )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line else : while line . strip () . endswith ( \" \\\\ \" ): line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ): stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ] . strip () . endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ) . strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ): nested_comments [ stripped_line ] = comments [ - 1 ] if import_string . strip () . endswith ( ( \" import\" , \" cimport\" ) ) or line . strip () . startswith (( \"import \" , \"cimport \" )): import_string += line_separator + line else : import_string = import_string . rstrip () . rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ] . split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ) . join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 :])] + parts [ 1 :] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ) . replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ) . split () ] attach_comments_to : Optional [ List [ Any ]] = None direct_imports = just_imports [ 1 :] straight_import = True top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ): straight_import = False while \"as\" in just_imports : nested_module = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : nested_module = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + nested_module as_name = just_imports [ as_index + 1 ] direct_imports . remove ( nested_module ) direct_imports . remove ( as_name ) direct_imports . remove ( \"as\" ) if nested_module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"from\" ][ module ]: as_map [ \"from\" ][ module ] . append ( as_name ) full_name = f \"{nested_module} as {as_name}\" associated_comment = nested_comments . get ( full_name ) if associated_comment : categorized_comments [ \"nested\" ] . setdefault ( top_level_module , {})[ full_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"straight\" ][ module ]: as_map [ \"straight\" ][ module ] . append ( as_name ) if comments and attach_comments_to is None : if nested_module and config . combine_as_imports : attach_comments_to = categorized_comments [ \"from\" ] . setdefault ( f \"{top_level_module}.__combined_as__\" , [] ) else : if type_of_import == \"from\" or ( config . remove_redundant_aliases and as_name == module . split ( \".\" )[ - 1 ] ): attach_comments_to = categorized_comments [ \"straight\" ] . setdefault ( module , [] ) else : attach_comments_to = categorized_comments [ \"straight\" ] . setdefault ( f \"{module} as {as_name}\" , [] ) del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose and not config . only_modified : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type: ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ] . setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments and attach_comments_to is None : attach_comments_to = categorized_comments [ \"from\" ] . setdefault ( import_from , []) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines [ - 1 ] . rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ): categorized_comments [ \"above\" ][ \"from\" ] . setdefault ( import_from , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if statement_index - 1 == import_index : # pragma: no cover import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ] . get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , module in direct_imports ) for module in just_imports ) else : root [ import_from ] . update ( ( module , root [ import_from ] . get ( module , False ) or module in direct_imports ) for module in just_imports ) if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) else : if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) comments = [] for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines [ - 1 ] . rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( '\"\"\"' ) and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ): categorized_comments [ \"above\" ][ \"straight\" ] . setdefault ( module , []) . insert ( 0 , out_lines . pop ( - 1 ) ) if out_lines : last = out_lines [ - 1 ] . rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ] . get ( module , []) ) placed_module = finder ( module ) if config . verbose and not config . only_modified : print ( f \"else-type place_module for {module} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) if placed_module and placed_module not in imports : raise MissingSection ( import_module = module , section = placed_module ) straight_import |= imports [ placed_module ][ type_of_import ] . get ( # type: ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type: ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , verbose_output = verbose_output , )","title":"Module isort.parse"},{"location":"reference/isort/parse/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/isort/parse/#functions","text":"","title":"Functions"},{"location":"reference/isort/parse/#file_contents","text":"def file_contents ( contents : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> isort . parse . ParsedContent Parses a python file taking out and categorizing imports. View Source def file_contents ( contents : str , config : Config = DEFAULT_CONFIG ) -> ParsedContent : \"\"\"Parses a python file taking out and categorizing imports.\"\"\" line_separator : str = config . line_ending or _infer_line_separator ( contents ) in_lines = contents . splitlines () if contents and contents [ -1 ] in ( \" \\n \" , \" \\r \" ) : in_lines . append ( \"\" ) out_lines = [] original_line_count = len ( in_lines ) if config . old_finders : finder = FindersManager ( config = config ). find else : finder = partial ( place . module , config = config ) line_count = len ( in_lines ) place_imports : Dict [ str , List [ str ]] = {} import_placements : Dict [ str , str ] = {} as_map : Dict [ str , Dict [ str , List [ str ]]] = { \"straight\" : defaultdict ( list ), \"from\" : defaultdict ( list ), } imports : OrderedDict [ str , Dict [ str , Any ]] = OrderedDict () verbose_output : List [ str ] = [] for section in chain ( config . sections , config . forced_separate ) : imports [ section ] = { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()} categorized_comments : CommentsDict = { \"from\" : {}, \"straight\" : {}, \"nested\" : {}, \"above\" : { \"straight\" : {}, \"from\" : {}}, } index = 0 import_index = -1 in_quote = \"\" while index < line_count : line = in_lines [ index ] index += 1 statement_index = index ( skipping_line , in_quote ) = skip_line ( line , in_quote = in_quote , index = index , section_comments = config . section_comments ) if line in config . section_comments and not skipping_line : if import_index == -1 : import_index = index - 1 continue if \"isort:imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort:imports-\" )[ -1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section elif \"isort: imports-\" in line and line . startswith ( \"#\" ) : section = line . split ( \"isort: imports-\" )[ -1 ]. split ()[ 0 ]. upper () place_imports [ section ] = [] import_placements [ line ] = section if skipping_line : out_lines . append ( line ) continue lstripped_line = line . lstrip () if ( config . float_to_top and import_index == -1 and line and not in_quote and not lstripped_line . startswith ( \"#\" ) and not lstripped_line . startswith ( \"'''\" ) and not lstripped_line . startswith ( ' \"\"\"') ) : if not lstripped_line . startswith ( \"import\" ) and not lstripped_line . startswith ( \"from\" ) : import_index = index - 1 while import_index and not in_lines [ import_index - 1 ] : import_index -= 1 else : commentless = line . split ( \"#\" , 1 )[ 0 ]. strip () if ( ( \"isort:skip\" in line or \"isort: skip\" in line ) and \"(\" in commentless and \")\" not in commentless ) : import_index = index starting_line = line while \"isort:skip\" in starting_line or \"isort: skip\" in starting_line : commentless = starting_line . split ( \"#\" , 1 )[ 0 ] if ( \"(\" in commentless and not commentless . rstrip (). endswith ( \")\" ) and import_index < line_count ) : while import_index < line_count and not commentless . rstrip (). endswith ( \")\" ) : commentless = in_lines [ import_index ]. split ( \"#\" , 1 )[ 0 ] import_index += 1 else : import_index += 1 if import_index >= line_count : break starting_line = in_lines [ import_index ] line , * end_of_line_comment = line . split ( \"#\" , 1 ) if \";\" in line : statements = [ line . strip () for line in line . split ( \";\" )] else : statements = [ line ] if end_of_line_comment : statements [ -1 ] = f \"{statements[-1]}#{end_of_line_comment[0]}\" for statement in statements : line , raw_line = _normalize_line ( statement ) type_of_import = import_type ( line , config ) or \"\" if not type_of_import : out_lines . append ( raw_line ) continue if import_index == -1 : import_index = index - 1 nested_comments = {} import_string , comment = parse_comments ( line ) comments = [ comment ] if comment else [] line_parts = [ part for part in _strip_syntax ( import_string ). strip (). split ( \" \" ) if part ] if type_of_import == \"from\" and len ( line_parts ) == 2 and comments : nested_comments [ line_parts [ -1 ]] = comments [ 0 ] if \"(\" in line . split ( \"#\" , 1 )[ 0 ] and index < line_count : while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] import_string += line_separator + line else : while line . strip (). endswith ( \" \\\\ \" ) : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) # Still need to check for parentheses after an escaped line if ( \"(\" in line . split ( \"#\" )[ 0 ] and \")\" not in line . split ( \"#\" )[ 0 ] and index < line_count ) : stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] import_string += line_separator + line while not line . split ( \"#\" )[ 0 ]. strip (). endswith ( \")\" ) and index < line_count : line , new_comment = parse_comments ( in_lines [ index ]) index += 1 if new_comment : comments . append ( new_comment ) stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] import_string += line_separator + line stripped_line = _strip_syntax ( line ). strip () if ( type_of_import == \"from\" and stripped_line and \" \" not in stripped_line . replace ( \" as \" , \"\" ) and new_comment ) : nested_comments [ stripped_line ] = comments [ -1 ] if import_string . strip (). endswith ( ( \" import\" , \" cimport\" ) ) or line . strip (). startswith (( \"import \" , \"cimport \" )) : import_string += line_separator + line else : import_string = import_string . rstrip (). rstrip ( \" \\\\ \" ) + \" \" + line . lstrip () if type_of_import == \"from\" : cimports : bool import_string = ( import_string . replace ( \"import(\" , \"import (\" ) . replace ( \" \\\\ \" , \" \" ) . replace ( \" \\n \" , \" \" ) ) if \" cimport \" in import_string : parts = import_string . split ( \" cimport \" ) cimports = True else : parts = import_string . split ( \" import \" ) cimports = False from_import = parts [ 0 ]. split ( \" \" ) import_string = ( \" cimport \" if cimports else \" import \" ). join ( [ from_import [ 0 ] + \" \" + \"\" . join ( from_import [ 1 : ])] + parts [ 1 : ] ) just_imports = [ item . replace ( \"{|\" , \"{ \" ). replace ( \"|}\" , \" }\" ) for item in _strip_syntax ( import_string ). split () ] attach_comments_to : Optional [ List [ Any ]] = None direct_imports = just_imports [ 1 : ] straight_import = True top_level_module = \"\" if \"as\" in just_imports and ( just_imports . index ( \"as\" ) + 1 ) < len ( just_imports ) : straight_import = False while \"as\" in just_imports : nested_module = None as_index = just_imports . index ( \"as\" ) if type_of_import == \"from\" : nested_module = just_imports [ as_index - 1 ] top_level_module = just_imports [ 0 ] module = top_level_module + \".\" + nested_module as_name = just_imports [ as_index + 1 ] direct_imports . remove ( nested_module ) direct_imports . remove ( as_name ) direct_imports . remove ( \"as\" ) if nested_module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"from\" ][ module ] : as_map [ \"from\" ][ module ]. append ( as_name ) full_name = f \"{nested_module} as {as_name}\" associated_comment = nested_comments . get ( full_name ) if associated_comment : categorized_comments [ \"nested\" ]. setdefault ( top_level_module , {})[ full_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) else : module = just_imports [ as_index - 1 ] as_name = just_imports [ as_index + 1 ] if module == as_name and config . remove_redundant_aliases : pass elif as_name not in as_map [ \"straight\" ][ module ] : as_map [ \"straight\" ][ module ]. append ( as_name ) if comments and attach_comments_to is None : if nested_module and config . combine_as_imports : attach_comments_to = categorized_comments [ \"from\" ]. setdefault ( f \"{top_level_module}.__combined_as__\" , [] ) else : if type_of_import == \"from\" or ( config . remove_redundant_aliases and as_name == module . split ( \".\" )[ -1 ] ) : attach_comments_to = categorized_comments [ \"straight\" ]. setdefault ( module , [] ) else : attach_comments_to = categorized_comments [ \"straight\" ]. setdefault ( f \"{module} as {as_name}\" , [] ) del just_imports [ as_index : as_index + 2 ] if type_of_import == \"from\" : import_from = just_imports . pop ( 0 ) placed_module = finder ( import_from ) if config . verbose and not config . only_modified : print ( f \"from-type place_module for {import_from} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"from-type place_module for {import_from} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {import_from} of line {line} --\" \" Do you need to define a default section?\" ) root = imports [ placed_module ][ type_of_import ] # type : ignore for import_name in just_imports : associated_comment = nested_comments . get ( import_name ) if associated_comment : categorized_comments [ \"nested\" ]. setdefault ( import_from , {})[ import_name ] = associated_comment if associated_comment in comments : comments . pop ( comments . index ( associated_comment )) if comments and attach_comments_to is None : attach_comments_to = categorized_comments [ \"from\" ]. setdefault ( import_from , []) if len ( out_lines ) > max ( import_index , 1 ) - 1 : last = out_lines [ -1 ]. rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ) : categorized_comments [ \"above\" ][ \"from\" ]. setdefault ( import_from , []). insert ( 0 , out_lines . pop ( -1 ) ) if out_lines : last = out_lines [ -1 ]. rstrip () else : last = \"\" if statement_index - 1 == import_index : # pragma : no cover import_index -= len ( categorized_comments [ \"above\" ][ \"from\" ]. get ( import_from , []) ) if import_from not in root : root [ import_from ] = OrderedDict ( ( module , module in direct_imports ) for module in just_imports ) else : root [ import_from ]. update ( ( module , root [ import_from ]. get ( module , False ) or module in direct_imports ) for module in just_imports ) if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) else : if comments and attach_comments_to is not None : attach_comments_to . extend ( comments ) comments = [] for module in just_imports : if comments : categorized_comments [ \"straight\" ][ module ] = comments comments = [] if len ( out_lines ) > max ( import_index , + 1 , 1 ) - 1 : last = out_lines [ -1 ]. rstrip () if out_lines else \"\" while ( last . startswith ( \"#\" ) and not last . endswith ( ' \"\"\"') and not last . endswith ( \"'''\" ) and \"isort:imports-\" not in last and \"isort: imports-\" not in last and not config . treat_all_comments_as_code and not last . strip () in config . treat_comments_as_code ) : categorized_comments [ \"above\" ][ \"straight\" ]. setdefault ( module , []). insert ( 0 , out_lines . pop ( -1 ) ) if out_lines : last = out_lines [ -1 ]. rstrip () else : last = \"\" if index - 1 == import_index : import_index -= len ( categorized_comments [ \"above\" ][ \"straight\" ]. get ( module , []) ) placed_module = finder ( module ) if config . verbose and not config . only_modified : print ( f \"else-type place_module for {module} returned {placed_module}\" ) elif config . verbose : verbose_output . append ( f \"else-type place_module for {module} returned {placed_module}\" ) if placed_module == \"\" : warn ( f \"could not place module {module} of line {line} --\" \" Do you need to define a default section?\" ) imports . setdefault ( \"\" , { \"straight\" : OrderedDict (), \"from\" : OrderedDict ()}) if placed_module and placed_module not in imports : raise MissingSection ( import_module = module , section = placed_module ) straight_import |= imports [ placed_module ][ type_of_import ]. get ( # type : ignore module , False ) imports [ placed_module ][ type_of_import ][ module ] = straight_import # type : ignore change_count = len ( out_lines ) - original_line_count return ParsedContent ( in_lines = in_lines , lines_without_imports = out_lines , import_index = import_index , place_imports = place_imports , import_placements = import_placements , as_map = as_map , imports = imports , categorized_comments = categorized_comments , change_count = change_count , original_line_count = original_line_count , line_separator = line_separator , sections = config . sections , verbose_output = verbose_output , )","title":"file_contents"},{"location":"reference/isort/parse/#import_type","text":"def import_type ( line : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> Union [ str , NoneType ] If the current line is an import line it will return its type (from or straight) View Source def import_type ( line : str , config : Config = DEFAULT_CONFIG ) -> Optional [ str ]: \"\"\"If the current line is an import line it will return its type (from or straight)\"\"\" if config . honor_noqa and line . lower () . rstrip () . endswith ( \"noqa\" ): return None if \"isort:skip\" in line or \"isort: skip\" in line or \"isort: split\" in line : return None if line . startswith (( \"import \" , \"cimport \" )): return \"straight\" if line . startswith ( \"from \" ): return \"from\" return None","title":"import_type"},{"location":"reference/isort/parse/#skip_line","text":"def skip_line ( line : str , in_quote : str , index : int , section_comments : Tuple [ str , ... ], needs_import : bool = True ) -> Tuple [ bool , str ] Determine if a given line should be skipped. Returns back a tuple containing: (skip_line: bool, in_quote: str,) View Source def skip_line ( line : str , in_quote : str , index : int , section_comments : Tuple [ str , ...], needs_import : bool = True , ) -> Tuple [ bool , str ] : \"\"\"Determine if a given line should be skipped. Returns back a tuple containing : ( skip_line : bool , in_quote : str ,) \"\"\" should_skip = bool ( in_quote ) if '\"' in line or \"'\" in line : char_index = 0 while char_index < len ( line ) : if line [ char_index ] == \" \\\\ \" : char_index += 1 elif in_quote : if line [ char_index : char_index + len ( in_quote )] == in_quote : in_quote = \"\" elif line [ char_index ] in ( \"'\" , '\"' ) : long_quote = line [ char_index : char_index + 3 ] if long_quote in ( ' \"\"\"', \" ''' \"): in_quote = long_quote char_index += 2 else : in_quote = line [ char_index ] elif line [ char_index ] == \"#\" : break char_index += 1 if \" ; \" in line.split(\" # \")[0] and needs_import: for part in ( part . strip () for part in line . split ( \";\" )) : if ( part and not part . startswith ( \"from \" ) and not part . startswith (( \"import \" , \"cimport \" )) ) : should_skip = True return ( bool ( should_skip or in_quote ), in_quote )","title":"skip_line"},{"location":"reference/isort/parse/#classes","text":"","title":"Classes"},{"location":"reference/isort/parse/#parsedcontent","text":"class ParsedContent ( / , * args , ** kwargs ) ParsedContent(in_lines, lines_without_imports, import_index, place_imports, import_placements, as_map, imports, categorized_comments, change_count, original_line_count, line_separator, sections, verbose_output) View Source class ParsedContent ( NamedTuple ) : in_lines : List [ str ] lines_without_imports : List [ str ] import_index : int place_imports : Dict [ str, List[str ] ] import_placements : Dict [ str, str ] as_map : Dict [ str, Dict[str, List[str ] ]] imports : Dict [ str, Dict[str, Any ] ] categorized_comments : \"CommentsDict\" change_count : int original_line_count : int line_separator : str sections : Any verbose_output : List [ str ]","title":"ParsedContent"},{"location":"reference/isort/parse/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/isort/parse/#class-variables","text":"as_map categorized_comments change_count import_index import_placements imports in_lines line_separator lines_without_imports original_line_count place_imports sections verbose_output","title":"Class variables"},{"location":"reference/isort/parse/#methods","text":"","title":"Methods"},{"location":"reference/isort/parse/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/isort/parse/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/isort/place/","text":"Module isort.place Contains all logic related to placing an import within a certain section. View Source \"\"\"Contains all logic related to placing an import within a certain section.\"\"\" import importlib from fnmatch import fnmatch from functools import lru_cache from pathlib import Path from typing import FrozenSet , Iterable , Optional , Tuple from isort import sections from isort.settings import DEFAULT_CONFIG , Config from isort.utils import exists_case_sensitive LOCAL = \"LOCALFOLDER\" def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ] @lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ]: \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate ( name , config ) or _local ( name , config ) or _known_pattern ( name , config ) or _src_path ( name , config ) or ( config . default_section , \"Default option in Config or universal default.\" ) ) def _forced_separate ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: for forced_separate in config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ): path_glob = \" %s *\" % forced_separate if fnmatch ( name , path_glob ) or fnmatch ( name , \".\" + path_glob ): return ( forced_separate , f \"Matched forced_separate ({forced_separate}) config value.\" ) return None def _local ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: if name . startswith ( \".\" ): return ( LOCAL , \"Module name started with a dot.\" ) return None def _known_pattern ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: parts = name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [: first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in config . known_patterns : if placement in config . sections and pattern . match ( module_name_to_check ): return ( placement , f \"Matched configured known pattern {pattern}\" ) return None def _src_path ( name : str , config : Config , src_paths : Optional [ Iterable [ Path ]] = None , prefix : Tuple [ str , ... ] = (), ) -> Optional [ Tuple [ str , str ]]: if src_paths is None : src_paths = config . src_paths root_module_name , * nested_module = name . split ( \".\" , 1 ) new_prefix = prefix + ( root_module_name ,) namespace = \".\" . join ( new_prefix ) for src_path in src_paths : module_path = ( src_path / root_module_name ) . resolve () if not prefix and not module_path . is_dir () and src_path . name == root_module_name : module_path = src_path . resolve () if nested_module and ( namespace in config . namespace_packages or ( config . auto_identify_namespace_packages and _is_namespace_package ( module_path , config . supported_extensions ) ) ): return _src_path ( nested_module [ 0 ], config , ( module_path ,), new_prefix ) if ( _is_module ( module_path ) or _is_package ( module_path ) or _src_path_is_module ( src_path , root_module_name ) ): return ( sections . FIRSTPARTY , f \"Found in one of the configured src_paths: {src_path}.\" ) return None def _is_module ( path : Path ) -> bool : return ( exists_case_sensitive ( str ( path . with_suffix ( \".py\" ))) or any ( exists_case_sensitive ( str ( path . with_suffix ( ext_suffix ))) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( str ( path / \"__init__.py\" )) ) def _is_package ( path : Path ) -> bool : return exists_case_sensitive ( str ( path )) and path . is_dir () def _is_namespace_package ( path : Path , src_extensions : FrozenSet [ str ]) -> bool : if not _is_package ( path ): return False init_file = path / \"__init__.py\" if not init_file . exists (): filenames = [ filepath for filepath in path . iterdir () if filepath . suffix . lstrip ( \".\" ) in src_extensions or filepath . name . lower () in ( \"setup.cfg\" , \"pyproject.toml\" ) ] if filenames : return False else : with init_file . open () as open_init_file : file_start = open_init_file . read ( 4096 ) if ( \"__import__('pkg_resources').declare_namespace(__name__)\" not in file_start and '__import__(\"pkg_resources\").declare_namespace(__name__)' not in file_start and \"__path__ = __import__('pkgutil').extend_path(__path__, __name__)\" not in file_start and '__path__ = __import__(\"pkgutil\").extend_path(__path__, __name__)' not in file_start ): return False return True def _src_path_is_module ( src_path : Path , module_name : str ) -> bool : return ( module_name == src_path . name and src_path . is_dir () and exists_case_sensitive ( str ( src_path )) ) Variables LOCAL Functions module def module ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> str Returns the section placement for the given module name. View Source def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ] module_with_reason def module_with_reason ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> Tuple [ str , str ] Returns the section placement for the given module name alongside the reasoning. View Source @ lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ] : \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate(name, config) or _local(name, config) or _known_pattern(name, config) or _src_path(name, config) or (config.default_section, \"Default option in Config or universal default.\") )","title":"Place"},{"location":"reference/isort/place/#module-isortplace","text":"Contains all logic related to placing an import within a certain section. View Source \"\"\"Contains all logic related to placing an import within a certain section.\"\"\" import importlib from fnmatch import fnmatch from functools import lru_cache from pathlib import Path from typing import FrozenSet , Iterable , Optional , Tuple from isort import sections from isort.settings import DEFAULT_CONFIG , Config from isort.utils import exists_case_sensitive LOCAL = \"LOCALFOLDER\" def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ] @lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ]: \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate ( name , config ) or _local ( name , config ) or _known_pattern ( name , config ) or _src_path ( name , config ) or ( config . default_section , \"Default option in Config or universal default.\" ) ) def _forced_separate ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: for forced_separate in config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ): path_glob = \" %s *\" % forced_separate if fnmatch ( name , path_glob ) or fnmatch ( name , \".\" + path_glob ): return ( forced_separate , f \"Matched forced_separate ({forced_separate}) config value.\" ) return None def _local ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: if name . startswith ( \".\" ): return ( LOCAL , \"Module name started with a dot.\" ) return None def _known_pattern ( name : str , config : Config ) -> Optional [ Tuple [ str , str ]]: parts = name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [: first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in config . known_patterns : if placement in config . sections and pattern . match ( module_name_to_check ): return ( placement , f \"Matched configured known pattern {pattern}\" ) return None def _src_path ( name : str , config : Config , src_paths : Optional [ Iterable [ Path ]] = None , prefix : Tuple [ str , ... ] = (), ) -> Optional [ Tuple [ str , str ]]: if src_paths is None : src_paths = config . src_paths root_module_name , * nested_module = name . split ( \".\" , 1 ) new_prefix = prefix + ( root_module_name ,) namespace = \".\" . join ( new_prefix ) for src_path in src_paths : module_path = ( src_path / root_module_name ) . resolve () if not prefix and not module_path . is_dir () and src_path . name == root_module_name : module_path = src_path . resolve () if nested_module and ( namespace in config . namespace_packages or ( config . auto_identify_namespace_packages and _is_namespace_package ( module_path , config . supported_extensions ) ) ): return _src_path ( nested_module [ 0 ], config , ( module_path ,), new_prefix ) if ( _is_module ( module_path ) or _is_package ( module_path ) or _src_path_is_module ( src_path , root_module_name ) ): return ( sections . FIRSTPARTY , f \"Found in one of the configured src_paths: {src_path}.\" ) return None def _is_module ( path : Path ) -> bool : return ( exists_case_sensitive ( str ( path . with_suffix ( \".py\" ))) or any ( exists_case_sensitive ( str ( path . with_suffix ( ext_suffix ))) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( str ( path / \"__init__.py\" )) ) def _is_package ( path : Path ) -> bool : return exists_case_sensitive ( str ( path )) and path . is_dir () def _is_namespace_package ( path : Path , src_extensions : FrozenSet [ str ]) -> bool : if not _is_package ( path ): return False init_file = path / \"__init__.py\" if not init_file . exists (): filenames = [ filepath for filepath in path . iterdir () if filepath . suffix . lstrip ( \".\" ) in src_extensions or filepath . name . lower () in ( \"setup.cfg\" , \"pyproject.toml\" ) ] if filenames : return False else : with init_file . open () as open_init_file : file_start = open_init_file . read ( 4096 ) if ( \"__import__('pkg_resources').declare_namespace(__name__)\" not in file_start and '__import__(\"pkg_resources\").declare_namespace(__name__)' not in file_start and \"__path__ = __import__('pkgutil').extend_path(__path__, __name__)\" not in file_start and '__path__ = __import__(\"pkgutil\").extend_path(__path__, __name__)' not in file_start ): return False return True def _src_path_is_module ( src_path : Path , module_name : str ) -> bool : return ( module_name == src_path . name and src_path . is_dir () and exists_case_sensitive ( str ( src_path )) )","title":"Module isort.place"},{"location":"reference/isort/place/#variables","text":"LOCAL","title":"Variables"},{"location":"reference/isort/place/#functions","text":"","title":"Functions"},{"location":"reference/isort/place/#module","text":"def module ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> str Returns the section placement for the given module name. View Source def module ( name : str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns the section placement for the given module name.\"\"\" return module_with_reason ( name , config )[ 0 ]","title":"module"},{"location":"reference/isort/place/#module_with_reason","text":"def module_with_reason ( name : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> Tuple [ str , str ] Returns the section placement for the given module name alongside the reasoning. View Source @ lru_cache ( maxsize = 1000 ) def module_with_reason ( name : str , config : Config = DEFAULT_CONFIG ) -> Tuple [ str , str ] : \"\"\"Returns the section placement for the given module name alongside the reasoning.\"\"\" return ( _forced_separate(name, config) or _local(name, config) or _known_pattern(name, config) or _src_path(name, config) or (config.default_section, \"Default option in Config or universal default.\") )","title":"module_with_reason"},{"location":"reference/isort/profiles/","text":"Module isort.profiles Common profiles are defined here to be easily used within a project using --profile {name} View Source \"\"\"Common profiles are defined here to be easily used within a project using --profile {name}\"\"\" from typing import Any , Dict black = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"ensure_newline_before_comments\" : True , \"line_length\" : 88 , } django = { \"combine_as_imports\" : True , \"include_trailing_comma\" : True , \"multi_line_output\" : 5 , \"line_length\" : 79 , } pycharm = { \"multi_line_output\" : 3 , \"force_grid_wrap\" : 2 , \"lines_after_imports\" : 2 , } google = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , \"single_line_exclusions\" : ( \"typing\" ,), \"order_by_type\" : False , \"group_by_package\" : True , } open_stack = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , } plone = { \"force_alphabetical_sort\" : True , \"force_single_line\" : True , \"lines_after_imports\" : 2 , \"line_length\" : 200 , } attrs = { \"atomic\" : True , \"force_grid_wrap\" : 0 , \"include_trailing_comma\" : True , \"lines_after_imports\" : 2 , \"lines_between_types\" : 1 , \"multi_line_output\" : 3 , \"use_parentheses\" : True , } hug = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"line_length\" : 100 , } wemake = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"use_parentheses\" : True , \"line_length\" : 80 , } profiles : Dict [ str , Dict [ str , Any ]] = { \"black\" : black , \"django\" : django , \"pycharm\" : pycharm , \"google\" : google , \"open_stack\" : open_stack , \"plone\" : plone , \"attrs\" : attrs , \"hug\" : hug , \"wemake\" : wemake , } Variables attrs black django google hug open_stack plone profiles pycharm wemake","title":"Profiles"},{"location":"reference/isort/profiles/#module-isortprofiles","text":"Common profiles are defined here to be easily used within a project using --profile {name} View Source \"\"\"Common profiles are defined here to be easily used within a project using --profile {name}\"\"\" from typing import Any , Dict black = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"ensure_newline_before_comments\" : True , \"line_length\" : 88 , } django = { \"combine_as_imports\" : True , \"include_trailing_comma\" : True , \"multi_line_output\" : 5 , \"line_length\" : 79 , } pycharm = { \"multi_line_output\" : 3 , \"force_grid_wrap\" : 2 , \"lines_after_imports\" : 2 , } google = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , \"single_line_exclusions\" : ( \"typing\" ,), \"order_by_type\" : False , \"group_by_package\" : True , } open_stack = { \"force_single_line\" : True , \"force_sort_within_sections\" : True , \"lexicographical\" : True , } plone = { \"force_alphabetical_sort\" : True , \"force_single_line\" : True , \"lines_after_imports\" : 2 , \"line_length\" : 200 , } attrs = { \"atomic\" : True , \"force_grid_wrap\" : 0 , \"include_trailing_comma\" : True , \"lines_after_imports\" : 2 , \"lines_between_types\" : 1 , \"multi_line_output\" : 3 , \"use_parentheses\" : True , } hug = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"force_grid_wrap\" : 0 , \"use_parentheses\" : True , \"line_length\" : 100 , } wemake = { \"multi_line_output\" : 3 , \"include_trailing_comma\" : True , \"use_parentheses\" : True , \"line_length\" : 80 , } profiles : Dict [ str , Dict [ str , Any ]] = { \"black\" : black , \"django\" : django , \"pycharm\" : pycharm , \"google\" : google , \"open_stack\" : open_stack , \"plone\" : plone , \"attrs\" : attrs , \"hug\" : hug , \"wemake\" : wemake , }","title":"Module isort.profiles"},{"location":"reference/isort/profiles/#variables","text":"attrs black django google hug open_stack plone profiles pycharm wemake","title":"Variables"},{"location":"reference/isort/pylama_isort/","text":"Module isort.pylama_isort View Source import os import sys from contextlib import contextmanager from typing import Any , Dict , List from pylama.lint import Linter as BaseLinter from isort.exceptions import FileSkipped from . import api @contextmanager def supress_stdout (): stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout class Linter ( BaseLinter ): def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): try : if not api . check_file ( path , disregard_skip = False ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" , } ] except FileSkipped : pass return [] Functions supress_stdout def supress_stdout ( ) View Source @contextmanager def supress_stdout () : stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout Classes Linter class Linter ( / , * args , ** kwargs ) Abstract class for linter plugin. View Source class Linter ( BaseLinter ) : def allow ( self , path: str ) -> bool: \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path: str , ** meta: Any ) -> List [ Dict [ str , Any ]] : \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout () : try: if not api . check_file ( path , disregard_skip = False ) : return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" , } ] except FileSkipped: pass return [] Ancestors (in MRO) pylama.lint.Linter Methods allow def allow ( self , path : str ) -> bool Determine if this path should be linted. View Source def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) run def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]] Lint the file. Return an array of error dicts if appropriate. View Source def run ( self , path: str , ** meta: Any ) -> List [ Dict [ str , Any ]] : \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout () : try: if not api . check_file ( path , disregard_skip = False ) : return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" , } ] except FileSkipped: pass return []","title":"Pylama Isort"},{"location":"reference/isort/pylama_isort/#module-isortpylama_isort","text":"View Source import os import sys from contextlib import contextmanager from typing import Any , Dict , List from pylama.lint import Linter as BaseLinter from isort.exceptions import FileSkipped from . import api @contextmanager def supress_stdout (): stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout class Linter ( BaseLinter ): def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]]: \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout (): try : if not api . check_file ( path , disregard_skip = False ): return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" , } ] except FileSkipped : pass return []","title":"Module isort.pylama_isort"},{"location":"reference/isort/pylama_isort/#functions","text":"","title":"Functions"},{"location":"reference/isort/pylama_isort/#supress_stdout","text":"def supress_stdout ( ) View Source @contextmanager def supress_stdout () : stdout = sys . stdout with open ( os . devnull , \"w\" ) as devnull : sys . stdout = devnull yield sys . stdout = stdout","title":"supress_stdout"},{"location":"reference/isort/pylama_isort/#classes","text":"","title":"Classes"},{"location":"reference/isort/pylama_isort/#linter","text":"class Linter ( / , * args , ** kwargs ) Abstract class for linter plugin. View Source class Linter ( BaseLinter ) : def allow ( self , path: str ) -> bool: \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" ) def run ( self , path: str , ** meta: Any ) -> List [ Dict [ str , Any ]] : \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout () : try: if not api . check_file ( path , disregard_skip = False ) : return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" , } ] except FileSkipped: pass return []","title":"Linter"},{"location":"reference/isort/pylama_isort/#ancestors-in-mro","text":"pylama.lint.Linter","title":"Ancestors (in MRO)"},{"location":"reference/isort/pylama_isort/#methods","text":"","title":"Methods"},{"location":"reference/isort/pylama_isort/#allow","text":"def allow ( self , path : str ) -> bool Determine if this path should be linted. View Source def allow ( self , path : str ) -> bool : \"\"\"Determine if this path should be linted.\"\"\" return path . endswith ( \".py\" )","title":"allow"},{"location":"reference/isort/pylama_isort/#run","text":"def run ( self , path : str , ** meta : Any ) -> List [ Dict [ str , Any ]] Lint the file. Return an array of error dicts if appropriate. View Source def run ( self , path: str , ** meta: Any ) -> List [ Dict [ str , Any ]] : \"\"\"Lint the file. Return an array of error dicts if appropriate.\"\"\" with supress_stdout () : try: if not api . check_file ( path , disregard_skip = False ) : return [ { \"lnum\" : 0 , \"col\" : 0 , \"text\" : \"Incorrectly sorted imports.\" , \"type\" : \"ISORT\" , } ] except FileSkipped: pass return []","title":"run"},{"location":"reference/isort/sections/","text":"Module isort.sections Defines all sections isort uses by default View Source \"\"\"Defines all sections isort uses by default\"\"\" from typing import Tuple FUTURE : str = \"FUTURE\" STDLIB : str = \"STDLIB\" THIRDPARTY : str = \"THIRDPARTY\" FIRSTPARTY : str = \"FIRSTPARTY\" LOCALFOLDER : str = \"LOCALFOLDER\" DEFAULT : Tuple [ str , ... ] = ( FUTURE , STDLIB , THIRDPARTY , FIRSTPARTY , LOCALFOLDER ) Variables DEFAULT FIRSTPARTY FUTURE LOCALFOLDER STDLIB THIRDPARTY","title":"Sections"},{"location":"reference/isort/sections/#module-isortsections","text":"Defines all sections isort uses by default View Source \"\"\"Defines all sections isort uses by default\"\"\" from typing import Tuple FUTURE : str = \"FUTURE\" STDLIB : str = \"STDLIB\" THIRDPARTY : str = \"THIRDPARTY\" FIRSTPARTY : str = \"FIRSTPARTY\" LOCALFOLDER : str = \"LOCALFOLDER\" DEFAULT : Tuple [ str , ... ] = ( FUTURE , STDLIB , THIRDPARTY , FIRSTPARTY , LOCALFOLDER )","title":"Module isort.sections"},{"location":"reference/isort/sections/#variables","text":"DEFAULT FIRSTPARTY FUTURE LOCALFOLDER STDLIB THIRDPARTY","title":"Variables"},{"location":"reference/isort/settings/","text":"Module isort.settings isort/settings.py. Defines how the default settings for isort should be loaded View Source \"\"\"isort/settings.py. Defines how the default settings for isort should be loaded \"\"\" import configparser import fnmatch import os import posixpath import re import stat import subprocess # nosec: Needed for gitignore support. import sys from functools import lru_cache from pathlib import Path from typing import Any , Callable , Dict , FrozenSet , Iterable , List , Optional , Pattern , Set , Tuple from warnings import warn from . import stdlibs from ._future import dataclass , field from ._vendored import toml from .exceptions import ( FormattingPluginDoesNotExist , InvalidSettingsPath , ProfileDoesNotExist , UnsupportedSettings , ) from .profiles import profiles from .sections import DEFAULT as SECTION_DEFAULTS from .sections import FIRSTPARTY , FUTURE , LOCALFOLDER , STDLIB , THIRDPARTY from .wrap_modes import WrapModes from .wrap_modes import from_string as wrap_mode_from_string _SHEBANG_RE = re . compile ( br \"^#!.*\\bpython[23w]?\\b\" ) SUPPORTED_EXTENSIONS = frozenset ({ \"py\" , \"pyi\" , \"pyx\" , \"pxd\" }) BLOCKED_EXTENSIONS = frozenset ({ \"pex\" }) FILE_SKIP_COMMENTS : Tuple [ str , ... ] = ( \"isort:\" + \"skip_file\" , \"isort: \" + \"skip_file\" , ) # Concatenated to avoid this file being skipped MAX_CONFIG_SEARCH_DEPTH : int = 25 # The number of parent directories to for a config file within STOP_CONFIG_SEARCH_ON_DIRS : Tuple [ str , ... ] = ( \".git\" , \".hg\" ) VALID_PY_TARGETS : Tuple [ str , ... ] = tuple ( target . replace ( \"py\" , \"\" ) for target in dir ( stdlibs ) if not target . startswith ( \"_\" ) ) CONFIG_SOURCES : Tuple [ str , ... ] = ( \".isort.cfg\" , \"pyproject.toml\" , \"setup.cfg\" , \"tox.ini\" , \".editorconfig\" , ) DEFAULT_SKIP : FrozenSet [ str ] = frozenset ( { \".venv\" , \"venv\" , \".tox\" , \".eggs\" , \".git\" , \".hg\" , \".mypy_cache\" , \".nox\" , \".svn\" , \".bzr\" , \"_build\" , \"buck-out\" , \"build\" , \"dist\" , \".pants.d\" , \".direnv\" , \"node_modules\" , } ) CONFIG_SECTIONS : Dict [ str , Tuple [ str , ... ]] = { \".isort.cfg\" : ( \"settings\" , \"isort\" ), \"pyproject.toml\" : ( \"tool.isort\" ,), \"setup.cfg\" : ( \"isort\" , \"tool:isort\" ), \"tox.ini\" : ( \"isort\" , \"tool:isort\" ), \".editorconfig\" : ( \"*\" , \"*.py\" , \"**.py\" , \"*.{py}\" ), } FALLBACK_CONFIG_SECTIONS : Tuple [ str , ... ] = ( \"isort\" , \"tool:isort\" , \"tool.isort\" ) IMPORT_HEADING_PREFIX = \"import_heading_\" KNOWN_PREFIX = \"known_\" KNOWN_SECTION_MAPPING : Dict [ str , str ] = { STDLIB : \"STANDARD_LIBRARY\" , FUTURE : \"FUTURE_LIBRARY\" , FIRSTPARTY : \"FIRST_PARTY\" , THIRDPARTY : \"THIRD_PARTY\" , LOCALFOLDER : \"LOCAL_FOLDER\" , } RUNTIME_SOURCE = \"runtime\" DEPRECATED_SETTINGS = ( \"not_skip\" , \"keep_direct_and_as_imports\" ) _STR_BOOLEAN_MAPPING = { \"y\" : True , \"yes\" : True , \"t\" : True , \"on\" : True , \"1\" : True , \"true\" : True , \"n\" : False , \"no\" : False , \"f\" : False , \"off\" : False , \"0\" : False , \"false\" : False , } @dataclass ( frozen = True ) class _Config : \"\"\"Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. \"\"\" py_version : str = \"3\" force_to_top : FrozenSet [ str ] = frozenset () skip : FrozenSet [ str ] = DEFAULT_SKIP skip_glob : FrozenSet [ str ] = frozenset () skip_gitignore : bool = False line_length : int = 79 wrap_length : int = 0 line_ending : str = \"\" sections : Tuple [ str , ... ] = SECTION_DEFAULTS no_sections : bool = False known_future_library : FrozenSet [ str ] = frozenset (( \"__future__\" ,)) known_third_party : FrozenSet [ str ] = frozenset () known_first_party : FrozenSet [ str ] = frozenset () known_local_folder : FrozenSet [ str ] = frozenset () known_standard_library : FrozenSet [ str ] = frozenset () extra_standard_library : FrozenSet [ str ] = frozenset () known_other : Dict [ str , FrozenSet [ str ]] = field ( default_factory = dict ) multi_line_output : WrapModes = WrapModes . GRID # type: ignore forced_separate : Tuple [ str , ... ] = () indent : str = \" \" * 4 comment_prefix : str = \" #\" length_sort : bool = False length_sort_straight : bool = False length_sort_sections : FrozenSet [ str ] = frozenset () add_imports : FrozenSet [ str ] = frozenset () remove_imports : FrozenSet [ str ] = frozenset () append_only : bool = False reverse_relative : bool = False force_single_line : bool = False single_line_exclusions : Tuple [ str , ... ] = () default_section : str = THIRDPARTY import_headings : Dict [ str , str ] = field ( default_factory = dict ) balanced_wrapping : bool = False use_parentheses : bool = False order_by_type : bool = True atomic : bool = False lines_after_imports : int = - 1 lines_between_sections : int = 1 lines_between_types : int = 0 combine_as_imports : bool = False combine_star : bool = False include_trailing_comma : bool = False from_first : bool = False verbose : bool = False quiet : bool = False force_adds : bool = False force_alphabetical_sort_within_sections : bool = False force_alphabetical_sort : bool = False force_grid_wrap : int = 0 force_sort_within_sections : bool = False lexicographical : bool = False group_by_package : bool = False ignore_whitespace : bool = False no_lines_before : FrozenSet [ str ] = frozenset () no_inline_sort : bool = False ignore_comments : bool = False case_sensitive : bool = False sources : Tuple [ Dict [ str , Any ], ... ] = () virtual_env : str = \"\" conda_env : str = \"\" ensure_newline_before_comments : bool = False directory : str = \"\" profile : str = \"\" honor_noqa : bool = False src_paths : Tuple [ Path , ... ] = () old_finders : bool = False remove_redundant_aliases : bool = False float_to_top : bool = False filter_files : bool = False formatter : str = \"\" formatting_function : Optional [ Callable [[ str , str , object ], str ]] = None color_output : bool = False treat_comments_as_code : FrozenSet [ str ] = frozenset () treat_all_comments_as_code : bool = False supported_extensions : FrozenSet [ str ] = SUPPORTED_EXTENSIONS blocked_extensions : FrozenSet [ str ] = BLOCKED_EXTENSIONS constants : FrozenSet [ str ] = frozenset () classes : FrozenSet [ str ] = frozenset () variables : FrozenSet [ str ] = frozenset () dedup_headings : bool = False only_sections : bool = False only_modified : bool = False combine_straight_imports : bool = False auto_identify_namespace_packages : bool = True namespace_packages : FrozenSet [ str ] = frozenset () follow_links : bool = True indented_import_headings : bool = True honor_case_in_force_sorted_sections : bool = False def __post_init__ ( self ): py_version = self . py_version if py_version == \"auto\" : # pragma: no cover if sys . version_info . major == 2 and sys . version_info . minor <= 6 : py_version = \"2\" elif sys . version_info . major == 3 and ( sys . version_info . minor <= 5 or sys . version_info . minor >= 9 ): py_version = \"3\" else : py_version = f \"{sys.version_info.major}{sys.version_info.minor}\" if py_version not in VALID_PY_TARGETS : raise ValueError ( f \"The python version {py_version} is not supported. \" \"You can set a python version with the -py or --python-version flag. \" f \"The following versions are supported: {VALID_PY_TARGETS}\" ) if py_version != \"all\" : object . __setattr__ ( self , \"py_version\" , f \"py{py_version}\" ) if not self . known_standard_library : object . __setattr__ ( self , \"known_standard_library\" , frozenset ( getattr ( stdlibs , self . py_version ) . stdlib ) ) if self . multi_line_output == WrapModes . VERTICAL_GRID_GROUPED_NO_COMMA : # type: ignore vertical_grid_grouped = WrapModes . VERTICAL_GRID_GROUPED # type: ignore object . __setattr__ ( self , \"multi_line_output\" , vertical_grid_grouped ) if self . force_alphabetical_sort : object . __setattr__ ( self , \"force_alphabetical_sort_within_sections\" , True ) object . __setattr__ ( self , \"no_sections\" , True ) object . __setattr__ ( self , \"lines_between_types\" , 1 ) object . __setattr__ ( self , \"from_first\" , True ) if self . wrap_length > self . line_length : raise ValueError ( \"wrap_length must be set lower than or equal to line_length: \" f \"{self.wrap_length} > {self.line_length}.\" ) def __hash__ ( self ): return id ( self ) _DEFAULT_SETTINGS = { ** vars ( _Config ()), \"source\" : \"defaults\" } class Config ( _Config ): def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ): self . _known_patterns : Optional [ List [ Tuple [ Pattern [ str ], str ]]] = None self . _section_comments : Optional [ Tuple [ str , ... ]] = None if config : config_vars = vars ( config ) . copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) config_vars . pop ( \"_section_comments\" ) super () . __init__ ( ** config_vars ) # type: ignore return # We can't use self.quiet to conditionally show warnings before super.__init__() is called # at the end of this method. _Config is also frozen so setting self.quiet isn't possible. # Therefore we extract quiet early here in a variable and use that in warning conditions. quiet = config_overrides . get ( \"quiet\" , False ) sources : List [ Dict [ str , Any ]] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str , Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) if not config_settings and not quiet : warn ( f \"A custom settings file was specified: {settings_file} but no configuration \" \"was found inside. This can happen when [settings] is used as the config \" \"header instead of [isort]. \" \"See: https://pycqa.github.io/isort/docs/configuration/config_files\" \"/#custom_config_files for more information.\" ) elif settings_path : if not os . path . exists ( settings_path ): raise InvalidSettingsPath ( settings_path ) settings_path = os . path . abspath ( settings_path ) project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str , Any ] = {} if profile_name : if profile_name not in profiles : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.profiles\" ): profiles . setdefault ( plugin . name , plugin . load ()) if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ]) if indent . isdigit (): indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ) . strip ( '\"' ) if indent . lower () == \"tab\" : indent = \" \\t \" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in tuple ( combined_config . items ()): # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , \"known_local_folder\" , ): import_heading = key [ len ( KNOWN_PREFIX ) :] . lower () maps_to_section = import_heading . upper () combined_config . pop ( key ) if maps_to_section in KNOWN_SECTION_MAPPING : section_name = f \"known_{KNOWN_SECTION_MAPPING[maps_to_section].lower()}\" if section_name in combined_config and not quiet : warn ( f \"Can't set both {key} and {section_name} in the same config file. \\n \" f \"Default to {section_name} if unsure.\" \" \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) else : combined_config [ section_name ] = frozenset ( value ) else : known_other [ import_heading ] = frozenset ( value ) if maps_to_section not in combined_config . get ( \"sections\" , ()) and not quiet : warn ( f \"`{key}` setting is defined, but {maps_to_section} is not\" \" included in `sections` config option:\" f \" {combined_config.get('sections', SECTION_DEFAULTS)}. \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) if key . startswith ( IMPORT_HEADING_PREFIX ): import_headings [ key [ len ( IMPORT_HEADING_PREFIX ) :] . lower ()] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) for section in combined_config . get ( \"sections\" , ()): if section in SECTION_DEFAULTS : continue if not section . lower () in known_other : config_keys = \", \" . join ( known_other . keys ()) warn ( f \"`sections` setting includes {section}, but no known_{section.lower()} \" \"is defined. \" f \"The following known_SECTION config options are defined: {config_keys}.\" ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ]) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )) . resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = ( path_root / \"src\" , path_root ) else : src_paths : List [ Path ] = [] for src_path in combined_config . get ( \"src_paths\" , ()): full_path = path_root / src_path if full_path not in src_paths : src_paths . append ( full_path ) combined_config [ \"src_paths\" ] = tuple ( src_paths ) if \"formatter\" in combined_config : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.formatters\" ): if plugin . name == combined_config [ \"formatter\" ]: combined_config [ \"formatting_function\" ] = plugin . load () break else : raise FormattingPluginDoesNotExist ( combined_config [ \"formatter\" ]) # Remove any config values that are used for creating config object but # aren't defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) deprecated_options_used = [ option for option in combined_config if option in DEPRECATED_SETTINGS ] if deprecated_options_used : for deprecated_option in deprecated_options_used : combined_config . pop ( deprecated_option ) if not quiet : warn ( \"W0503: Deprecated config options were used: \" f \"{', '.join(deprecated_options_used)}.\" \"Please see the 5.0.0 upgrade guide: bit.ly/isortv5.\" ) if known_other : combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings unsupported_config_errors = {} for option in set ( combined_config . keys ()) . difference ( getattr ( _Config , \"__dataclass_fields__\" , {}) . keys () ): for source in reversed ( sources ): if option in source : unsupported_config_errors [ option ] = { \"value\" : source [ option ], \"source\" : source [ \"source\" ], } if unsupported_config_errors : raise UnsupportedSettings ( unsupported_config_errors ) super () . __init__ ( sources = tuple ( sources ), ** combined_config ) # type: ignore def is_supported_filetype ( self , file_name : str ): _root , ext = os . path . splitext ( file_name ) ext = ext . lstrip ( \".\" ) if ext in self . supported_extensions : return True if ext in self . blocked_extensions : return False # Skip editor backup files. if file_name . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( file_name ) . st_mode ): return False except OSError : pass try : with open ( file_name , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( _SHEBANG_RE . match ( line )) def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . resolve () . parents : file_name = os . path . relpath ( file_path . resolve (), self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) if self . skip_gitignore : if file_path . name == \".git\" : # pragma: no cover return True result = subprocess . run ( # nosec # skipcq: PYL-W1510 [ \"git\" , \"-C\" , str ( file_path . parent ), \"check-ignore\" , \"--quiet\" , os_path ] ) if result . returncode == 0 : return True normalized_path = os_path . replace ( \" \\\\ \" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \" \\\\ \" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False @property def known_patterns ( self ): if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] pattern_sections = [ STDLIB ] + [ section for section in self . sections if section != STDLIB ] for placement in reversed ( pattern_sections ): known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ) . lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( extra_modules ) . union ( known_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self . _parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ) . replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @property def section_comments ( self ) -> Tuple [ str , ... ]: if self . _section_comments is not None : return self . _section_comments self . _section_comments = tuple ( f \"# {heading}\" for heading in self . import_headings . values ()) return self . _section_comments def _parse_known_pattern ( self , pattern : str ) -> List [ str ]: \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ): patterns = [ filename for filename in os . listdir ( os . path . join ( self . directory , pattern )) if os . path . isdir ( os . path . join ( self . directory , pattern , filename )) ] else : patterns = [ pattern ] return patterns def _get_str_to_type_converter ( setting_name : str ) -> Callable [[ str ], Any ]: type_converter : Callable [[ str ], Any ] = type ( _DEFAULT_SETTINGS . get ( setting_name , \"\" )) if type_converter == WrapModes : type_converter = wrap_mode_from_string return type_converter def _as_list ( value : str ) -> List [ str ]: if isinstance ( value , list ): return [ item . strip () for item in value ] filtered = [ item . strip () for item in value . replace ( \" \\n \" , \",\" ) . split ( \",\" ) if item . strip ()] return filtered def _abspaths ( cwd : str , values : Iterable [ str ]) -> Set [ str ]: paths = { os . path . join ( cwd , value ) if not value . startswith ( os . path . sep ) and value . endswith ( os . path . sep ) else value for value in values } return paths @lru_cache () def _find_config ( path : str ) -> Tuple [ str , Dict [ str , Any ]]: current_directory = path tries = 0 while current_directory and tries < MAX_CONFIG_SEARCH_DEPTH : for config_file_name in CONFIG_SOURCES : potential_config_file = os . path . join ( current_directory , config_file_name ) if os . path . isfile ( potential_config_file ): config_data : Dict [ str , Any ] try : config_data = _get_config_data ( potential_config_file , CONFIG_SECTIONS [ config_file_name ] ) except Exception : warn ( f \"Failed to pull configuration information from {potential_config_file}\" ) config_data = {} if config_data : return ( current_directory , config_data ) for stop_dir in STOP_CONFIG_SEARCH_ON_DIRS : if os . path . isdir ( os . path . join ( current_directory , stop_dir )): return ( current_directory , {}) new_directory = os . path . split ( current_directory )[ 0 ] if new_directory == current_directory : break current_directory = new_directory tries += 1 return ( path , {}) @lru_cache () def _get_config_data ( file_path : str , sections : Tuple [ str ]) -> Dict [ str , Any ]: settings : Dict [ str , Any ] = {} with open ( file_path ) as config_file : if file_path . endswith ( \".toml\" ): config = toml . load ( config_file ) for section in sections : config_section = config for key in section . split ( \".\" ): config_section = config_section . get ( key , {}) settings . update ( config_section ) else : if file_path . endswith ( \".editorconfig\" ): line = \" \\n \" last_position = config_file . tell () while line : line = config_file . readline () if \"[\" in line : config_file . seek ( last_position ) break last_position = config_file . tell () config = configparser . ConfigParser ( strict = False ) config . read_file ( config_file ) for section in sections : if section . startswith ( \"*.{\" ) and section . endswith ( \"}\" ): extension = section [ len ( \"*.{\" ) : - 1 ] for config_key in config . keys (): if ( config_key . startswith ( \"*.{\" ) and config_key . endswith ( \"}\" ) and extension in map ( lambda text : text . strip (), config_key [ len ( \"*.{\" ) : - 1 ] . split ( \",\" ) ) ): settings . update ( config . items ( config_key )) elif config . has_section ( section ): settings . update ( config . items ( section )) if settings : settings [ \"source\" ] = file_path if file_path . endswith ( \".editorconfig\" ): indent_style = settings . pop ( \"indent_style\" , \"\" ) . strip () indent_size = settings . pop ( \"indent_size\" , \"\" ) . strip () if indent_size == \"tab\" : indent_size = settings . pop ( \"tab_width\" , \"\" ) . strip () if indent_style == \"space\" : settings [ \"indent\" ] = \" \" * ( indent_size and int ( indent_size ) or 4 ) elif indent_style == \"tab\" : settings [ \"indent\" ] = \" \\t \" * ( indent_size and int ( indent_size ) or 1 ) max_line_length = settings . pop ( \"max_line_length\" , \"\" ) . strip () if max_line_length and ( max_line_length == \"off\" or max_line_length . isdigit ()): settings [ \"line_length\" ] = ( float ( \"inf\" ) if max_line_length == \"off\" else int ( max_line_length ) ) settings = { key : value for key , value in settings . items () if key in _DEFAULT_SETTINGS . keys () or key . startswith ( KNOWN_PREFIX ) } for key , value in settings . items (): existing_value_type = _get_str_to_type_converter ( key ) if existing_value_type == tuple : settings [ key ] = tuple ( _as_list ( value )) elif existing_value_type == frozenset : settings [ key ] = frozenset ( _as_list ( settings . get ( key ))) # type: ignore elif existing_value_type == bool : # Only some configuration formats support native boolean values. if not isinstance ( value , bool ): value = _as_bool ( value ) settings [ key ] = value elif key . startswith ( KNOWN_PREFIX ): settings [ key ] = _abspaths ( os . path . dirname ( file_path ), _as_list ( value )) elif key == \"force_grid_wrap\" : try : result = existing_value_type ( value ) except ValueError : # backwards compatibility for true / false force grid wrap result = 0 if value . lower () . strip () == \"false\" else 2 settings [ key ] = result elif key == \"comment_prefix\" : settings [ key ] = str ( value ) . strip ( \"'\" ) . strip ( '\"' ) else : settings [ key ] = existing_value_type ( value ) return settings def _as_bool ( value : str ) -> bool : \"\"\"Given a string value that represents True or False, returns the Boolean equivalent. Heavily inspired from distutils strtobool. \"\"\" try : return _STR_BOOLEAN_MAPPING [ value . lower ()] except KeyError : raise ValueError ( f \"invalid truth value {value}\" ) DEFAULT_CONFIG = Config () Variables BLOCKED_EXTENSIONS CONFIG_SECTIONS CONFIG_SOURCES DEFAULT_CONFIG DEFAULT_SKIP DEPRECATED_SETTINGS FALLBACK_CONFIG_SECTIONS FILE_SKIP_COMMENTS FIRSTPARTY FUTURE IMPORT_HEADING_PREFIX KNOWN_PREFIX KNOWN_SECTION_MAPPING LOCALFOLDER MAX_CONFIG_SEARCH_DEPTH RUNTIME_SOURCE SECTION_DEFAULTS STDLIB STOP_CONFIG_SEARCH_ON_DIRS SUPPORTED_EXTENSIONS THIRDPARTY VALID_PY_TARGETS profiles Classes Config class Config ( settings_file : str = '' , settings_path : str = '' , config : Union [ isort . settings . _Config , NoneType ] = None , ** config_overrides ) Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. View Source class Config ( _Config ): def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ): self . _known_patterns : Optional [ List [ Tuple [ Pattern [ str ], str ]]] = None self . _section_comments : Optional [ Tuple [ str , ... ]] = None if config : config_vars = vars ( config ) . copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) config_vars . pop ( \"_section_comments\" ) super () . __init__ ( ** config_vars ) # type: ignore return # We can't use self.quiet to conditionally show warnings before super.__init__() is called # at the end of this method. _Config is also frozen so setting self.quiet isn't possible. # Therefore we extract quiet early here in a variable and use that in warning conditions. quiet = config_overrides . get ( \"quiet\" , False ) sources : List [ Dict [ str , Any ]] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str , Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) if not config_settings and not quiet : warn ( f \"A custom settings file was specified: {settings_file} but no configuration \" \"was found inside. This can happen when [settings] is used as the config \" \"header instead of [isort]. \" \"See: https://pycqa.github.io/isort/docs/configuration/config_files\" \"/#custom_config_files for more information.\" ) elif settings_path : if not os . path . exists ( settings_path ): raise InvalidSettingsPath ( settings_path ) settings_path = os . path . abspath ( settings_path ) project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str , Any ] = {} if profile_name : if profile_name not in profiles : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.profiles\" ): profiles . setdefault ( plugin . name , plugin . load ()) if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ]) if indent . isdigit (): indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ) . strip ( '\"' ) if indent . lower () == \"tab\" : indent = \" \\t \" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in tuple ( combined_config . items ()): # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , \"known_local_folder\" , ): import_heading = key [ len ( KNOWN_PREFIX ) :] . lower () maps_to_section = import_heading . upper () combined_config . pop ( key ) if maps_to_section in KNOWN_SECTION_MAPPING : section_name = f \"known_{KNOWN_SECTION_MAPPING[maps_to_section].lower()}\" if section_name in combined_config and not quiet : warn ( f \"Can't set both {key} and {section_name} in the same config file. \\n \" f \"Default to {section_name} if unsure.\" \" \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) else : combined_config [ section_name ] = frozenset ( value ) else : known_other [ import_heading ] = frozenset ( value ) if maps_to_section not in combined_config . get ( \"sections\" , ()) and not quiet : warn ( f \"`{key}` setting is defined, but {maps_to_section} is not\" \" included in `sections` config option:\" f \" {combined_config.get('sections', SECTION_DEFAULTS)}. \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) if key . startswith ( IMPORT_HEADING_PREFIX ): import_headings [ key [ len ( IMPORT_HEADING_PREFIX ) :] . lower ()] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) for section in combined_config . get ( \"sections\" , ()): if section in SECTION_DEFAULTS : continue if not section . lower () in known_other : config_keys = \", \" . join ( known_other . keys ()) warn ( f \"`sections` setting includes {section}, but no known_{section.lower()} \" \"is defined. \" f \"The following known_SECTION config options are defined: {config_keys}.\" ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ]) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )) . resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = ( path_root / \"src\" , path_root ) else : src_paths : List [ Path ] = [] for src_path in combined_config . get ( \"src_paths\" , ()): full_path = path_root / src_path if full_path not in src_paths : src_paths . append ( full_path ) combined_config [ \"src_paths\" ] = tuple ( src_paths ) if \"formatter\" in combined_config : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.formatters\" ): if plugin . name == combined_config [ \"formatter\" ]: combined_config [ \"formatting_function\" ] = plugin . load () break else : raise FormattingPluginDoesNotExist ( combined_config [ \"formatter\" ]) # Remove any config values that are used for creating config object but # aren't defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) deprecated_options_used = [ option for option in combined_config if option in DEPRECATED_SETTINGS ] if deprecated_options_used : for deprecated_option in deprecated_options_used : combined_config . pop ( deprecated_option ) if not quiet : warn ( \"W0503: Deprecated config options were used: \" f \"{', '.join(deprecated_options_used)}.\" \"Please see the 5.0.0 upgrade guide: bit.ly/isortv5.\" ) if known_other : combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings unsupported_config_errors = {} for option in set ( combined_config . keys ()) . difference ( getattr ( _Config , \"__dataclass_fields__\" , {}) . keys () ): for source in reversed ( sources ): if option in source : unsupported_config_errors [ option ] = { \"value\" : source [ option ], \"source\" : source [ \"source\" ], } if unsupported_config_errors : raise UnsupportedSettings ( unsupported_config_errors ) super () . __init__ ( sources = tuple ( sources ), ** combined_config ) # type: ignore def is_supported_filetype ( self , file_name : str ): _root , ext = os . path . splitext ( file_name ) ext = ext . lstrip ( \".\" ) if ext in self . supported_extensions : return True if ext in self . blocked_extensions : return False # Skip editor backup files. if file_name . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( file_name ) . st_mode ): return False except OSError : pass try : with open ( file_name , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( _SHEBANG_RE . match ( line )) def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . resolve () . parents : file_name = os . path . relpath ( file_path . resolve (), self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) if self . skip_gitignore : if file_path . name == \".git\" : # pragma: no cover return True result = subprocess . run ( # nosec # skipcq: PYL-W1510 [ \"git\" , \"-C\" , str ( file_path . parent ), \"check-ignore\" , \"--quiet\" , os_path ] ) if result . returncode == 0 : return True normalized_path = os_path . replace ( \" \\\\ \" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \" \\\\ \" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False @ property def known_patterns ( self ): if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] pattern_sections = [ STDLIB ] + [ section for section in self . sections if section != STDLIB ] for placement in reversed ( pattern_sections ): known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ) . lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( extra_modules ) . union ( known_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self . _parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ) . replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @ property def section_comments ( self ) -> Tuple [ str , ... ]: if self . _section_comments is not None : return self . _section_comments self . _section_comments = tuple ( f \"# {heading}\" for heading in self . import_headings . values ()) return self . _section_comments def _parse_known_pattern ( self , pattern : str ) -> List [ str ]: \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ): patterns = [ filename for filename in os . listdir ( os . path . join ( self . directory , pattern )) if os . path . isdir ( os . path . join ( self . directory , pattern , filename )) ] else : patterns = [ pattern ] return patterns Ancestors (in MRO) isort.settings._Config Class variables add_imports append_only atomic auto_identify_namespace_packages balanced_wrapping blocked_extensions case_sensitive classes color_output combine_as_imports combine_star combine_straight_imports comment_prefix conda_env constants dedup_headings default_section directory ensure_newline_before_comments extra_standard_library filter_files float_to_top follow_links force_adds force_alphabetical_sort force_alphabetical_sort_within_sections force_grid_wrap force_single_line force_sort_within_sections force_to_top forced_separate formatter formatting_function from_first group_by_package honor_case_in_force_sorted_sections honor_noqa ignore_comments ignore_whitespace include_trailing_comma indent indented_import_headings known_first_party known_future_library known_local_folder known_standard_library known_third_party length_sort length_sort_sections length_sort_straight lexicographical line_ending line_length lines_after_imports lines_between_sections lines_between_types multi_line_output namespace_packages no_inline_sort no_lines_before no_sections old_finders only_modified only_sections order_by_type profile py_version quiet remove_imports remove_redundant_aliases reverse_relative sections single_line_exclusions skip skip_gitignore skip_glob sources src_paths supported_extensions treat_all_comments_as_code treat_comments_as_code use_parentheses variables verbose virtual_env wrap_length Instance variables known_patterns section_comments Methods is_skipped def is_skipped ( self , file_path : pathlib . Path ) -> bool Returns True if the file and/or folder should be skipped based on current settings. View Source def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . resolve (). parents : file_name = os . path . relpath ( file_path . resolve (), self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) if self . skip_gitignore : if file_path . name == \".git\" : # pragma : no cover return True result = subprocess . run ( # nosec # skipcq : PYL - W1510 [ \"git\" , \"-C\" , str ( file_path . parent ), \"check-ignore\" , \"--quiet\" , os_path ] ) if result . returncode == 0 : return True normalized_path = os_path . replace ( \"\\\\\" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \"\\\\\" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False is_supported_filetype def is_supported_filetype ( self , file_name : str ) View Source def is_supported_filetype ( self , file_name : str ): _root , ext = os . path . splitext ( file_name ) ext = ext . lstrip ( \".\" ) if ext in self . supported_extensions : return True if ext in self . blocked_extensions : return False # Skip editor backup files . if file_name . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( file_name ). st_mode ): return False except OSError : pass try : with open ( file_name , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( _SHEBANG_RE . match ( line ))","title":"Settings"},{"location":"reference/isort/settings/#module-isortsettings","text":"isort/settings.py. Defines how the default settings for isort should be loaded View Source \"\"\"isort/settings.py. Defines how the default settings for isort should be loaded \"\"\" import configparser import fnmatch import os import posixpath import re import stat import subprocess # nosec: Needed for gitignore support. import sys from functools import lru_cache from pathlib import Path from typing import Any , Callable , Dict , FrozenSet , Iterable , List , Optional , Pattern , Set , Tuple from warnings import warn from . import stdlibs from ._future import dataclass , field from ._vendored import toml from .exceptions import ( FormattingPluginDoesNotExist , InvalidSettingsPath , ProfileDoesNotExist , UnsupportedSettings , ) from .profiles import profiles from .sections import DEFAULT as SECTION_DEFAULTS from .sections import FIRSTPARTY , FUTURE , LOCALFOLDER , STDLIB , THIRDPARTY from .wrap_modes import WrapModes from .wrap_modes import from_string as wrap_mode_from_string _SHEBANG_RE = re . compile ( br \"^#!.*\\bpython[23w]?\\b\" ) SUPPORTED_EXTENSIONS = frozenset ({ \"py\" , \"pyi\" , \"pyx\" , \"pxd\" }) BLOCKED_EXTENSIONS = frozenset ({ \"pex\" }) FILE_SKIP_COMMENTS : Tuple [ str , ... ] = ( \"isort:\" + \"skip_file\" , \"isort: \" + \"skip_file\" , ) # Concatenated to avoid this file being skipped MAX_CONFIG_SEARCH_DEPTH : int = 25 # The number of parent directories to for a config file within STOP_CONFIG_SEARCH_ON_DIRS : Tuple [ str , ... ] = ( \".git\" , \".hg\" ) VALID_PY_TARGETS : Tuple [ str , ... ] = tuple ( target . replace ( \"py\" , \"\" ) for target in dir ( stdlibs ) if not target . startswith ( \"_\" ) ) CONFIG_SOURCES : Tuple [ str , ... ] = ( \".isort.cfg\" , \"pyproject.toml\" , \"setup.cfg\" , \"tox.ini\" , \".editorconfig\" , ) DEFAULT_SKIP : FrozenSet [ str ] = frozenset ( { \".venv\" , \"venv\" , \".tox\" , \".eggs\" , \".git\" , \".hg\" , \".mypy_cache\" , \".nox\" , \".svn\" , \".bzr\" , \"_build\" , \"buck-out\" , \"build\" , \"dist\" , \".pants.d\" , \".direnv\" , \"node_modules\" , } ) CONFIG_SECTIONS : Dict [ str , Tuple [ str , ... ]] = { \".isort.cfg\" : ( \"settings\" , \"isort\" ), \"pyproject.toml\" : ( \"tool.isort\" ,), \"setup.cfg\" : ( \"isort\" , \"tool:isort\" ), \"tox.ini\" : ( \"isort\" , \"tool:isort\" ), \".editorconfig\" : ( \"*\" , \"*.py\" , \"**.py\" , \"*.{py}\" ), } FALLBACK_CONFIG_SECTIONS : Tuple [ str , ... ] = ( \"isort\" , \"tool:isort\" , \"tool.isort\" ) IMPORT_HEADING_PREFIX = \"import_heading_\" KNOWN_PREFIX = \"known_\" KNOWN_SECTION_MAPPING : Dict [ str , str ] = { STDLIB : \"STANDARD_LIBRARY\" , FUTURE : \"FUTURE_LIBRARY\" , FIRSTPARTY : \"FIRST_PARTY\" , THIRDPARTY : \"THIRD_PARTY\" , LOCALFOLDER : \"LOCAL_FOLDER\" , } RUNTIME_SOURCE = \"runtime\" DEPRECATED_SETTINGS = ( \"not_skip\" , \"keep_direct_and_as_imports\" ) _STR_BOOLEAN_MAPPING = { \"y\" : True , \"yes\" : True , \"t\" : True , \"on\" : True , \"1\" : True , \"true\" : True , \"n\" : False , \"no\" : False , \"f\" : False , \"off\" : False , \"0\" : False , \"false\" : False , } @dataclass ( frozen = True ) class _Config : \"\"\"Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. \"\"\" py_version : str = \"3\" force_to_top : FrozenSet [ str ] = frozenset () skip : FrozenSet [ str ] = DEFAULT_SKIP skip_glob : FrozenSet [ str ] = frozenset () skip_gitignore : bool = False line_length : int = 79 wrap_length : int = 0 line_ending : str = \"\" sections : Tuple [ str , ... ] = SECTION_DEFAULTS no_sections : bool = False known_future_library : FrozenSet [ str ] = frozenset (( \"__future__\" ,)) known_third_party : FrozenSet [ str ] = frozenset () known_first_party : FrozenSet [ str ] = frozenset () known_local_folder : FrozenSet [ str ] = frozenset () known_standard_library : FrozenSet [ str ] = frozenset () extra_standard_library : FrozenSet [ str ] = frozenset () known_other : Dict [ str , FrozenSet [ str ]] = field ( default_factory = dict ) multi_line_output : WrapModes = WrapModes . GRID # type: ignore forced_separate : Tuple [ str , ... ] = () indent : str = \" \" * 4 comment_prefix : str = \" #\" length_sort : bool = False length_sort_straight : bool = False length_sort_sections : FrozenSet [ str ] = frozenset () add_imports : FrozenSet [ str ] = frozenset () remove_imports : FrozenSet [ str ] = frozenset () append_only : bool = False reverse_relative : bool = False force_single_line : bool = False single_line_exclusions : Tuple [ str , ... ] = () default_section : str = THIRDPARTY import_headings : Dict [ str , str ] = field ( default_factory = dict ) balanced_wrapping : bool = False use_parentheses : bool = False order_by_type : bool = True atomic : bool = False lines_after_imports : int = - 1 lines_between_sections : int = 1 lines_between_types : int = 0 combine_as_imports : bool = False combine_star : bool = False include_trailing_comma : bool = False from_first : bool = False verbose : bool = False quiet : bool = False force_adds : bool = False force_alphabetical_sort_within_sections : bool = False force_alphabetical_sort : bool = False force_grid_wrap : int = 0 force_sort_within_sections : bool = False lexicographical : bool = False group_by_package : bool = False ignore_whitespace : bool = False no_lines_before : FrozenSet [ str ] = frozenset () no_inline_sort : bool = False ignore_comments : bool = False case_sensitive : bool = False sources : Tuple [ Dict [ str , Any ], ... ] = () virtual_env : str = \"\" conda_env : str = \"\" ensure_newline_before_comments : bool = False directory : str = \"\" profile : str = \"\" honor_noqa : bool = False src_paths : Tuple [ Path , ... ] = () old_finders : bool = False remove_redundant_aliases : bool = False float_to_top : bool = False filter_files : bool = False formatter : str = \"\" formatting_function : Optional [ Callable [[ str , str , object ], str ]] = None color_output : bool = False treat_comments_as_code : FrozenSet [ str ] = frozenset () treat_all_comments_as_code : bool = False supported_extensions : FrozenSet [ str ] = SUPPORTED_EXTENSIONS blocked_extensions : FrozenSet [ str ] = BLOCKED_EXTENSIONS constants : FrozenSet [ str ] = frozenset () classes : FrozenSet [ str ] = frozenset () variables : FrozenSet [ str ] = frozenset () dedup_headings : bool = False only_sections : bool = False only_modified : bool = False combine_straight_imports : bool = False auto_identify_namespace_packages : bool = True namespace_packages : FrozenSet [ str ] = frozenset () follow_links : bool = True indented_import_headings : bool = True honor_case_in_force_sorted_sections : bool = False def __post_init__ ( self ): py_version = self . py_version if py_version == \"auto\" : # pragma: no cover if sys . version_info . major == 2 and sys . version_info . minor <= 6 : py_version = \"2\" elif sys . version_info . major == 3 and ( sys . version_info . minor <= 5 or sys . version_info . minor >= 9 ): py_version = \"3\" else : py_version = f \"{sys.version_info.major}{sys.version_info.minor}\" if py_version not in VALID_PY_TARGETS : raise ValueError ( f \"The python version {py_version} is not supported. \" \"You can set a python version with the -py or --python-version flag. \" f \"The following versions are supported: {VALID_PY_TARGETS}\" ) if py_version != \"all\" : object . __setattr__ ( self , \"py_version\" , f \"py{py_version}\" ) if not self . known_standard_library : object . __setattr__ ( self , \"known_standard_library\" , frozenset ( getattr ( stdlibs , self . py_version ) . stdlib ) ) if self . multi_line_output == WrapModes . VERTICAL_GRID_GROUPED_NO_COMMA : # type: ignore vertical_grid_grouped = WrapModes . VERTICAL_GRID_GROUPED # type: ignore object . __setattr__ ( self , \"multi_line_output\" , vertical_grid_grouped ) if self . force_alphabetical_sort : object . __setattr__ ( self , \"force_alphabetical_sort_within_sections\" , True ) object . __setattr__ ( self , \"no_sections\" , True ) object . __setattr__ ( self , \"lines_between_types\" , 1 ) object . __setattr__ ( self , \"from_first\" , True ) if self . wrap_length > self . line_length : raise ValueError ( \"wrap_length must be set lower than or equal to line_length: \" f \"{self.wrap_length} > {self.line_length}.\" ) def __hash__ ( self ): return id ( self ) _DEFAULT_SETTINGS = { ** vars ( _Config ()), \"source\" : \"defaults\" } class Config ( _Config ): def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ): self . _known_patterns : Optional [ List [ Tuple [ Pattern [ str ], str ]]] = None self . _section_comments : Optional [ Tuple [ str , ... ]] = None if config : config_vars = vars ( config ) . copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) config_vars . pop ( \"_section_comments\" ) super () . __init__ ( ** config_vars ) # type: ignore return # We can't use self.quiet to conditionally show warnings before super.__init__() is called # at the end of this method. _Config is also frozen so setting self.quiet isn't possible. # Therefore we extract quiet early here in a variable and use that in warning conditions. quiet = config_overrides . get ( \"quiet\" , False ) sources : List [ Dict [ str , Any ]] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str , Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) if not config_settings and not quiet : warn ( f \"A custom settings file was specified: {settings_file} but no configuration \" \"was found inside. This can happen when [settings] is used as the config \" \"header instead of [isort]. \" \"See: https://pycqa.github.io/isort/docs/configuration/config_files\" \"/#custom_config_files for more information.\" ) elif settings_path : if not os . path . exists ( settings_path ): raise InvalidSettingsPath ( settings_path ) settings_path = os . path . abspath ( settings_path ) project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str , Any ] = {} if profile_name : if profile_name not in profiles : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.profiles\" ): profiles . setdefault ( plugin . name , plugin . load ()) if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ]) if indent . isdigit (): indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ) . strip ( '\"' ) if indent . lower () == \"tab\" : indent = \" \\t \" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in tuple ( combined_config . items ()): # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , \"known_local_folder\" , ): import_heading = key [ len ( KNOWN_PREFIX ) :] . lower () maps_to_section = import_heading . upper () combined_config . pop ( key ) if maps_to_section in KNOWN_SECTION_MAPPING : section_name = f \"known_{KNOWN_SECTION_MAPPING[maps_to_section].lower()}\" if section_name in combined_config and not quiet : warn ( f \"Can't set both {key} and {section_name} in the same config file. \\n \" f \"Default to {section_name} if unsure.\" \" \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) else : combined_config [ section_name ] = frozenset ( value ) else : known_other [ import_heading ] = frozenset ( value ) if maps_to_section not in combined_config . get ( \"sections\" , ()) and not quiet : warn ( f \"`{key}` setting is defined, but {maps_to_section} is not\" \" included in `sections` config option:\" f \" {combined_config.get('sections', SECTION_DEFAULTS)}. \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) if key . startswith ( IMPORT_HEADING_PREFIX ): import_headings [ key [ len ( IMPORT_HEADING_PREFIX ) :] . lower ()] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) for section in combined_config . get ( \"sections\" , ()): if section in SECTION_DEFAULTS : continue if not section . lower () in known_other : config_keys = \", \" . join ( known_other . keys ()) warn ( f \"`sections` setting includes {section}, but no known_{section.lower()} \" \"is defined. \" f \"The following known_SECTION config options are defined: {config_keys}.\" ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ]) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )) . resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = ( path_root / \"src\" , path_root ) else : src_paths : List [ Path ] = [] for src_path in combined_config . get ( \"src_paths\" , ()): full_path = path_root / src_path if full_path not in src_paths : src_paths . append ( full_path ) combined_config [ \"src_paths\" ] = tuple ( src_paths ) if \"formatter\" in combined_config : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.formatters\" ): if plugin . name == combined_config [ \"formatter\" ]: combined_config [ \"formatting_function\" ] = plugin . load () break else : raise FormattingPluginDoesNotExist ( combined_config [ \"formatter\" ]) # Remove any config values that are used for creating config object but # aren't defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) deprecated_options_used = [ option for option in combined_config if option in DEPRECATED_SETTINGS ] if deprecated_options_used : for deprecated_option in deprecated_options_used : combined_config . pop ( deprecated_option ) if not quiet : warn ( \"W0503: Deprecated config options were used: \" f \"{', '.join(deprecated_options_used)}.\" \"Please see the 5.0.0 upgrade guide: bit.ly/isortv5.\" ) if known_other : combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings unsupported_config_errors = {} for option in set ( combined_config . keys ()) . difference ( getattr ( _Config , \"__dataclass_fields__\" , {}) . keys () ): for source in reversed ( sources ): if option in source : unsupported_config_errors [ option ] = { \"value\" : source [ option ], \"source\" : source [ \"source\" ], } if unsupported_config_errors : raise UnsupportedSettings ( unsupported_config_errors ) super () . __init__ ( sources = tuple ( sources ), ** combined_config ) # type: ignore def is_supported_filetype ( self , file_name : str ): _root , ext = os . path . splitext ( file_name ) ext = ext . lstrip ( \".\" ) if ext in self . supported_extensions : return True if ext in self . blocked_extensions : return False # Skip editor backup files. if file_name . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( file_name ) . st_mode ): return False except OSError : pass try : with open ( file_name , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( _SHEBANG_RE . match ( line )) def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . resolve () . parents : file_name = os . path . relpath ( file_path . resolve (), self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) if self . skip_gitignore : if file_path . name == \".git\" : # pragma: no cover return True result = subprocess . run ( # nosec # skipcq: PYL-W1510 [ \"git\" , \"-C\" , str ( file_path . parent ), \"check-ignore\" , \"--quiet\" , os_path ] ) if result . returncode == 0 : return True normalized_path = os_path . replace ( \" \\\\ \" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \" \\\\ \" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False @property def known_patterns ( self ): if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] pattern_sections = [ STDLIB ] + [ section for section in self . sections if section != STDLIB ] for placement in reversed ( pattern_sections ): known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ) . lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( extra_modules ) . union ( known_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self . _parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ) . replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @property def section_comments ( self ) -> Tuple [ str , ... ]: if self . _section_comments is not None : return self . _section_comments self . _section_comments = tuple ( f \"# {heading}\" for heading in self . import_headings . values ()) return self . _section_comments def _parse_known_pattern ( self , pattern : str ) -> List [ str ]: \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ): patterns = [ filename for filename in os . listdir ( os . path . join ( self . directory , pattern )) if os . path . isdir ( os . path . join ( self . directory , pattern , filename )) ] else : patterns = [ pattern ] return patterns def _get_str_to_type_converter ( setting_name : str ) -> Callable [[ str ], Any ]: type_converter : Callable [[ str ], Any ] = type ( _DEFAULT_SETTINGS . get ( setting_name , \"\" )) if type_converter == WrapModes : type_converter = wrap_mode_from_string return type_converter def _as_list ( value : str ) -> List [ str ]: if isinstance ( value , list ): return [ item . strip () for item in value ] filtered = [ item . strip () for item in value . replace ( \" \\n \" , \",\" ) . split ( \",\" ) if item . strip ()] return filtered def _abspaths ( cwd : str , values : Iterable [ str ]) -> Set [ str ]: paths = { os . path . join ( cwd , value ) if not value . startswith ( os . path . sep ) and value . endswith ( os . path . sep ) else value for value in values } return paths @lru_cache () def _find_config ( path : str ) -> Tuple [ str , Dict [ str , Any ]]: current_directory = path tries = 0 while current_directory and tries < MAX_CONFIG_SEARCH_DEPTH : for config_file_name in CONFIG_SOURCES : potential_config_file = os . path . join ( current_directory , config_file_name ) if os . path . isfile ( potential_config_file ): config_data : Dict [ str , Any ] try : config_data = _get_config_data ( potential_config_file , CONFIG_SECTIONS [ config_file_name ] ) except Exception : warn ( f \"Failed to pull configuration information from {potential_config_file}\" ) config_data = {} if config_data : return ( current_directory , config_data ) for stop_dir in STOP_CONFIG_SEARCH_ON_DIRS : if os . path . isdir ( os . path . join ( current_directory , stop_dir )): return ( current_directory , {}) new_directory = os . path . split ( current_directory )[ 0 ] if new_directory == current_directory : break current_directory = new_directory tries += 1 return ( path , {}) @lru_cache () def _get_config_data ( file_path : str , sections : Tuple [ str ]) -> Dict [ str , Any ]: settings : Dict [ str , Any ] = {} with open ( file_path ) as config_file : if file_path . endswith ( \".toml\" ): config = toml . load ( config_file ) for section in sections : config_section = config for key in section . split ( \".\" ): config_section = config_section . get ( key , {}) settings . update ( config_section ) else : if file_path . endswith ( \".editorconfig\" ): line = \" \\n \" last_position = config_file . tell () while line : line = config_file . readline () if \"[\" in line : config_file . seek ( last_position ) break last_position = config_file . tell () config = configparser . ConfigParser ( strict = False ) config . read_file ( config_file ) for section in sections : if section . startswith ( \"*.{\" ) and section . endswith ( \"}\" ): extension = section [ len ( \"*.{\" ) : - 1 ] for config_key in config . keys (): if ( config_key . startswith ( \"*.{\" ) and config_key . endswith ( \"}\" ) and extension in map ( lambda text : text . strip (), config_key [ len ( \"*.{\" ) : - 1 ] . split ( \",\" ) ) ): settings . update ( config . items ( config_key )) elif config . has_section ( section ): settings . update ( config . items ( section )) if settings : settings [ \"source\" ] = file_path if file_path . endswith ( \".editorconfig\" ): indent_style = settings . pop ( \"indent_style\" , \"\" ) . strip () indent_size = settings . pop ( \"indent_size\" , \"\" ) . strip () if indent_size == \"tab\" : indent_size = settings . pop ( \"tab_width\" , \"\" ) . strip () if indent_style == \"space\" : settings [ \"indent\" ] = \" \" * ( indent_size and int ( indent_size ) or 4 ) elif indent_style == \"tab\" : settings [ \"indent\" ] = \" \\t \" * ( indent_size and int ( indent_size ) or 1 ) max_line_length = settings . pop ( \"max_line_length\" , \"\" ) . strip () if max_line_length and ( max_line_length == \"off\" or max_line_length . isdigit ()): settings [ \"line_length\" ] = ( float ( \"inf\" ) if max_line_length == \"off\" else int ( max_line_length ) ) settings = { key : value for key , value in settings . items () if key in _DEFAULT_SETTINGS . keys () or key . startswith ( KNOWN_PREFIX ) } for key , value in settings . items (): existing_value_type = _get_str_to_type_converter ( key ) if existing_value_type == tuple : settings [ key ] = tuple ( _as_list ( value )) elif existing_value_type == frozenset : settings [ key ] = frozenset ( _as_list ( settings . get ( key ))) # type: ignore elif existing_value_type == bool : # Only some configuration formats support native boolean values. if not isinstance ( value , bool ): value = _as_bool ( value ) settings [ key ] = value elif key . startswith ( KNOWN_PREFIX ): settings [ key ] = _abspaths ( os . path . dirname ( file_path ), _as_list ( value )) elif key == \"force_grid_wrap\" : try : result = existing_value_type ( value ) except ValueError : # backwards compatibility for true / false force grid wrap result = 0 if value . lower () . strip () == \"false\" else 2 settings [ key ] = result elif key == \"comment_prefix\" : settings [ key ] = str ( value ) . strip ( \"'\" ) . strip ( '\"' ) else : settings [ key ] = existing_value_type ( value ) return settings def _as_bool ( value : str ) -> bool : \"\"\"Given a string value that represents True or False, returns the Boolean equivalent. Heavily inspired from distutils strtobool. \"\"\" try : return _STR_BOOLEAN_MAPPING [ value . lower ()] except KeyError : raise ValueError ( f \"invalid truth value {value}\" ) DEFAULT_CONFIG = Config ()","title":"Module isort.settings"},{"location":"reference/isort/settings/#variables","text":"BLOCKED_EXTENSIONS CONFIG_SECTIONS CONFIG_SOURCES DEFAULT_CONFIG DEFAULT_SKIP DEPRECATED_SETTINGS FALLBACK_CONFIG_SECTIONS FILE_SKIP_COMMENTS FIRSTPARTY FUTURE IMPORT_HEADING_PREFIX KNOWN_PREFIX KNOWN_SECTION_MAPPING LOCALFOLDER MAX_CONFIG_SEARCH_DEPTH RUNTIME_SOURCE SECTION_DEFAULTS STDLIB STOP_CONFIG_SEARCH_ON_DIRS SUPPORTED_EXTENSIONS THIRDPARTY VALID_PY_TARGETS profiles","title":"Variables"},{"location":"reference/isort/settings/#classes","text":"","title":"Classes"},{"location":"reference/isort/settings/#config","text":"class Config ( settings_file : str = '' , settings_path : str = '' , config : Union [ isort . settings . _Config , NoneType ] = None , ** config_overrides ) Defines the data schema and defaults used for isort configuration. NOTE: known lists, such as known_standard_library, are intentionally not complete as they are dynamically determined later on. View Source class Config ( _Config ): def __init__ ( self , settings_file : str = \"\" , settings_path : str = \"\" , config : Optional [ _Config ] = None , ** config_overrides , ): self . _known_patterns : Optional [ List [ Tuple [ Pattern [ str ], str ]]] = None self . _section_comments : Optional [ Tuple [ str , ... ]] = None if config : config_vars = vars ( config ) . copy () config_vars . update ( config_overrides ) config_vars [ \"py_version\" ] = config_vars [ \"py_version\" ] . replace ( \"py\" , \"\" ) config_vars . pop ( \"_known_patterns\" ) config_vars . pop ( \"_section_comments\" ) super () . __init__ ( ** config_vars ) # type: ignore return # We can't use self.quiet to conditionally show warnings before super.__init__() is called # at the end of this method. _Config is also frozen so setting self.quiet isn't possible. # Therefore we extract quiet early here in a variable and use that in warning conditions. quiet = config_overrides . get ( \"quiet\" , False ) sources : List [ Dict [ str , Any ]] = [ _DEFAULT_SETTINGS ] config_settings : Dict [ str , Any ] project_root : str if settings_file : config_settings = _get_config_data ( settings_file , CONFIG_SECTIONS . get ( os . path . basename ( settings_file ), FALLBACK_CONFIG_SECTIONS ), ) project_root = os . path . dirname ( settings_file ) if not config_settings and not quiet : warn ( f \"A custom settings file was specified: {settings_file} but no configuration \" \"was found inside. This can happen when [settings] is used as the config \" \"header instead of [isort]. \" \"See: https://pycqa.github.io/isort/docs/configuration/config_files\" \"/#custom_config_files for more information.\" ) elif settings_path : if not os . path . exists ( settings_path ): raise InvalidSettingsPath ( settings_path ) settings_path = os . path . abspath ( settings_path ) project_root , config_settings = _find_config ( settings_path ) else : config_settings = {} project_root = os . getcwd () profile_name = config_overrides . get ( \"profile\" , config_settings . get ( \"profile\" , \"\" )) profile : Dict [ str , Any ] = {} if profile_name : if profile_name not in profiles : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.profiles\" ): profiles . setdefault ( plugin . name , plugin . load ()) if profile_name not in profiles : raise ProfileDoesNotExist ( profile_name ) profile = profiles [ profile_name ] . copy () profile [ \"source\" ] = f \"{profile_name} profile\" sources . append ( profile ) if config_settings : sources . append ( config_settings ) if config_overrides : config_overrides [ \"source\" ] = RUNTIME_SOURCE sources . append ( config_overrides ) combined_config = { ** profile , ** config_settings , ** config_overrides } if \"indent\" in combined_config : indent = str ( combined_config [ \"indent\" ]) if indent . isdigit (): indent = \" \" * int ( indent ) else : indent = indent . strip ( \"'\" ) . strip ( '\"' ) if indent . lower () == \"tab\" : indent = \" \\t \" combined_config [ \"indent\" ] = indent known_other = {} import_headings = {} for key , value in tuple ( combined_config . items ()): # Collect all known sections beyond those that have direct entries if key . startswith ( KNOWN_PREFIX ) and key not in ( \"known_standard_library\" , \"known_future_library\" , \"known_third_party\" , \"known_first_party\" , \"known_local_folder\" , ): import_heading = key [ len ( KNOWN_PREFIX ) :] . lower () maps_to_section = import_heading . upper () combined_config . pop ( key ) if maps_to_section in KNOWN_SECTION_MAPPING : section_name = f \"known_{KNOWN_SECTION_MAPPING[maps_to_section].lower()}\" if section_name in combined_config and not quiet : warn ( f \"Can't set both {key} and {section_name} in the same config file. \\n \" f \"Default to {section_name} if unsure.\" \" \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) else : combined_config [ section_name ] = frozenset ( value ) else : known_other [ import_heading ] = frozenset ( value ) if maps_to_section not in combined_config . get ( \"sections\" , ()) and not quiet : warn ( f \"`{key}` setting is defined, but {maps_to_section} is not\" \" included in `sections` config option:\" f \" {combined_config.get('sections', SECTION_DEFAULTS)}. \\n\\n \" \"See: https://pycqa.github.io/isort/\" \"#custom-sections-and-ordering.\" ) if key . startswith ( IMPORT_HEADING_PREFIX ): import_headings [ key [ len ( IMPORT_HEADING_PREFIX ) :] . lower ()] = str ( value ) # Coerce all provided config values into their correct type default_value = _DEFAULT_SETTINGS . get ( key , None ) if default_value is None : continue combined_config [ key ] = type ( default_value )( value ) for section in combined_config . get ( \"sections\" , ()): if section in SECTION_DEFAULTS : continue if not section . lower () in known_other : config_keys = \", \" . join ( known_other . keys ()) warn ( f \"`sections` setting includes {section}, but no known_{section.lower()} \" \"is defined. \" f \"The following known_SECTION config options are defined: {config_keys}.\" ) if \"directory\" not in combined_config : combined_config [ \"directory\" ] = ( os . path . dirname ( config_settings [ \"source\" ]) if config_settings . get ( \"source\" , None ) else os . getcwd () ) path_root = Path ( combined_config . get ( \"directory\" , project_root )) . resolve () path_root = path_root if path_root . is_dir () else path_root . parent if \"src_paths\" not in combined_config : combined_config [ \"src_paths\" ] = ( path_root / \"src\" , path_root ) else : src_paths : List [ Path ] = [] for src_path in combined_config . get ( \"src_paths\" , ()): full_path = path_root / src_path if full_path not in src_paths : src_paths . append ( full_path ) combined_config [ \"src_paths\" ] = tuple ( src_paths ) if \"formatter\" in combined_config : import pkg_resources for plugin in pkg_resources . iter_entry_points ( \"isort.formatters\" ): if plugin . name == combined_config [ \"formatter\" ]: combined_config [ \"formatting_function\" ] = plugin . load () break else : raise FormattingPluginDoesNotExist ( combined_config [ \"formatter\" ]) # Remove any config values that are used for creating config object but # aren't defined in dataclass combined_config . pop ( \"source\" , None ) combined_config . pop ( \"sources\" , None ) combined_config . pop ( \"runtime_src_paths\" , None ) deprecated_options_used = [ option for option in combined_config if option in DEPRECATED_SETTINGS ] if deprecated_options_used : for deprecated_option in deprecated_options_used : combined_config . pop ( deprecated_option ) if not quiet : warn ( \"W0503: Deprecated config options were used: \" f \"{', '.join(deprecated_options_used)}.\" \"Please see the 5.0.0 upgrade guide: bit.ly/isortv5.\" ) if known_other : combined_config [ \"known_other\" ] = known_other if import_headings : for import_heading_key in import_headings : combined_config . pop ( f \"{IMPORT_HEADING_PREFIX}{import_heading_key}\" ) combined_config [ \"import_headings\" ] = import_headings unsupported_config_errors = {} for option in set ( combined_config . keys ()) . difference ( getattr ( _Config , \"__dataclass_fields__\" , {}) . keys () ): for source in reversed ( sources ): if option in source : unsupported_config_errors [ option ] = { \"value\" : source [ option ], \"source\" : source [ \"source\" ], } if unsupported_config_errors : raise UnsupportedSettings ( unsupported_config_errors ) super () . __init__ ( sources = tuple ( sources ), ** combined_config ) # type: ignore def is_supported_filetype ( self , file_name : str ): _root , ext = os . path . splitext ( file_name ) ext = ext . lstrip ( \".\" ) if ext in self . supported_extensions : return True if ext in self . blocked_extensions : return False # Skip editor backup files. if file_name . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( file_name ) . st_mode ): return False except OSError : pass try : with open ( file_name , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( _SHEBANG_RE . match ( line )) def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . resolve () . parents : file_name = os . path . relpath ( file_path . resolve (), self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) if self . skip_gitignore : if file_path . name == \".git\" : # pragma: no cover return True result = subprocess . run ( # nosec # skipcq: PYL-W1510 [ \"git\" , \"-C\" , str ( file_path . parent ), \"check-ignore\" , \"--quiet\" , os_path ] ) if result . returncode == 0 : return True normalized_path = os_path . replace ( \" \\\\ \" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \" \\\\ \" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False @ property def known_patterns ( self ): if self . _known_patterns is not None : return self . _known_patterns self . _known_patterns = [] pattern_sections = [ STDLIB ] + [ section for section in self . sections if section != STDLIB ] for placement in reversed ( pattern_sections ): known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ) . lower () config_key = f \"{KNOWN_PREFIX}{known_placement}\" known_modules = getattr ( self , config_key , self . known_other . get ( known_placement , ())) extra_modules = getattr ( self , f \"extra_{known_placement}\" , ()) all_modules = set ( extra_modules ) . union ( known_modules ) known_patterns = [ pattern for known_pattern in all_modules for pattern in self . _parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ) . replace ( \"?\" , \".?\" ) + \"$\" self . _known_patterns . append (( re . compile ( regexp ), placement )) return self . _known_patterns @ property def section_comments ( self ) -> Tuple [ str , ... ]: if self . _section_comments is not None : return self . _section_comments self . _section_comments = tuple ( f \"# {heading}\" for heading in self . import_headings . values ()) return self . _section_comments def _parse_known_pattern ( self , pattern : str ) -> List [ str ]: \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ): patterns = [ filename for filename in os . listdir ( os . path . join ( self . directory , pattern )) if os . path . isdir ( os . path . join ( self . directory , pattern , filename )) ] else : patterns = [ pattern ] return patterns","title":"Config"},{"location":"reference/isort/settings/#ancestors-in-mro","text":"isort.settings._Config","title":"Ancestors (in MRO)"},{"location":"reference/isort/settings/#class-variables","text":"add_imports append_only atomic auto_identify_namespace_packages balanced_wrapping blocked_extensions case_sensitive classes color_output combine_as_imports combine_star combine_straight_imports comment_prefix conda_env constants dedup_headings default_section directory ensure_newline_before_comments extra_standard_library filter_files float_to_top follow_links force_adds force_alphabetical_sort force_alphabetical_sort_within_sections force_grid_wrap force_single_line force_sort_within_sections force_to_top forced_separate formatter formatting_function from_first group_by_package honor_case_in_force_sorted_sections honor_noqa ignore_comments ignore_whitespace include_trailing_comma indent indented_import_headings known_first_party known_future_library known_local_folder known_standard_library known_third_party length_sort length_sort_sections length_sort_straight lexicographical line_ending line_length lines_after_imports lines_between_sections lines_between_types multi_line_output namespace_packages no_inline_sort no_lines_before no_sections old_finders only_modified only_sections order_by_type profile py_version quiet remove_imports remove_redundant_aliases reverse_relative sections single_line_exclusions skip skip_gitignore skip_glob sources src_paths supported_extensions treat_all_comments_as_code treat_comments_as_code use_parentheses variables verbose virtual_env wrap_length","title":"Class variables"},{"location":"reference/isort/settings/#instance-variables","text":"known_patterns section_comments","title":"Instance variables"},{"location":"reference/isort/settings/#methods","text":"","title":"Methods"},{"location":"reference/isort/settings/#is_skipped","text":"def is_skipped ( self , file_path : pathlib . Path ) -> bool Returns True if the file and/or folder should be skipped based on current settings. View Source def is_skipped ( self , file_path : Path ) -> bool : \"\"\"Returns True if the file and/or folder should be skipped based on current settings.\"\"\" if self . directory and Path ( self . directory ) in file_path . resolve (). parents : file_name = os . path . relpath ( file_path . resolve (), self . directory ) else : file_name = str ( file_path ) os_path = str ( file_path ) if self . skip_gitignore : if file_path . name == \".git\" : # pragma : no cover return True result = subprocess . run ( # nosec # skipcq : PYL - W1510 [ \"git\" , \"-C\" , str ( file_path . parent ), \"check-ignore\" , \"--quiet\" , os_path ] ) if result . returncode == 0 : return True normalized_path = os_path . replace ( \"\\\\\" , \"/\" ) if normalized_path [ 1 : 2 ] == \":\" : normalized_path = normalized_path [ 2 :] for skip_path in self . skip : if posixpath . abspath ( normalized_path ) == posixpath . abspath ( skip_path . replace ( \"\\\\\" , \"/\" ) ): return True position = os . path . split ( file_name ) while position [ 1 ]: if position [ 1 ] in self . skip : return True position = os . path . split ( position [ 0 ]) for glob in self . skip_glob : if fnmatch . fnmatch ( file_name , glob ) or fnmatch . fnmatch ( \"/\" + file_name , glob ): return True if not ( os . path . isfile ( os_path ) or os . path . isdir ( os_path ) or os . path . islink ( os_path )): return True return False","title":"is_skipped"},{"location":"reference/isort/settings/#is_supported_filetype","text":"def is_supported_filetype ( self , file_name : str ) View Source def is_supported_filetype ( self , file_name : str ): _root , ext = os . path . splitext ( file_name ) ext = ext . lstrip ( \".\" ) if ext in self . supported_extensions : return True if ext in self . blocked_extensions : return False # Skip editor backup files . if file_name . endswith ( \"~\" ): return False try : if stat . S_ISFIFO ( os . stat ( file_name ). st_mode ): return False except OSError : pass try : with open ( file_name , \"rb\" ) as fp : line = fp . readline ( 100 ) except OSError : return False else : return bool ( _SHEBANG_RE . match ( line ))","title":"is_supported_filetype"},{"location":"reference/isort/setuptools_commands/","text":"Module isort.setuptools_commands View Source import glob import os import sys from typing import Any , Dict , Iterator , List from warnings import warn import setuptools from . import api from .settings import DEFAULT_CONFIG class ISortCommand ( setuptools . Command ): \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ) . copy () for key , value in default_settings . items (): setattr ( self , key , value ) def finalize_options ( self ) -> None : \"\"\"Get options from config files.\"\"\" self . arguments : Dict [ str , Any ] = {} # skipcq: PYL-W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ]: \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : # pragma: no cover package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : # pragma: no cover pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \" %s .py\" % filename # Don't miss the setup.py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma: no cover except OSError as error : # pragma: no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma: no cover Classes ISortCommand class ISortCommand ( dist , ** kw ) The :class: ISortCommand class is used by setuptools to perform imports checks on registered modules. View Source class ISortCommand ( setuptools . Command ) : \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ). copy () for key , value in default_settings . items () : setattr ( self , key , value ) def finalize_options ( self ) -> None : \"\"\"Get options from config files.\"\"\" self . arguments : Dict [ str, Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : # pragma : no cover package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : # pragma : no cover pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False for path in self . distribution_files () : for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )) : try : if not api . check_file ( python_file , ** arguments ) : wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover Ancestors (in MRO) setuptools.Command distutils.cmd.Command Class variables command_consumes_arguments description sub_commands user_options Methods announce def announce ( self , msg , level = 1 ) If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. View Source def announce ( self , msg , level = 1 ): \"\"\"If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. \"\"\" log . log ( level , msg ) copy_file def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ) Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.) View Source def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ): \"\"\"Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.)\"\"\" return file_util . copy_file ( infile , outfile , preserve_mode , preserve_times , not self . force , link , dry_run = self . dry_run ) copy_tree def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ) Copy an entire directory tree respecting verbose, dry-run, and force flags. View Source def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ): \"\"\"Copy an entire directory tree respecting verbose, dry-run, and force flags. \"\"\" return dir_util . copy_tree ( infile , outfile , preserve_mode , preserve_times , preserve_symlinks , not self . force , dry_run = self . dry_run ) debug_print def debug_print ( self , msg ) Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. View Source def debug_print ( self , msg ): \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. \"\"\" from distutils.debug import DEBUG if DEBUG : print ( msg ) sys . stdout . flush () distribution_files def distribution_files ( self ) -> Iterator [ str ] Find distribution packages. View Source def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : # pragma : no cover package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : # pragma : no cover pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\" dump_options def dump_options ( self , header = None , indent = '' ) View Source def dump_options ( self , header = None , indent= \"\" ) : from distutils . fancy_getopt import longopt_xlate if header is None : header = \"command options for '%s':\" % self.get_command_name() self . announce ( indent + header , level = log . INFO ) indent = indent + \" \" for ( option , _ , _ ) in self . user_options: option = option . translate ( longopt_xlate ) if option [ - 1 ] == \"=\" : option = option [:- 1 ] value = getattr ( self , option ) self . announce ( indent + \"%s = %s\" % (option, value), level = log . INFO ) ensure_dirname def ensure_dirname ( self , option ) View Source def ensure_dirname ( self , option ): self . _ensure_tested_string ( option , os . path . isdir , \"directory name\" , \"'%s' does not exist or is not a directory\" ) ensure_filename def ensure_filename ( self , option ) Ensure that 'option' is the name of an existing file. View Source def ensure_filename ( self , option ): \"\"\"Ensure that 'option' is the name of an existing file.\"\"\" self . _ensure_tested_string ( option , os . path . isfile , \"filename\" , \"'%s' does not exist or is not a file\" ) ensure_finalized def ensure_finalized ( self ) View Source def ensure_finalized ( self ): if not self . finalized : self . finalize_options () self . finalized = 1 ensure_string def ensure_string ( self , option , default = None ) Ensure that 'option' is a string; if not defined, set it to 'default'. View Source def ensure_string ( self , option , default = None ): \"\"\"Ensure that 'option' is a string; if not defined, set it to 'default'. \"\"\" self . _ensure_stringlike ( option , \"string\" , default ) ensure_string_list def ensure_string_list ( self , option ) Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \"foo bar baz\", \"foo,bar,baz\", and \"foo, bar baz\" all become [\"foo\", \"bar\", \"baz\"]. View Source def ensure_string_list(self, option): r \"\"\"Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \" foo bar baz \", \" foo , bar , baz \", and \" foo , bar baz \" all become [\" foo \", \" bar \", \" baz \"]. \"\"\" val = getattr ( self , option ) if val is None: return elif isinstance(val, string_types): setattr ( self , option , re . split ( r ' , \\ s *|\\ s + ', val)) else: if isinstance(val, list): ok = all(isinstance(v, string_types) for v in val) else: ok = False if not ok: raise DistutilsOptionError( \"' %s' must be a list of strings (got %r)\" % (option, val)) execute def execute ( self , func , args , msg = None , level = 1 ) View Source def execute ( self , func , args , msg = None , level = 1 ): util . execute ( func , args , msg , dry_run = self . dry_run ) finalize_options def finalize_options ( self ) -> None Get options from config files. View Source def finalize_options ( self ) -> None : \"\"\"Get options from config files.\"\"\" self . arguments : Dict [ str , Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd () get_command_name def get_command_name ( self ) View Source def get_command_name ( self ): if hasattr ( self , 'command_name' ): return self . command_name else : return self . __class__ . __name__ get_finalized_command def get_finalized_command ( self , command , create = 1 ) Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. View Source def get_finalized_command ( self , command , create = 1 ): \"\"\"Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. \"\"\" cmd_obj = self . distribution . get_command_obj ( command , create ) cmd_obj . ensure_finalized () return cmd_obj get_sub_commands def get_sub_commands ( self ) Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. View Source def get_sub_commands ( self ): \"\"\"Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. \"\"\" commands = [] for ( cmd_name , method ) in self . sub_commands : if method is None or method ( self ): commands . append ( cmd_name ) return commands initialize_options def initialize_options ( self ) -> None Set default values for all the options that this command supports. Note that these defaults may be overridden by other commands, by the setup script, by config files, or by the command-line. Thus, this is not the place to code dependencies between options; generally, 'initialize_options()' implementations are just a bunch of \"self.foo = None\" assignments. This method must be implemented by all command classes. View Source def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ) . copy () for key , value in default_settings . items (): setattr ( self , key , value ) make_archive def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ) View Source def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ): return archive_util . make_archive ( base_name , format , root_dir , base_dir , dry_run = self . dry_run , owner = owner , group = group ) make_file def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ) Special case of 'execute()' for operations that process one or more input files and generate one output file. Works just like 'execute()', except the operation is skipped and a different message printed if 'outfile' already exists and is newer than all files listed in 'infiles'. If the command defined 'self.force', and it is true, then the command is unconditionally run -- does no timestamp checks. View Source def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ) : \"\"\"Special case of 'execute()' for operations that process one or more input files and generate one output file . Works just like ' execute ()', except the operation is skipped and a different message printed if ' outfile ' already exists and is newer than all files listed in ' infiles '. If the command defined ' self . force ', and it is true , then the command is unconditionally run -- does no timestamp checks . \"\"\" if skip_msg is None: skip_msg = \"skipping %s (inputs unchanged)\" % outfile # Allow ' infiles ' to be a single string if isinstance ( infiles , str ) : infiles = ( infiles ,) elif not isinstance ( infiles , ( list , tuple )) : raise TypeError ( \"'infiles' must be a string, or a list or tuple of strings\" ) if exec_msg is None: exec_msg = \"generating %s from %s\" % ( outfile , ', '. join ( infiles )) # If ' outfile ' must be regenerated ( either because it doesn ' t # exist , is out - of - date , or the ' force ' flag is true ) then # perform the action that presumably regenerates it if self . force or dep_util . newer_group ( infiles , outfile ) : self . execute ( func , args , exec_msg , level ) # Otherwise , print the \"skip\" message else : log . debug ( skip_msg ) mkpath def mkpath ( self , name , mode = 511 ) View Source def mkpath ( self , name , mode = 0 o777 ): dir_util . mkpath ( name , mode , dry_run = self . dry_run ) move_file def move_file ( self , src , dst , level = 1 ) Move a file respecting dry-run flag. View Source def move_file ( self , src , dst , level = 1 ): \"\"\"Move a file respecting dry-run flag.\"\"\" return file_util . move_file ( src , dst , dry_run = self . dry_run ) reinitialize_command def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ) View Source def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ): cmd = _Command . reinitialize_command ( self , command , reinit_subcommands ) vars ( cmd ) . update ( kw ) return cmd run def run ( self ) -> None A command's raison d'etre: carry out the action it exists to perform, controlled by the options initialized in 'initialize_options()', customized by other commands, the setup script, the command-line, and config files, and finalized in 'finalize_options()'. All terminal output and filesystem interaction should be done by 'run()'. This method must be implemented by all command classes. View Source def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover run_command def run_command ( self , command ) Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. View Source def run_command ( self , command ): \"\"\"Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. \"\"\" self . distribution . run_command ( command ) set_undefined_options def set_undefined_options ( self , src_cmd , * option_pairs ) Set the values of any \"undefined\" options from corresponding option values in some other command object. \"Undefined\" here means \"is None\", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \"take the value of 'src_option' in the 'src_cmd' command object, and copy it to 'dst_option' in the current command object\". View Source def set_undefined_options ( self , src_cmd , * option_pairs ): \"\"\"Set the values of any \" undefined \" options from corresponding option values in some other command object. \" Undefined \" here means \" is None \", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \" take the value of 'src_option' in the 'src_cmd' command object , and copy it to 'dst_option' in the current command object \". \"\"\" # Option_pairs : list of ( src_option , dst_option ) tuples src_cmd_obj = self . distribution . get_command_obj ( src_cmd ) src_cmd_obj . ensure_finalized () for ( src_option , dst_option ) in option_pairs : if getattr ( self , dst_option ) is None : setattr ( self , dst_option , getattr ( src_cmd_obj , src_option )) spawn def spawn ( self , cmd , search_path = 1 , level = 1 ) Spawn an external command respecting dry-run flag. View Source def spawn ( self , cmd , search_path = 1 , level = 1 ): \"\"\"Spawn an external command respecting dry-run flag.\"\"\" from distutils.spawn import spawn spawn ( cmd , search_path , dry_run = self . dry_run ) warn def warn ( self , msg ) View Source def warn ( self , msg ): log . warn ( \"warning: %s: %s\\n\" , self . get_command_name (), msg )","title":"Setuptools Commands"},{"location":"reference/isort/setuptools_commands/#module-isortsetuptools_commands","text":"View Source import glob import os import sys from typing import Any , Dict , Iterator , List from warnings import warn import setuptools from . import api from .settings import DEFAULT_CONFIG class ISortCommand ( setuptools . Command ): \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ) . copy () for key , value in default_settings . items (): setattr ( self , key , value ) def finalize_options ( self ) -> None : \"\"\"Get options from config files.\"\"\" self . arguments : Dict [ str , Any ] = {} # skipcq: PYL-W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ]: \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : # pragma: no cover package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : # pragma: no cover pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \" %s .py\" % filename # Don't miss the setup.py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma: no cover except OSError as error : # pragma: no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma: no cover","title":"Module isort.setuptools_commands"},{"location":"reference/isort/setuptools_commands/#classes","text":"","title":"Classes"},{"location":"reference/isort/setuptools_commands/#isortcommand","text":"class ISortCommand ( dist , ** kw ) The :class: ISortCommand class is used by setuptools to perform imports checks on registered modules. View Source class ISortCommand ( setuptools . Command ) : \"\"\"The :class:`ISortCommand` class is used by setuptools to perform imports checks on registered modules. \"\"\" description = \"Run isort on modules registered in setuptools\" user_options : List [ Any ] = [] def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ). copy () for key , value in default_settings . items () : setattr ( self , key , value ) def finalize_options ( self ) -> None : \"\"\"Get options from config files.\"\"\" self . arguments : Dict [ str, Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd () def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : # pragma : no cover package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : # pragma : no cover pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\" def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False for path in self . distribution_files () : for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )) : try : if not api . check_file ( python_file , ** arguments ) : wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover","title":"ISortCommand"},{"location":"reference/isort/setuptools_commands/#ancestors-in-mro","text":"setuptools.Command distutils.cmd.Command","title":"Ancestors (in MRO)"},{"location":"reference/isort/setuptools_commands/#class-variables","text":"command_consumes_arguments description sub_commands user_options","title":"Class variables"},{"location":"reference/isort/setuptools_commands/#methods","text":"","title":"Methods"},{"location":"reference/isort/setuptools_commands/#announce","text":"def announce ( self , msg , level = 1 ) If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. View Source def announce ( self , msg , level = 1 ): \"\"\"If the current verbosity level is of greater than or equal to 'level' print 'msg' to stdout. \"\"\" log . log ( level , msg )","title":"announce"},{"location":"reference/isort/setuptools_commands/#copy_file","text":"def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ) Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.) View Source def copy_file ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , link = None , level = 1 ): \"\"\"Copy a file respecting verbose, dry-run and force flags. (The former two default to whatever is in the Distribution object, and the latter defaults to false for commands that don't define it.)\"\"\" return file_util . copy_file ( infile , outfile , preserve_mode , preserve_times , not self . force , link , dry_run = self . dry_run )","title":"copy_file"},{"location":"reference/isort/setuptools_commands/#copy_tree","text":"def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ) Copy an entire directory tree respecting verbose, dry-run, and force flags. View Source def copy_tree ( self , infile , outfile , preserve_mode = 1 , preserve_times = 1 , preserve_symlinks = 0 , level = 1 ): \"\"\"Copy an entire directory tree respecting verbose, dry-run, and force flags. \"\"\" return dir_util . copy_tree ( infile , outfile , preserve_mode , preserve_times , preserve_symlinks , not self . force , dry_run = self . dry_run )","title":"copy_tree"},{"location":"reference/isort/setuptools_commands/#debug_print","text":"def debug_print ( self , msg ) Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. View Source def debug_print ( self , msg ): \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the DISTUTILS_DEBUG environment variable) flag is true. \"\"\" from distutils.debug import DEBUG if DEBUG : print ( msg ) sys . stdout . flush ()","title":"debug_print"},{"location":"reference/isort/setuptools_commands/#distribution_files","text":"def distribution_files ( self ) -> Iterator [ str ] Find distribution packages. View Source def distribution_files ( self ) -> Iterator [ str ] : \"\"\"Find distribution packages.\"\"\" # This is verbatim from flake8 if self . distribution . packages : # pragma : no cover package_dirs = self . distribution . package_dir or {} for package in self . distribution . packages : pkg_dir = package if package in package_dirs : pkg_dir = package_dirs [ package ] elif \"\" in package_dirs : # pragma : no cover pkg_dir = package_dirs [ \"\" ] + os . path . sep + pkg_dir yield pkg_dir . replace ( \".\" , os . path . sep ) if self . distribution . py_modules : for filename in self . distribution . py_modules : yield \"%s.py\" % filename # Don ' t miss the setup . py file itself yield \"setup.py\"","title":"distribution_files"},{"location":"reference/isort/setuptools_commands/#dump_options","text":"def dump_options ( self , header = None , indent = '' ) View Source def dump_options ( self , header = None , indent= \"\" ) : from distutils . fancy_getopt import longopt_xlate if header is None : header = \"command options for '%s':\" % self.get_command_name() self . announce ( indent + header , level = log . INFO ) indent = indent + \" \" for ( option , _ , _ ) in self . user_options: option = option . translate ( longopt_xlate ) if option [ - 1 ] == \"=\" : option = option [:- 1 ] value = getattr ( self , option ) self . announce ( indent + \"%s = %s\" % (option, value), level = log . INFO )","title":"dump_options"},{"location":"reference/isort/setuptools_commands/#ensure_dirname","text":"def ensure_dirname ( self , option ) View Source def ensure_dirname ( self , option ): self . _ensure_tested_string ( option , os . path . isdir , \"directory name\" , \"'%s' does not exist or is not a directory\" )","title":"ensure_dirname"},{"location":"reference/isort/setuptools_commands/#ensure_filename","text":"def ensure_filename ( self , option ) Ensure that 'option' is the name of an existing file. View Source def ensure_filename ( self , option ): \"\"\"Ensure that 'option' is the name of an existing file.\"\"\" self . _ensure_tested_string ( option , os . path . isfile , \"filename\" , \"'%s' does not exist or is not a file\" )","title":"ensure_filename"},{"location":"reference/isort/setuptools_commands/#ensure_finalized","text":"def ensure_finalized ( self ) View Source def ensure_finalized ( self ): if not self . finalized : self . finalize_options () self . finalized = 1","title":"ensure_finalized"},{"location":"reference/isort/setuptools_commands/#ensure_string","text":"def ensure_string ( self , option , default = None ) Ensure that 'option' is a string; if not defined, set it to 'default'. View Source def ensure_string ( self , option , default = None ): \"\"\"Ensure that 'option' is a string; if not defined, set it to 'default'. \"\"\" self . _ensure_stringlike ( option , \"string\" , default )","title":"ensure_string"},{"location":"reference/isort/setuptools_commands/#ensure_string_list","text":"def ensure_string_list ( self , option ) Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \"foo bar baz\", \"foo,bar,baz\", and \"foo, bar baz\" all become [\"foo\", \"bar\", \"baz\"]. View Source def ensure_string_list(self, option): r \"\"\"Ensure that 'option' is a list of strings. If 'option' is currently a string, we split it either on /,\\s*/ or /\\s+/, so \" foo bar baz \", \" foo , bar , baz \", and \" foo , bar baz \" all become [\" foo \", \" bar \", \" baz \"]. \"\"\" val = getattr ( self , option ) if val is None: return elif isinstance(val, string_types): setattr ( self , option , re . split ( r ' , \\ s *|\\ s + ', val)) else: if isinstance(val, list): ok = all(isinstance(v, string_types) for v in val) else: ok = False if not ok: raise DistutilsOptionError( \"' %s' must be a list of strings (got %r)\" % (option, val))","title":"ensure_string_list"},{"location":"reference/isort/setuptools_commands/#execute","text":"def execute ( self , func , args , msg = None , level = 1 ) View Source def execute ( self , func , args , msg = None , level = 1 ): util . execute ( func , args , msg , dry_run = self . dry_run )","title":"execute"},{"location":"reference/isort/setuptools_commands/#finalize_options","text":"def finalize_options ( self ) -> None Get options from config files. View Source def finalize_options ( self ) -> None : \"\"\"Get options from config files.\"\"\" self . arguments : Dict [ str , Any ] = {} # skipcq : PYL - W0201 self . arguments [ \"settings_path\" ] = os . getcwd ()","title":"finalize_options"},{"location":"reference/isort/setuptools_commands/#get_command_name","text":"def get_command_name ( self ) View Source def get_command_name ( self ): if hasattr ( self , 'command_name' ): return self . command_name else : return self . __class__ . __name__","title":"get_command_name"},{"location":"reference/isort/setuptools_commands/#get_finalized_command","text":"def get_finalized_command ( self , command , create = 1 ) Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. View Source def get_finalized_command ( self , command , create = 1 ): \"\"\"Wrapper around Distribution's 'get_command_obj()' method: find (create if necessary and 'create' is true) the command object for 'command', call its 'ensure_finalized()' method, and return the finalized command object. \"\"\" cmd_obj = self . distribution . get_command_obj ( command , create ) cmd_obj . ensure_finalized () return cmd_obj","title":"get_finalized_command"},{"location":"reference/isort/setuptools_commands/#get_sub_commands","text":"def get_sub_commands ( self ) Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. View Source def get_sub_commands ( self ): \"\"\"Determine the sub-commands that are relevant in the current distribution (ie., that need to be run). This is based on the 'sub_commands' class attribute: each tuple in that list may include a method that we call to determine if the subcommand needs to be run for the current distribution. Return a list of command names. \"\"\" commands = [] for ( cmd_name , method ) in self . sub_commands : if method is None or method ( self ): commands . append ( cmd_name ) return commands","title":"get_sub_commands"},{"location":"reference/isort/setuptools_commands/#initialize_options","text":"def initialize_options ( self ) -> None Set default values for all the options that this command supports. Note that these defaults may be overridden by other commands, by the setup script, by config files, or by the command-line. Thus, this is not the place to code dependencies between options; generally, 'initialize_options()' implementations are just a bunch of \"self.foo = None\" assignments. This method must be implemented by all command classes. View Source def initialize_options ( self ) -> None : default_settings = vars ( DEFAULT_CONFIG ) . copy () for key , value in default_settings . items (): setattr ( self , key , value )","title":"initialize_options"},{"location":"reference/isort/setuptools_commands/#make_archive","text":"def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ) View Source def make_archive ( self , base_name , format , root_dir = None , base_dir = None , owner = None , group = None ): return archive_util . make_archive ( base_name , format , root_dir , base_dir , dry_run = self . dry_run , owner = owner , group = group )","title":"make_archive"},{"location":"reference/isort/setuptools_commands/#make_file","text":"def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ) Special case of 'execute()' for operations that process one or more input files and generate one output file. Works just like 'execute()', except the operation is skipped and a different message printed if 'outfile' already exists and is newer than all files listed in 'infiles'. If the command defined 'self.force', and it is true, then the command is unconditionally run -- does no timestamp checks. View Source def make_file ( self , infiles , outfile , func , args , exec_msg = None , skip_msg = None , level = 1 ) : \"\"\"Special case of 'execute()' for operations that process one or more input files and generate one output file . Works just like ' execute ()', except the operation is skipped and a different message printed if ' outfile ' already exists and is newer than all files listed in ' infiles '. If the command defined ' self . force ', and it is true , then the command is unconditionally run -- does no timestamp checks . \"\"\" if skip_msg is None: skip_msg = \"skipping %s (inputs unchanged)\" % outfile # Allow ' infiles ' to be a single string if isinstance ( infiles , str ) : infiles = ( infiles ,) elif not isinstance ( infiles , ( list , tuple )) : raise TypeError ( \"'infiles' must be a string, or a list or tuple of strings\" ) if exec_msg is None: exec_msg = \"generating %s from %s\" % ( outfile , ', '. join ( infiles )) # If ' outfile ' must be regenerated ( either because it doesn ' t # exist , is out - of - date , or the ' force ' flag is true ) then # perform the action that presumably regenerates it if self . force or dep_util . newer_group ( infiles , outfile ) : self . execute ( func , args , exec_msg , level ) # Otherwise , print the \"skip\" message else : log . debug ( skip_msg )","title":"make_file"},{"location":"reference/isort/setuptools_commands/#mkpath","text":"def mkpath ( self , name , mode = 511 ) View Source def mkpath ( self , name , mode = 0 o777 ): dir_util . mkpath ( name , mode , dry_run = self . dry_run )","title":"mkpath"},{"location":"reference/isort/setuptools_commands/#move_file","text":"def move_file ( self , src , dst , level = 1 ) Move a file respecting dry-run flag. View Source def move_file ( self , src , dst , level = 1 ): \"\"\"Move a file respecting dry-run flag.\"\"\" return file_util . move_file ( src , dst , dry_run = self . dry_run )","title":"move_file"},{"location":"reference/isort/setuptools_commands/#reinitialize_command","text":"def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ) View Source def reinitialize_command ( self , command , reinit_subcommands = 0 , ** kw ): cmd = _Command . reinitialize_command ( self , command , reinit_subcommands ) vars ( cmd ) . update ( kw ) return cmd","title":"reinitialize_command"},{"location":"reference/isort/setuptools_commands/#run","text":"def run ( self ) -> None A command's raison d'etre: carry out the action it exists to perform, controlled by the options initialized in 'initialize_options()', customized by other commands, the setup script, the command-line, and config files, and finalized in 'finalize_options()'. All terminal output and filesystem interaction should be done by 'run()'. This method must be implemented by all command classes. View Source def run ( self ) -> None : arguments = self . arguments wrong_sorted_files = False for path in self . distribution_files (): for python_file in glob . iglob ( os . path . join ( path , \"*.py\" )): try : if not api . check_file ( python_file , ** arguments ): wrong_sorted_files = True # pragma : no cover except OSError as error : # pragma : no cover warn ( f \"Unable to parse file {python_file} due to {error}\" ) if wrong_sorted_files : sys . exit ( 1 ) # pragma : no cover","title":"run"},{"location":"reference/isort/setuptools_commands/#run_command","text":"def run_command ( self , command ) Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. View Source def run_command ( self , command ): \"\"\"Run some other command: uses the 'run_command()' method of Distribution, which creates and finalizes the command object if necessary and then invokes its 'run()' method. \"\"\" self . distribution . run_command ( command )","title":"run_command"},{"location":"reference/isort/setuptools_commands/#set_undefined_options","text":"def set_undefined_options ( self , src_cmd , * option_pairs ) Set the values of any \"undefined\" options from corresponding option values in some other command object. \"Undefined\" here means \"is None\", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \"take the value of 'src_option' in the 'src_cmd' command object, and copy it to 'dst_option' in the current command object\". View Source def set_undefined_options ( self , src_cmd , * option_pairs ): \"\"\"Set the values of any \" undefined \" options from corresponding option values in some other command object. \" Undefined \" here means \" is None \", which is the convention used to indicate that an option has not been changed between 'initialize_options()' and 'finalize_options()'. Usually called from 'finalize_options()' for options that depend on some other command rather than another option of the same command. 'src_cmd' is the other command from which option values will be taken (a command object will be created for it if necessary); the remaining arguments are '(src_option,dst_option)' tuples which mean \" take the value of 'src_option' in the 'src_cmd' command object , and copy it to 'dst_option' in the current command object \". \"\"\" # Option_pairs : list of ( src_option , dst_option ) tuples src_cmd_obj = self . distribution . get_command_obj ( src_cmd ) src_cmd_obj . ensure_finalized () for ( src_option , dst_option ) in option_pairs : if getattr ( self , dst_option ) is None : setattr ( self , dst_option , getattr ( src_cmd_obj , src_option ))","title":"set_undefined_options"},{"location":"reference/isort/setuptools_commands/#spawn","text":"def spawn ( self , cmd , search_path = 1 , level = 1 ) Spawn an external command respecting dry-run flag. View Source def spawn ( self , cmd , search_path = 1 , level = 1 ): \"\"\"Spawn an external command respecting dry-run flag.\"\"\" from distutils.spawn import spawn spawn ( cmd , search_path , dry_run = self . dry_run )","title":"spawn"},{"location":"reference/isort/setuptools_commands/#warn","text":"def warn ( self , msg ) View Source def warn ( self , msg ): log . warn ( \"warning: %s: %s\\n\" , self . get_command_name (), msg )","title":"warn"},{"location":"reference/isort/sorting/","text":"Module isort.sorting View Source import re from typing import Any , Callable , Iterable , List , Optional from .settings import Config _import_line_intro_re = re . compile ( \"^(?:from|import) \" ) _import_line_midline_import_re = re . compile ( \" import \" ) def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , straight_import : Optional [ bool ] = False , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ) . lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name in config . constants : prefix = \"A\" elif module_name in config . classes : prefix = \"B\" elif module_name in config . variables : prefix = \"C\" elif module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name in config . classes or module_name [ 0 : 1 ] . isupper (): prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = ( config . length_sort or ( config . length_sort_straight and straight_import ) or str ( section_name ) . lower () in config . length_sort_sections ) _length_sort_maybe = ( str ( len ( module_name )) + \":\" + module_name ) if length_sort else module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\" def section_key ( line : str , config : Config ) -> str : section = \"B\" if config . reverse_relative and line . startswith ( \"from .\" ): match = re . match ( r \"^from (\\.+)\\s*(.*)\" , line ) if match : # pragma: no cover - regex always matches if line starts with \"from .\" line = f \"from {' '.join(match.groups())}\" if config . group_by_package and line . strip () . startswith ( \"from\" ): line = line . split ( \" import\" , 1 )[ 0 ] if config . lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in config . force_to_top : section = \"A\" # * If honor_case_in_force_sorted_sections is true, and case_sensitive and # order_by_type are different, only ignore case in part of the line. # * Otherwise, let order_by_type decide the sorting of the whole line. This # is only \"correct\" if case_sensitive and order_by_type have the same value. if config . honor_case_in_force_sorted_sections and config . case_sensitive != config . order_by_type : split_module = line . split ( \" import \" , 1 ) if len ( split_module ) > 1 : module_name , names = split_module if not config . case_sensitive : module_name = module_name . lower () if not config . order_by_type : names = names . lower () line = \" import \" . join ([ module_name , names ]) elif not config . case_sensitive : line = line . lower () elif not config . order_by_type : line = line . lower () return f \"{section}{len(line) if config.length_sort else ''}{line}\" def naturally ( to_sort : Iterable [ str ], key : Optional [ Callable [[ str ], Any ]] = None ) -> List [ str ]: \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ]: return _natural_keys ( key ( text )) # type: ignore return sorted ( to_sort , key = key_callback ) def _atoi ( text : str ) -> Any : return int ( text ) if text . isdigit () else text def _natural_keys ( text : str ) -> List [ Any ]: return [ _atoi ( c ) for c in re . split ( r \"(\\d+)\" , text )] Functions module_key def module_key ( module_name : str , config : isort . settings . Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Union [ Any , NoneType ] = None , straight_import : Union [ bool , NoneType ] = False ) -> str View Source def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , straight_import : Optional [ bool ] = False , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ). lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name in config . constants : prefix = \"A\" elif module_name in config . classes : prefix = \"B\" elif module_name in config . variables : prefix = \"C\" elif module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name in config . classes or module_name [ 0:1 ] . isupper () : prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = ( config . length_sort or ( config . length_sort_straight and straight_import ) or str ( section_name ). lower () in config . length_sort_sections ) _length_sort_maybe = ( str ( len ( module_name )) + \":\" + module_name ) if length_sort else module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\" naturally def naturally ( to_sort : Iterable [ str ], key : Union [ Callable [[ str ], Any ], NoneType ] = None ) -> List [ str ] Returns a naturally sorted list View Source def naturally ( to_sort : Iterable [ str ] , key : Optional [ Callable[[str ] , Any ]] = None ) -> List [ str ] : \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ] : return _natural_keys ( key ( text )) # type : ignore return sorted ( to_sort , key = key_callback ) section_key def section_key ( line : str , config : isort . settings . Config ) -> str View Source def section_key ( line : str , config : Config ) -> str : section = \"B\" if config . reverse_relative and line . startswith ( \"from .\" ): match = re . match ( r \"^from (\\.+)\\s*(.*)\" , line ) if match : # pragma: no cover - regex always matches if line starts with \"from .\" line = f \"from {' '.join(match.groups())}\" if config . group_by_package and line . strip () . startswith ( \"from\" ): line = line . split ( \" import\" , 1 )[ 0 ] if config . lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in config . force_to_top : section = \"A\" # * If honor_case_in_force_sorted_sections is true, and case_sensitive and # order_by_type are different, only ignore case in part of the line. # * Otherwise, let order_by_type decide the sorting of the whole line. This # is only \"correct\" if case_sensitive and order_by_type have the same value. if config . honor_case_in_force_sorted_sections and config . case_sensitive != config . order_by_type : split_module = line . split ( \" import \" , 1 ) if len ( split_module ) > 1 : module_name , names = split_module if not config . case_sensitive : module_name = module_name . lower () if not config . order_by_type : names = names . lower () line = \" import \" . join ([ module_name , names ]) elif not config . case_sensitive : line = line . lower () elif not config . order_by_type : line = line . lower () return f \"{section}{len(line) if config.length_sort else ''}{line}\"","title":"Sorting"},{"location":"reference/isort/sorting/#module-isortsorting","text":"View Source import re from typing import Any , Callable , Iterable , List , Optional from .settings import Config _import_line_intro_re = re . compile ( \"^(?:from|import) \" ) _import_line_midline_import_re = re . compile ( \" import \" ) def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , straight_import : Optional [ bool ] = False , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ) . lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name in config . constants : prefix = \"A\" elif module_name in config . classes : prefix = \"B\" elif module_name in config . variables : prefix = \"C\" elif module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name in config . classes or module_name [ 0 : 1 ] . isupper (): prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = ( config . length_sort or ( config . length_sort_straight and straight_import ) or str ( section_name ) . lower () in config . length_sort_sections ) _length_sort_maybe = ( str ( len ( module_name )) + \":\" + module_name ) if length_sort else module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\" def section_key ( line : str , config : Config ) -> str : section = \"B\" if config . reverse_relative and line . startswith ( \"from .\" ): match = re . match ( r \"^from (\\.+)\\s*(.*)\" , line ) if match : # pragma: no cover - regex always matches if line starts with \"from .\" line = f \"from {' '.join(match.groups())}\" if config . group_by_package and line . strip () . startswith ( \"from\" ): line = line . split ( \" import\" , 1 )[ 0 ] if config . lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in config . force_to_top : section = \"A\" # * If honor_case_in_force_sorted_sections is true, and case_sensitive and # order_by_type are different, only ignore case in part of the line. # * Otherwise, let order_by_type decide the sorting of the whole line. This # is only \"correct\" if case_sensitive and order_by_type have the same value. if config . honor_case_in_force_sorted_sections and config . case_sensitive != config . order_by_type : split_module = line . split ( \" import \" , 1 ) if len ( split_module ) > 1 : module_name , names = split_module if not config . case_sensitive : module_name = module_name . lower () if not config . order_by_type : names = names . lower () line = \" import \" . join ([ module_name , names ]) elif not config . case_sensitive : line = line . lower () elif not config . order_by_type : line = line . lower () return f \"{section}{len(line) if config.length_sort else ''}{line}\" def naturally ( to_sort : Iterable [ str ], key : Optional [ Callable [[ str ], Any ]] = None ) -> List [ str ]: \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ]: return _natural_keys ( key ( text )) # type: ignore return sorted ( to_sort , key = key_callback ) def _atoi ( text : str ) -> Any : return int ( text ) if text . isdigit () else text def _natural_keys ( text : str ) -> List [ Any ]: return [ _atoi ( c ) for c in re . split ( r \"(\\d+)\" , text )]","title":"Module isort.sorting"},{"location":"reference/isort/sorting/#functions","text":"","title":"Functions"},{"location":"reference/isort/sorting/#module_key","text":"def module_key ( module_name : str , config : isort . settings . Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Union [ Any , NoneType ] = None , straight_import : Union [ bool , NoneType ] = False ) -> str View Source def module_key ( module_name : str , config : Config , sub_imports : bool = False , ignore_case : bool = False , section_name : Optional [ Any ] = None , straight_import : Optional [ bool ] = False , ) -> str : match = re . match ( r \"^(\\.+)\\s*(.*)\" , module_name ) if match : sep = \" \" if config . reverse_relative else \"_\" module_name = sep . join ( match . groups ()) prefix = \"\" if ignore_case : module_name = str ( module_name ). lower () else : module_name = str ( module_name ) if sub_imports and config . order_by_type : if module_name in config . constants : prefix = \"A\" elif module_name in config . classes : prefix = \"B\" elif module_name in config . variables : prefix = \"C\" elif module_name . isupper () and len ( module_name ) > 1 : # see issue #376 prefix = \"A\" elif module_name in config . classes or module_name [ 0:1 ] . isupper () : prefix = \"B\" else : prefix = \"C\" if not config . case_sensitive : module_name = module_name . lower () length_sort = ( config . length_sort or ( config . length_sort_straight and straight_import ) or str ( section_name ). lower () in config . length_sort_sections ) _length_sort_maybe = ( str ( len ( module_name )) + \":\" + module_name ) if length_sort else module_name return f \"{module_name in config.force_to_top and 'A' or 'B'}{prefix}{_length_sort_maybe}\"","title":"module_key"},{"location":"reference/isort/sorting/#naturally","text":"def naturally ( to_sort : Iterable [ str ], key : Union [ Callable [[ str ], Any ], NoneType ] = None ) -> List [ str ] Returns a naturally sorted list View Source def naturally ( to_sort : Iterable [ str ] , key : Optional [ Callable[[str ] , Any ]] = None ) -> List [ str ] : \"\"\"Returns a naturally sorted list\"\"\" if key is None : key_callback = _natural_keys else : def key_callback ( text : str ) -> List [ Any ] : return _natural_keys ( key ( text )) # type : ignore return sorted ( to_sort , key = key_callback )","title":"naturally"},{"location":"reference/isort/sorting/#section_key","text":"def section_key ( line : str , config : isort . settings . Config ) -> str View Source def section_key ( line : str , config : Config ) -> str : section = \"B\" if config . reverse_relative and line . startswith ( \"from .\" ): match = re . match ( r \"^from (\\.+)\\s*(.*)\" , line ) if match : # pragma: no cover - regex always matches if line starts with \"from .\" line = f \"from {' '.join(match.groups())}\" if config . group_by_package and line . strip () . startswith ( \"from\" ): line = line . split ( \" import\" , 1 )[ 0 ] if config . lexicographical : line = _import_line_intro_re . sub ( \"\" , _import_line_midline_import_re . sub ( \".\" , line )) else : line = re . sub ( \"^from \" , \"\" , line ) line = re . sub ( \"^import \" , \"\" , line ) if line . split ( \" \" )[ 0 ] in config . force_to_top : section = \"A\" # * If honor_case_in_force_sorted_sections is true, and case_sensitive and # order_by_type are different, only ignore case in part of the line. # * Otherwise, let order_by_type decide the sorting of the whole line. This # is only \"correct\" if case_sensitive and order_by_type have the same value. if config . honor_case_in_force_sorted_sections and config . case_sensitive != config . order_by_type : split_module = line . split ( \" import \" , 1 ) if len ( split_module ) > 1 : module_name , names = split_module if not config . case_sensitive : module_name = module_name . lower () if not config . order_by_type : names = names . lower () line = \" import \" . join ([ module_name , names ]) elif not config . case_sensitive : line = line . lower () elif not config . order_by_type : line = line . lower () return f \"{section}{len(line) if config.length_sort else ''}{line}\"","title":"section_key"},{"location":"reference/isort/utils/","text":"Module isort.utils View Source import os import sys def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result Functions exists_case_sensitive def exists_case_sensitive ( path : str ) -> bool Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. View Source def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result","title":"Utils"},{"location":"reference/isort/utils/#module-isortutils","text":"View Source import os import sys def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result","title":"Module isort.utils"},{"location":"reference/isort/utils/#functions","text":"","title":"Functions"},{"location":"reference/isort/utils/#exists_case_sensitive","text":"def exists_case_sensitive ( path : str ) -> bool Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. View Source def exists_case_sensitive ( path : str ) -> bool : \"\"\"Returns if the given path exists and also matches the case on Windows. When finding files that can be imported, it is important for the cases to match because while file os.path.exists(\"module.py\") and os.path.exists(\"MODULE.py\") both return True on Windows, Python can only import using the case of the real file. \"\"\" result = os . path . exists ( path ) if ( sys . platform . startswith ( \"win\" ) or sys . platform == \"darwin\" ) and result : # pragma: no cover directory , basename = os . path . split ( path ) result = basename in os . listdir ( directory ) return result","title":"exists_case_sensitive"},{"location":"reference/isort/wrap/","text":"Module isort.wrap View Source import copy import re from typing import List , Optional , Sequence from . settings import DEFAULT_CONFIG , Config from . wrap_modes import WrapModes as Modes from . wrap_modes import formatter_from_string def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment and not ( config . use_parentheses and \"noqa\" in comment ) : _ comma_maybe = ( \",\" if ( config . include_trailing_comma and config . use_parentheses and not line_without_comment . rstrip (). endswith ( \",\" ) ) else \"\" ) line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe}{config.comment_prefix}{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config , ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" _ comment = \"\" if comment and \"noqa\" in comment : _ comment = f \"{config.comment_prefix}{comment}\" cont_line = cont_line . rstrip () _ comma = \",\" if config . include_trailing_comma else \"\" output = ( f \"{content}{splitter}({_comment}\" f \"{line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content _ wrap_line = line Functions import_statement def import_statement ( import_start : str , from_imports : List [ str ], comments : Sequence [ str ] = (), line_separator : str = ' \\n ' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), multi_line_output : Union [ isort . wrap_modes . WrapModes , NoneType ] = None ) -> str Returns a multi-line wrapped form of the provided from import statement. View Source def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement line def line ( content : str , line_separator : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> str Returns a line wrapped to the specified line-length, if possible. View Source def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment and not ( config . use_parentheses and \"noqa\" in comment ) : _ comma_maybe = ( \",\" if ( config . include_trailing_comma and config . use_parentheses and not line_without_comment . rstrip (). endswith ( \",\" ) ) else \"\" ) line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe}{config.comment_prefix}{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config , ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" _ comment = \"\" if comment and \"noqa\" in comment : _ comment = f \"{config.comment_prefix}{comment}\" cont_line = cont_line . rstrip () _ comma = \",\" if config . include_trailing_comma else \"\" output = ( f \"{content}{splitter}({_comment}\" f \"{line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content","title":"Wrap"},{"location":"reference/isort/wrap/#module-isortwrap","text":"View Source import copy import re from typing import List , Optional , Sequence from . settings import DEFAULT_CONFIG , Config from . wrap_modes import WrapModes as Modes from . wrap_modes import formatter_from_string def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment and not ( config . use_parentheses and \"noqa\" in comment ) : _ comma_maybe = ( \",\" if ( config . include_trailing_comma and config . use_parentheses and not line_without_comment . rstrip (). endswith ( \",\" ) ) else \"\" ) line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe}{config.comment_prefix}{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config , ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" _ comment = \"\" if comment and \"noqa\" in comment : _ comment = f \"{config.comment_prefix}{comment}\" cont_line = cont_line . rstrip () _ comma = \",\" if config . include_trailing_comma else \"\" output = ( f \"{content}{splitter}({_comment}\" f \"{line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content _ wrap_line = line","title":"Module isort.wrap"},{"location":"reference/isort/wrap/#functions","text":"","title":"Functions"},{"location":"reference/isort/wrap/#import_statement","text":"def import_statement ( import_start : str , from_imports : List [ str ], comments : Sequence [ str ] = (), line_separator : str = ' \\n ' , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ), multi_line_output : Union [ isort . wrap_modes . WrapModes , NoneType ] = None ) -> str Returns a multi-line wrapped form of the provided from import statement. View Source def import_statement ( import_start: str , from_imports: List [ str ], comments : Sequence [ str ] = (), line_separator: str = \"\\n\" , config : Config = DEFAULT_CONFIG , multi_line_output: Optional [ Modes ] = None , ) -> str : \"\"\"Returns a multi-line wrapped form of the provided from import statement.\"\"\" formatter = formatter_from_string (( multi_line_output or config . multi_line_output ). name ) dynamic_indent = \" \" * ( len ( import_start ) + 1 ) indent = config . indent line_length = config . wrap_length or config . line_length statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) if config . balanced_wrapping: lines = statement . split ( line_separator ) line_count = len ( lines ) if len ( lines ) > 1 : minimum_length = min ( len ( line ) for line in lines [:- 1 ]) else : minimum_length = 0 new_import_statement = statement while len ( lines [ - 1 ]) < minimum_length and len ( lines ) == line_count and line_length > 10 : statement = new_import_statement line_length -= 1 new_import_statement = formatter ( statement = import_start , imports = copy . copy ( from_imports ), white_space = dynamic_indent , indent = indent , line_length = line_length , comments = comments , line_separator = line_separator , comment_prefix = config . comment_prefix , include_trailing_comma = config . include_trailing_comma , remove_comments = config . ignore_comments , ) lines = new_import_statement . split ( line_separator ) if statement . count ( line_separator ) == 0 : return _ wrap_line ( statement , line_separator , config ) return statement","title":"import_statement"},{"location":"reference/isort/wrap/#line","text":"def line ( content : str , line_separator : str , config : isort . settings . Config = Config ( py_version = 'py3' , force_to_top = frozenset (), skip = frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), skip_glob = frozenset (), skip_gitignore = False , line_length = 79 , wrap_length = 0 , line_ending = '' , sections = ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), no_sections = False , known_future_library = frozenset ({ '__future__' }), known_third_party = frozenset (), known_first_party = frozenset (), known_local_folder = frozenset (), known_standard_library = frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), extra_standard_library = frozenset (), known_other = {}, multi_line_output =< WrapModes . GRID : 0 > , forced_separate = (), indent = ' ' , comment_prefix = ' #' , length_sort = False , length_sort_straight = False , length_sort_sections = frozenset (), add_imports = frozenset (), remove_imports = frozenset (), append_only = False , reverse_relative = False , force_single_line = False , single_line_exclusions = (), default_section = 'THIRDPARTY' , import_headings = {}, balanced_wrapping = False , use_parentheses = False , order_by_type = True , atomic = False , lines_after_imports =- 1 , lines_between_sections = 1 , lines_between_types = 0 , combine_as_imports = False , combine_star = False , include_trailing_comma = False , from_first = False , verbose = False , quiet = False , force_adds = False , force_alphabetical_sort_within_sections = False , force_alphabetical_sort = False , force_grid_wrap = 0 , force_sort_within_sections = False , lexicographical = False , group_by_package = False , ignore_whitespace = False , no_lines_before = frozenset (), no_inline_sort = False , ignore_comments = False , case_sensitive = False , sources = ({ 'py_version' : 'py3' , 'force_to_top' : frozenset (), 'skip' : frozenset ({ '.svn' , '.mypy_cache' , '_build' , '.nox' , '.git' , 'dist' , '.eggs' , 'venv' , '.hg' , '.pants.d' , 'node_modules' , '.direnv' , '.venv' , 'buck-out' , 'build' , '.tox' , '.bzr' }), 'skip_glob' : frozenset (), 'skip_gitignore' : False , 'line_length' : 79 , 'wrap_length' : 0 , 'line_ending' : '' , 'sections' : ( 'FUTURE' , 'STDLIB' , 'THIRDPARTY' , 'FIRSTPARTY' , 'LOCALFOLDER' ), 'no_sections' : False , 'known_future_library' : frozenset ({ '__future__' }), 'known_third_party' : frozenset (), 'known_first_party' : frozenset (), 'known_local_folder' : frozenset (), 'known_standard_library' : frozenset ({ 'chunk' , 'pstats' , 'mmap' , 'zipfile' , 'posixpath' , 'math' , 'getpass' , 'grp' , 'venv' , 'syslog' , 'ftplib' , 'pickle' , 'bdb' , 'zipimport' , 'pprint' , 'difflib' , 'netrc' , 'zoneinfo' , 'gc' , 'stringprep' , 'numbers' , 'timeit' , 'weakref' , 'pathlib' , 'poplib' , 'compileall' , 'typing' , 'modulefinder' , 'functools' , 'secrets' , 'winreg' , 'aifc' , 'cmd' , 'tempfile' , 'macpath' , 'binascii' , 'formatter' , 'plistlib' , 'ctypes' , 'bz2' , 'string' , 'asynchat' , 'glob' , 'ipaddress' , 'dbm' , 'zipapp' , 'unittest' , 'shutil' , 'codecs' , 'base64' , 'threading' , 'codeop' , 'socketserver' , 'json' , 'warnings' , 'keyword' , 'sched' , 'enum' , 'dis' , 'pickletools' , 'code' , 'atexit' , 'distutils' , 'runpy' , 'select' , 'email' , 'tkinter' , 'locale' , 'py_compile' , 'sysconfig' , 'multiprocessing' , 'turtle' , 'quopri' , 'tarfile' , 'argparse' , 'errno' , '_dummy_thread' , 'signal' , 'configparser' , 'tty' , 'os' , 'concurrent' , 'logging' , 'ossaudiodev' , 'decimal' , 'heapq' , 'calendar' , 'rlcompleter' , 'msilib' , 'readline' , 'shlex' , 'xml' , 'ssl' , 'socket' , 'lib2to3' , 'faulthandler' , 'urllib' , 'xmlrpc' , 'abc' , 'cProfile' , 'tokenize' , 'textwrap' , 'importlib' , 'collections' , 'shelve' , 'inspect' , 'fileinput' , 'datetime' , 'pydoc' , 'optparse' , 'pyclbr' , 'mailcap' , 'tracemalloc' , 'imaplib' , 'cmath' , 'curses' , 'selectors' , 'binhex' , 'asyncore' , 'sre' , 'crypt' , 'unicodedata' , 'sre_constants' , 'asyncio' , 'resource' , 'statistics' , 'subprocess' , 'cgi' , 'io' , 'doctest' , 'xdrlib' , 'fnmatch' , 'http' , 'token' , 'mimetypes' , 'sys' , 'profile' , 'pkgutil' , 'sre_compile' , 'smtpd' , 'stat' , 'gzip' , 'nis' , 'queue' , 'dummy_threading' , 'zlib' , 'marshal' , 'test' , 'telnetlib' , 'fractions' , 'csv' , 'wave' , 'sunau' , 'termios' , 'filecmp' , 'spwd' , 'pwd' , 'traceback' , 'encodings' , 'trace' , 'struct' , 'time' , 'pdb' , 'smtplib' , 'audioop' , 'nntplib' , 'mailbox' , 'wsgiref' , 'site' , 'array' , 'gettext' , 'fcntl' , 'uuid' , 'symbol' , 'html' , 'pty' , 'builtins' , 'getopt' , 'imp' , 're' , 'posix' , 'operator' , 'imghdr' , 'msvcrt' , 'copyreg' , 'itertools' , 'sre_parse' , 'contextlib' , 'types' , 'webbrowser' , 'bisect' , 'platform' , 'symtable' , 'ensurepip' , 'hashlib' , 'sndhdr' , 'hmac' , 'contextvars' , 'lzma' , 'reprlib' , 'tabnanny' , 'copy' , 'dataclasses' , 'linecache' , 'uu' , 'turtledemo' , 'graphlib' , 'sqlite3' , 'fpectl' , 'cgitb' , 'random' , 'winsound' , 'ntpath' , 'ast' , 'parser' , '_thread' , 'colorsys' , 'pipes' }), 'extra_standard_library' : frozenset (), 'known_other' : {}, 'multi_line_output' : < WrapModes . GRID : 0 > , 'forced_separate' : (), 'indent' : ' ' , 'comment_prefix' : ' #' , 'length_sort' : False , 'length_sort_straight' : False , 'length_sort_sections' : frozenset (), 'add_imports' : frozenset (), 'remove_imports' : frozenset (), 'append_only' : False , 'reverse_relative' : False , 'force_single_line' : False , 'single_line_exclusions' : (), 'default_section' : 'THIRDPARTY' , 'import_headings' : {}, 'balanced_wrapping' : False , 'use_parentheses' : False , 'order_by_type' : True , 'atomic' : False , 'lines_after_imports' : - 1 , 'lines_between_sections' : 1 , 'lines_between_types' : 0 , 'combine_as_imports' : False , 'combine_star' : False , 'include_trailing_comma' : False , 'from_first' : False , 'verbose' : False , 'quiet' : False , 'force_adds' : False , 'force_alphabetical_sort_within_sections' : False , 'force_alphabetical_sort' : False , 'force_grid_wrap' : 0 , 'force_sort_within_sections' : False , 'lexicographical' : False , 'group_by_package' : False , 'ignore_whitespace' : False , 'no_lines_before' : frozenset (), 'no_inline_sort' : False , 'ignore_comments' : False , 'case_sensitive' : False , 'sources' : (), 'virtual_env' : '' , 'conda_env' : '' , 'ensure_newline_before_comments' : False , 'directory' : '' , 'profile' : '' , 'honor_noqa' : False , 'src_paths' : (), 'old_finders' : False , 'remove_redundant_aliases' : False , 'float_to_top' : False , 'filter_files' : False , 'formatter' : '' , 'formatting_function' : None , 'color_output' : False , 'treat_comments_as_code' : frozenset (), 'treat_all_comments_as_code' : False , 'supported_extensions' : frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), 'blocked_extensions' : frozenset ({ 'pex' }), 'constants' : frozenset (), 'classes' : frozenset (), 'variables' : frozenset (), 'dedup_headings' : False , 'only_sections' : False , 'only_modified' : False , 'combine_straight_imports' : False , 'auto_identify_namespace_packages' : True , 'namespace_packages' : frozenset (), 'follow_links' : True , 'indented_import_headings' : True , 'honor_case_in_force_sorted_sections' : False , 'source' : 'defaults' },), virtual_env = '' , conda_env = '' , ensure_newline_before_comments = False , directory = '/home/tim/Projects/isort' , profile = '' , honor_noqa = False , src_paths = ( PosixPath ( '/home/tim/Projects/isort/src' ), PosixPath ( '/home/tim/Projects/isort' )), old_finders = False , remove_redundant_aliases = False , float_to_top = False , filter_files = False , formatter = '' , formatting_function = None , color_output = False , treat_comments_as_code = frozenset (), treat_all_comments_as_code = False , supported_extensions = frozenset ({ 'py' , 'pyx' , 'pxd' , 'pyi' }), blocked_extensions = frozenset ({ 'pex' }), constants = frozenset (), classes = frozenset (), variables = frozenset (), dedup_headings = False , only_sections = False , only_modified = False , combine_straight_imports = False , auto_identify_namespace_packages = True , namespace_packages = frozenset (), follow_links = True , indented_import_headings = True , honor_case_in_force_sorted_sections = False ) ) -> str Returns a line wrapped to the specified line-length, if possible. View Source def line ( content : str , line_separator: str , config : Config = DEFAULT_CONFIG ) -> str : \"\"\"Returns a line wrapped to the specified line-length, if possible.\"\"\" wrap_mode = config . multi_line_output if len ( content ) > config . line_length and wrap_mode ! = Modes . NOQA : # type : ignore line_without_comment = content comment = None if \"#\" in content : line_without_comment , comment = content . split ( \"#\" , 1 ) for splitter in ( \"import \" , \".\" , \"as \" ) : exp = r \"\\b\" + re . escape ( splitter ) + r \"\\b\" if re . search ( exp , line_without_comment ) and not line_without_comment . strip (). startswith ( splitter ) : line_parts = re . split ( exp , line_without_comment ) if comment and not ( config . use_parentheses and \"noqa\" in comment ) : _ comma_maybe = ( \",\" if ( config . include_trailing_comma and config . use_parentheses and not line_without_comment . rstrip (). endswith ( \",\" ) ) else \"\" ) line_parts [ - 1 ] = f \"{line_parts[-1].strip()}{_comma_maybe}{config.comment_prefix}{comment}\" next_line = [] while ( len ( content ) + 2 ) > ( config . wrap_length or config . line_length ) and line_parts: next_line . append ( line_parts . pop ()) content = splitter . join ( line_parts ) if not content : content = next_line . pop () cont_line = _ wrap_line ( config . indent + splitter . join ( next_line ). lstrip (), line_separator , config , ) if config . use_parentheses: if splitter == \"as \" : output = f \"{content}{splitter}{cont_line.lstrip()}\" else : _ comma = \",\" if config . include_trailing_comma and not comment else \"\" if wrap_mode in ( Modes . VERTICAL_HANGING_INDENT , # type : ignore Modes . VERTICAL_GRID_GROUPED , # type : ignore ) : _ separator = line_separator else : _ separator = \"\" _ comment = \"\" if comment and \"noqa\" in comment : _ comment = f \"{config.comment_prefix}{comment}\" cont_line = cont_line . rstrip () _ comma = \",\" if config . include_trailing_comma else \"\" output = ( f \"{content}{splitter}({_comment}\" f \"{line_separator}{cont_line}{_comma}{_separator})\" ) lines = output . split ( line_separator ) if config . comment_prefix in lines [ - 1 ] and lines [ - 1 ]. endswith ( \")\" ) : content , comment = lines [ - 1 ]. split ( config . comment_prefix , 1 ) lines [ - 1 ] = content + \")\" + config . comment_prefix + comment [:- 1 ] return line_separator . join ( lines ) return f \" { content }{ splitter } \\\\ { line_separator }{ cont_line } \" elif len(content) > config.line_length and wrap_mode == Modes.NOQA: # type: ignore if \" # NOQA \" not in content: return f\" { content }{ config . comment_prefix } NOQA \" return content","title":"line"},{"location":"reference/isort/wrap_modes/","text":"Module isort.wrap_modes Defines all wrap modes that can be used when outputting formatted imports View Source \"\"\"Defines all wrap modes that can be used when outputting formatted imports\"\"\" import enum from inspect import signature from typing import Any , Callable , Dict , List import isort . comments _ wrap_modes: Dict [ str , Callable [[ Any ], str ]] = {} def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value )) def formatter_from_string ( name : str ) : return _ wrap_modes . get ( name . upper (), grid ) def _ wrap_mode_interface ( statement : str , imports : List [ str ], white_space: str , indent : str , line_length: int , comments : List [ str ], line_separator: str , comment_prefix: str , include_trailing_comma: bool , remove_comments: bool , ) -> str : \"\"\"Defines the common interface used by all wrap mode functions\"\"\" return \"\" def _ wrap_mode ( function ) : \"\"\"Registers an individual wrap mode. Function name and order are significant and used for creating enum. \"\"\" _ wrap_modes [ function . __ name__ . upper ()] = function function . __ signature__ = signature ( _ wrap_mode_interface ) function . __ annotations__ = _ wrap_mode_interface . __ annotations__ return function @ _ wrap_mode def grid ( **interface ) : if not interface [ \"imports\" ] : return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ]. pop ( 0 ) while interface [ \"imports\" ] : next_import = interface [ \"imports\" ]. pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ) : lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 : ] : new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ] : lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ]. join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\" @ _ wrap_mode def vertical ( **interface ) : if not interface [ \"imports\" ] : return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ]. pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _ imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]). join ( interface [ \"imports\" ] ) _ comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\" def _ hanging_indent_common ( use_parentheses = False , **interface ) : if not interface [ \"imports\" ] : return \"\" line_length_limit = interface [ \"line_length\" ] - ( 1 if use_parentheses else 3 ) def end_line ( line ) : if use_parentheses: return line if not line . endswith ( \" \" ) : line += \" \" return line + \" \\\\ \" if use_parentheses: interface[\" statement \"] += \" ( \" next_import = interface[\" imports \"].pop(0) next_statement = interface[\" statement \"] + next_import # Check for first import if len(next_statement) > line_length_limit: next_statement = ( isort.comments.add_to_line( interface[\" comments \"], end_line(interface[\" statement \"]), removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = isort.comments.add_to_line( interface[\" comments \"], interface[\" statement \"] + \" , \" + next_import, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) current_line = next_statement.split(interface[\" line_separator \"])[-1] if len(current_line) > line_length_limit: next_statement = ( isort.comments.add_to_line( interface[\" comments \"], end_line(interface[\" statement \"] + \" , \"), removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement _comma_maybe = \" , \" if interface[\" include_trailing_comma \"] else \"\" _close_parentheses_maybe = \" ) \" if use_parentheses else \"\" return interface[\" statement \"] + _comma_maybe + _close_parentheses_maybe @_wrap_mode def hanging_indent(**interface): return _hanging_indent_common(use_parentheses=False, **interface) @_wrap_mode def vertical_hanging_indent(**interface): _line_with_comments = isort.comments.add_to_line( interface[\" comments \"], \"\", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) _imports = (\" , \" + interface[\" line_separator \"] + interface[\" indent \"]).join(interface[\" imports \"]) _comma_maybe = \" , \" if interface[\" include_trailing_comma \"] else \"\" return ( f\" { interface [ 'statement' ]}({ _ line_with_comments }{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ _ imports }{ _ comma_maybe }{ interface [ 'line_separator' ]}) \" ) def _vertical_grid_common(need_trailing_char: bool, **interface): if not interface[\" imports \"]: return \"\" interface[\" statement \"] += ( isort.comments.add_to_line( interface[\" comments \"], \" ( \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + interface[\" line_separator \"] + interface[\" indent \"] + interface[\" imports \"].pop(0) ) while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = f\" { interface [ 'statement' ]}, { next_import } \" current_line_length = len(next_statement.split(interface[\" line_separator \"])[-1]) if interface[\" imports \"] or interface[\" include_trailing_comma \"]: # We need to account for a comma after this import. current_line_length += 1 if not interface[\" imports \"] and need_trailing_char: # We need to account for a closing ) we're going to add. current_line_length += 1 if current_line_length > interface[\" line_length \"]: next_statement = ( f\" { interface [ 'statement' ]},{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ next_import } \" ) interface[\" statement \"] = next_statement if interface[\" include_trailing_comma \"]: interface[\" statement \"] += \" , \" return interface[\" statement \"] @_wrap_mode def vertical_grid(**interface) -> str: return _vertical_grid_common(need_trailing_char=True, **interface) + \" ) \" @_wrap_mode def vertical_grid_grouped(**interface): return ( _vertical_grid_common(need_trailing_char=False, **interface) + interface[\" line_separator \"] + \" ) \" ) @_wrap_mode def vertical_grid_grouped_no_comma(**interface): # This is a deprecated alias for vertical_grid_grouped above. This function # needs to exist for backwards compatibility but should never get called. raise NotImplementedError @_wrap_mode def noqa(**interface): _imports = \" , \".join(interface[\" imports \"]) retval = f\" { interface [ 'statement' ]}{ _ imports } \" comment_str = \" \".join(interface[\" comments \"]) if interface[\" comments \"]: if ( len(retval) + len(interface[\" comment_prefix \"]) + 1 + len(comment_str) <= interface[\" line_length \"] ): return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" if \" NOQA \" in interface[\" comments \"]: return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA { comment_str } \" if len(retval) <= interface[\" line_length \"]: return retval return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA \" @_wrap_mode def vertical_hanging_indent_bracket(**interface): if not interface[\" imports \"]: return \"\" statement = vertical_hanging_indent(**interface) return f'{statement[:-1]}{interface[\" indent \"]})' @_wrap_mode def vertical_prefix_from_module_import(**interface): if not interface[\" imports \"]: return \"\" prefix_statement = interface[\" statement \"] output_statement = prefix_statement + interface[\" imports \"].pop(0) comments = interface[\" comments \"] statement = output_statement statement_with_comments = \"\" for next_import in interface[\" imports \"]: statement = statement + \" , \" + next_import statement_with_comments = isort.comments.add_to_line( comments, statement, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) if ( len(statement_with_comments.split(interface[\" line_separator \"])[-1]) + 1 > interface[\" line_length \"] ): statement = ( isort.comments.add_to_line( comments, output_statement, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ prefix_statement }{ next_import } \" ) comments = [] output_statement = statement if comments and statement_with_comments: output_statement = statement_with_comments return output_statement @_wrap_mode def hanging_indent_with_parentheses(**interface): return _hanging_indent_common(use_parentheses=True, **interface) @_wrap_mode def backslash_grid(**interface): interface[\" indent \"] = interface[\" white_space \"][:-1] return _hanging_indent_common(use_parentheses=False, **interface) WrapModes = enum.Enum( # type: ignore \" WrapModes \" , { wrap_mode: index for index , wrap_mode in enumerate ( _ wrap_modes . keys ())} ) Functions backslash_grid def backslash_grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @ _ wrap_mode def backslash_grid ( **interface ) : interface [ \"indent\" ] = interface [ \"white_space\" ][:- 1 ] return _ hanging_indent_common ( use_parentheses = False , **interface ) formatter_from_string def formatter_from_string ( name : str ) View Source def formatter_from_string ( name : str ): return _wrap_modes . get ( name . upper (), grid ) from_string def from_string ( value : str ) -> 'WrapModes' View Source def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value )) grid def grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def grid ( ** interface ): if not interface [ \"imports\" ]: return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ] . pop ( 0 ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 :]: new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ]: lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ] . join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\" hanging_indent def hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def hanging_indent ( ** interface ) : return _hanging_indent_common ( use_parentheses = False , ** interface ) hanging_indent_with_parentheses def hanging_indent_with_parentheses ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def hanging_indent_with_parentheses ( ** interface ) : return _hanging_indent_common ( use_parentheses = True , ** interface ) noqa def noqa ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def noqa ( ** interface ) : _imports = \", \" . join ( interface [ \"imports\" ] ) retval = f \"{interface['statement']}{_imports}\" comment_str = \" \" . join ( interface [ \"comments\" ] ) if interface [ \"comments\" ] : if ( len ( retval ) + len ( interface [ \"comment_prefix\" ] ) + 1 + len ( comment_str ) <= interface [ \"line_length\" ] ) : return f \"{retval}{interface['comment_prefix']} {comment_str}\" if \"NOQA\" in interface [ \"comments\" ] : return f \"{retval}{interface['comment_prefix']} {comment_str}\" return f \"{retval}{interface['comment_prefix']} NOQA {comment_str}\" if len ( retval ) <= interface [ \"line_length\" ] : return retval return f \"{retval}{interface['comment_prefix']} NOQA\" vertical def vertical ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical ( ** interface ): if not interface [ \"imports\" ]: return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ] . pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]) . join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\" vertical_grid def vertical_grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid ( ** interface ) -> str : return _vertical_grid_common ( need_trailing_char = True , ** interface ) + \")\" vertical_grid_grouped def vertical_grid_grouped ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped ( ** interface ) : return ( _vertical_grid_common ( need_trailing_char = False , ** interface ) + interface [ \"line_separator\" ] + \")\" ) vertical_grid_grouped_no_comma def vertical_grid_grouped_no_comma ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped_no_comma ( ** interface ) : # This is a deprecated alias for vertical_grid_grouped above . This function # needs to exist for backwards compatibility but should never get called . raise NotImplementedError vertical_hanging_indent def vertical_hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_hanging_indent ( ** interface ) : _line_with_comments = isort . comments . add_to_line ( interface [ \"comments\" ] , \"\" , removed = interface [ \"remove_comments\" ] , comment_prefix = interface [ \"comment_prefix\" ] , ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"indent\" ] ). join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return ( f \"{interface['statement']}({_line_with_comments}{interface['line_separator']}\" f \"{interface['indent']}{_imports}{_comma_maybe}{interface['line_separator']})\" ) vertical_hanging_indent_bracket def vertical_hanging_indent_bracket ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @ _ wrap_mode def vertical_hanging_indent_bracket ( **interface ) : if not interface [ \"imports\" ] : return \"\" statement = vertical_hanging_indent ( **interface ) return f'{statement[:-1]}{interface[\"indent\"]})' vertical_prefix_from_module_import def vertical_prefix_from_module_import ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_prefix_from_module_import ( ** interface ): if not interface [ \"imports\" ]: return \"\" prefix_statement = interface [ \"statement\" ] output_statement = prefix_statement + interface [ \"imports\" ] . pop ( 0 ) comments = interface [ \"comments\" ] statement = output_statement statement_with_comments = \"\" for next_import in interface [ \"imports\" ]: statement = statement + \", \" + next_import statement_with_comments = isort . comments . add_to_line ( comments , statement , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( statement_with_comments . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): statement = ( isort . comments . add_to_line ( comments , output_statement , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{prefix_statement}{next_import}\" ) comments = [] output_statement = statement if comments and statement_with_comments : output_statement = statement_with_comments return output_statement Classes WrapModes class WrapModes ( / , * args , ** kwargs ) An enumeration. Ancestors (in MRO) enum.Enum Class variables BACKSLASH_GRID GRID HANGING_INDENT HANGING_INDENT_WITH_PARENTHESES NOQA VERTICAL VERTICAL_GRID VERTICAL_GRID_GROUPED VERTICAL_GRID_GROUPED_NO_COMMA VERTICAL_HANGING_INDENT VERTICAL_HANGING_INDENT_BRACKET VERTICAL_PREFIX_FROM_MODULE_IMPORT name value","title":"Wrap Modes"},{"location":"reference/isort/wrap_modes/#module-isortwrap_modes","text":"Defines all wrap modes that can be used when outputting formatted imports View Source \"\"\"Defines all wrap modes that can be used when outputting formatted imports\"\"\" import enum from inspect import signature from typing import Any , Callable , Dict , List import isort . comments _ wrap_modes: Dict [ str , Callable [[ Any ], str ]] = {} def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value )) def formatter_from_string ( name : str ) : return _ wrap_modes . get ( name . upper (), grid ) def _ wrap_mode_interface ( statement : str , imports : List [ str ], white_space: str , indent : str , line_length: int , comments : List [ str ], line_separator: str , comment_prefix: str , include_trailing_comma: bool , remove_comments: bool , ) -> str : \"\"\"Defines the common interface used by all wrap mode functions\"\"\" return \"\" def _ wrap_mode ( function ) : \"\"\"Registers an individual wrap mode. Function name and order are significant and used for creating enum. \"\"\" _ wrap_modes [ function . __ name__ . upper ()] = function function . __ signature__ = signature ( _ wrap_mode_interface ) function . __ annotations__ = _ wrap_mode_interface . __ annotations__ return function @ _ wrap_mode def grid ( **interface ) : if not interface [ \"imports\" ] : return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ]. pop ( 0 ) while interface [ \"imports\" ] : next_import = interface [ \"imports\" ]. pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ) : lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 : ] : new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ] : lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ]. join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\" @ _ wrap_mode def vertical ( **interface ) : if not interface [ \"imports\" ] : return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ]. pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _ imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]). join ( interface [ \"imports\" ] ) _ comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\" def _ hanging_indent_common ( use_parentheses = False , **interface ) : if not interface [ \"imports\" ] : return \"\" line_length_limit = interface [ \"line_length\" ] - ( 1 if use_parentheses else 3 ) def end_line ( line ) : if use_parentheses: return line if not line . endswith ( \" \" ) : line += \" \" return line + \" \\\\ \" if use_parentheses: interface[\" statement \"] += \" ( \" next_import = interface[\" imports \"].pop(0) next_statement = interface[\" statement \"] + next_import # Check for first import if len(next_statement) > line_length_limit: next_statement = ( isort.comments.add_to_line( interface[\" comments \"], end_line(interface[\" statement \"]), removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = isort.comments.add_to_line( interface[\" comments \"], interface[\" statement \"] + \" , \" + next_import, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) current_line = next_statement.split(interface[\" line_separator \"])[-1] if len(current_line) > line_length_limit: next_statement = ( isort.comments.add_to_line( interface[\" comments \"], end_line(interface[\" statement \"] + \" , \"), removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ interface [ 'indent' ]}{ next_import } \" ) interface[\" comments \"] = [] interface[\" statement \"] = next_statement _comma_maybe = \" , \" if interface[\" include_trailing_comma \"] else \"\" _close_parentheses_maybe = \" ) \" if use_parentheses else \"\" return interface[\" statement \"] + _comma_maybe + _close_parentheses_maybe @_wrap_mode def hanging_indent(**interface): return _hanging_indent_common(use_parentheses=False, **interface) @_wrap_mode def vertical_hanging_indent(**interface): _line_with_comments = isort.comments.add_to_line( interface[\" comments \"], \"\", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) _imports = (\" , \" + interface[\" line_separator \"] + interface[\" indent \"]).join(interface[\" imports \"]) _comma_maybe = \" , \" if interface[\" include_trailing_comma \"] else \"\" return ( f\" { interface [ 'statement' ]}({ _ line_with_comments }{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ _ imports }{ _ comma_maybe }{ interface [ 'line_separator' ]}) \" ) def _vertical_grid_common(need_trailing_char: bool, **interface): if not interface[\" imports \"]: return \"\" interface[\" statement \"] += ( isort.comments.add_to_line( interface[\" comments \"], \" ( \", removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + interface[\" line_separator \"] + interface[\" indent \"] + interface[\" imports \"].pop(0) ) while interface[\" imports \"]: next_import = interface[\" imports \"].pop(0) next_statement = f\" { interface [ 'statement' ]}, { next_import } \" current_line_length = len(next_statement.split(interface[\" line_separator \"])[-1]) if interface[\" imports \"] or interface[\" include_trailing_comma \"]: # We need to account for a comma after this import. current_line_length += 1 if not interface[\" imports \"] and need_trailing_char: # We need to account for a closing ) we're going to add. current_line_length += 1 if current_line_length > interface[\" line_length \"]: next_statement = ( f\" { interface [ 'statement' ]},{ interface [ 'line_separator' ]} \" f\" { interface [ 'indent' ]}{ next_import } \" ) interface[\" statement \"] = next_statement if interface[\" include_trailing_comma \"]: interface[\" statement \"] += \" , \" return interface[\" statement \"] @_wrap_mode def vertical_grid(**interface) -> str: return _vertical_grid_common(need_trailing_char=True, **interface) + \" ) \" @_wrap_mode def vertical_grid_grouped(**interface): return ( _vertical_grid_common(need_trailing_char=False, **interface) + interface[\" line_separator \"] + \" ) \" ) @_wrap_mode def vertical_grid_grouped_no_comma(**interface): # This is a deprecated alias for vertical_grid_grouped above. This function # needs to exist for backwards compatibility but should never get called. raise NotImplementedError @_wrap_mode def noqa(**interface): _imports = \" , \".join(interface[\" imports \"]) retval = f\" { interface [ 'statement' ]}{ _ imports } \" comment_str = \" \".join(interface[\" comments \"]) if interface[\" comments \"]: if ( len(retval) + len(interface[\" comment_prefix \"]) + 1 + len(comment_str) <= interface[\" line_length \"] ): return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" if \" NOQA \" in interface[\" comments \"]: return f\" { retval }{ interface [ 'comment_prefix' ]} { comment_str } \" return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA { comment_str } \" if len(retval) <= interface[\" line_length \"]: return retval return f\" { retval }{ interface [ 'comment_prefix' ]} NOQA \" @_wrap_mode def vertical_hanging_indent_bracket(**interface): if not interface[\" imports \"]: return \"\" statement = vertical_hanging_indent(**interface) return f'{statement[:-1]}{interface[\" indent \"]})' @_wrap_mode def vertical_prefix_from_module_import(**interface): if not interface[\" imports \"]: return \"\" prefix_statement = interface[\" statement \"] output_statement = prefix_statement + interface[\" imports \"].pop(0) comments = interface[\" comments \"] statement = output_statement statement_with_comments = \"\" for next_import in interface[\" imports \"]: statement = statement + \" , \" + next_import statement_with_comments = isort.comments.add_to_line( comments, statement, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) if ( len(statement_with_comments.split(interface[\" line_separator \"])[-1]) + 1 > interface[\" line_length \"] ): statement = ( isort.comments.add_to_line( comments, output_statement, removed=interface[\" remove_comments \"], comment_prefix=interface[\" comment_prefix \"], ) + f\" { interface [ 'line_separator' ]}{ prefix_statement }{ next_import } \" ) comments = [] output_statement = statement if comments and statement_with_comments: output_statement = statement_with_comments return output_statement @_wrap_mode def hanging_indent_with_parentheses(**interface): return _hanging_indent_common(use_parentheses=True, **interface) @_wrap_mode def backslash_grid(**interface): interface[\" indent \"] = interface[\" white_space \"][:-1] return _hanging_indent_common(use_parentheses=False, **interface) WrapModes = enum.Enum( # type: ignore \" WrapModes \" , { wrap_mode: index for index , wrap_mode in enumerate ( _ wrap_modes . keys ())} )","title":"Module isort.wrap_modes"},{"location":"reference/isort/wrap_modes/#functions","text":"","title":"Functions"},{"location":"reference/isort/wrap_modes/#backslash_grid","text":"def backslash_grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @ _ wrap_mode def backslash_grid ( **interface ) : interface [ \"indent\" ] = interface [ \"white_space\" ][:- 1 ] return _ hanging_indent_common ( use_parentheses = False , **interface )","title":"backslash_grid"},{"location":"reference/isort/wrap_modes/#formatter_from_string","text":"def formatter_from_string ( name : str ) View Source def formatter_from_string ( name : str ): return _wrap_modes . get ( name . upper (), grid )","title":"formatter_from_string"},{"location":"reference/isort/wrap_modes/#from_string","text":"def from_string ( value : str ) -> 'WrapModes' View Source def from_string ( value : str ) -> \"WrapModes\" : return getattr ( WrapModes , str ( value ), None ) or WrapModes ( int ( value ))","title":"from_string"},{"location":"reference/isort/wrap_modes/#grid","text":"def grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def grid ( ** interface ): if not interface [ \"imports\" ]: return \"\" interface [ \"statement\" ] += \"(\" + interface [ \"imports\" ] . pop ( 0 ) while interface [ \"imports\" ]: next_import = interface [ \"imports\" ] . pop ( 0 ) next_statement = isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"statement\" ] + \", \" + next_import , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( next_statement . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): lines = [ f \"{interface['white_space']}{next_import.split(' ')[0]}\" ] for part in next_import . split ( \" \" )[ 1 :]: new_line = f \"{lines[-1]} {part}\" if len ( new_line ) + 1 > interface [ \"line_length\" ]: lines . append ( f \"{interface['white_space']}{part}\" ) else : lines [ - 1 ] = new_line next_import = interface [ \"line_separator\" ] . join ( lines ) interface [ \"statement\" ] = ( isort . comments . add_to_line ( interface [ \"comments\" ], f \"{interface['statement']},\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{next_import}\" ) interface [ \"comments\" ] = [] else : interface [ \"statement\" ] += \", \" + next_import return interface [ \"statement\" ] + ( \",\" if interface [ \"include_trailing_comma\" ] else \"\" ) + \")\"","title":"grid"},{"location":"reference/isort/wrap_modes/#hanging_indent","text":"def hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def hanging_indent ( ** interface ) : return _hanging_indent_common ( use_parentheses = False , ** interface )","title":"hanging_indent"},{"location":"reference/isort/wrap_modes/#hanging_indent_with_parentheses","text":"def hanging_indent_with_parentheses ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def hanging_indent_with_parentheses ( ** interface ) : return _hanging_indent_common ( use_parentheses = True , ** interface )","title":"hanging_indent_with_parentheses"},{"location":"reference/isort/wrap_modes/#noqa","text":"def noqa ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def noqa ( ** interface ) : _imports = \", \" . join ( interface [ \"imports\" ] ) retval = f \"{interface['statement']}{_imports}\" comment_str = \" \" . join ( interface [ \"comments\" ] ) if interface [ \"comments\" ] : if ( len ( retval ) + len ( interface [ \"comment_prefix\" ] ) + 1 + len ( comment_str ) <= interface [ \"line_length\" ] ) : return f \"{retval}{interface['comment_prefix']} {comment_str}\" if \"NOQA\" in interface [ \"comments\" ] : return f \"{retval}{interface['comment_prefix']} {comment_str}\" return f \"{retval}{interface['comment_prefix']} NOQA {comment_str}\" if len ( retval ) <= interface [ \"line_length\" ] : return retval return f \"{retval}{interface['comment_prefix']} NOQA\"","title":"noqa"},{"location":"reference/isort/wrap_modes/#vertical","text":"def vertical ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical ( ** interface ): if not interface [ \"imports\" ]: return \"\" first_import = ( isort . comments . add_to_line ( interface [ \"comments\" ], interface [ \"imports\" ] . pop ( 0 ) + \",\" , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + interface [ \"line_separator\" ] + interface [ \"white_space\" ] ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"white_space\" ]) . join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return f \"{interface['statement']}({first_import}{_imports}{_comma_maybe})\"","title":"vertical"},{"location":"reference/isort/wrap_modes/#vertical_grid","text":"def vertical_grid ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid ( ** interface ) -> str : return _vertical_grid_common ( need_trailing_char = True , ** interface ) + \")\"","title":"vertical_grid"},{"location":"reference/isort/wrap_modes/#vertical_grid_grouped","text":"def vertical_grid_grouped ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped ( ** interface ) : return ( _vertical_grid_common ( need_trailing_char = False , ** interface ) + interface [ \"line_separator\" ] + \")\" )","title":"vertical_grid_grouped"},{"location":"reference/isort/wrap_modes/#vertical_grid_grouped_no_comma","text":"def vertical_grid_grouped_no_comma ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_grid_grouped_no_comma ( ** interface ) : # This is a deprecated alias for vertical_grid_grouped above . This function # needs to exist for backwards compatibility but should never get called . raise NotImplementedError","title":"vertical_grid_grouped_no_comma"},{"location":"reference/isort/wrap_modes/#vertical_hanging_indent","text":"def vertical_hanging_indent ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_hanging_indent ( ** interface ) : _line_with_comments = isort . comments . add_to_line ( interface [ \"comments\" ] , \"\" , removed = interface [ \"remove_comments\" ] , comment_prefix = interface [ \"comment_prefix\" ] , ) _imports = ( \",\" + interface [ \"line_separator\" ] + interface [ \"indent\" ] ). join ( interface [ \"imports\" ] ) _comma_maybe = \",\" if interface [ \"include_trailing_comma\" ] else \"\" return ( f \"{interface['statement']}({_line_with_comments}{interface['line_separator']}\" f \"{interface['indent']}{_imports}{_comma_maybe}{interface['line_separator']})\" )","title":"vertical_hanging_indent"},{"location":"reference/isort/wrap_modes/#vertical_hanging_indent_bracket","text":"def vertical_hanging_indent_bracket ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @ _ wrap_mode def vertical_hanging_indent_bracket ( **interface ) : if not interface [ \"imports\" ] : return \"\" statement = vertical_hanging_indent ( **interface ) return f'{statement[:-1]}{interface[\"indent\"]})'","title":"vertical_hanging_indent_bracket"},{"location":"reference/isort/wrap_modes/#vertical_prefix_from_module_import","text":"def vertical_prefix_from_module_import ( statement : str , imports : List [ str ], white_space : str , indent : str , line_length : int , comments : List [ str ], line_separator : str , comment_prefix : str , include_trailing_comma : bool , remove_comments : bool ) -> str View Source @_wrap_mode def vertical_prefix_from_module_import ( ** interface ): if not interface [ \"imports\" ]: return \"\" prefix_statement = interface [ \"statement\" ] output_statement = prefix_statement + interface [ \"imports\" ] . pop ( 0 ) comments = interface [ \"comments\" ] statement = output_statement statement_with_comments = \"\" for next_import in interface [ \"imports\" ]: statement = statement + \", \" + next_import statement_with_comments = isort . comments . add_to_line ( comments , statement , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) if ( len ( statement_with_comments . split ( interface [ \"line_separator\" ])[ - 1 ]) + 1 > interface [ \"line_length\" ] ): statement = ( isort . comments . add_to_line ( comments , output_statement , removed = interface [ \"remove_comments\" ], comment_prefix = interface [ \"comment_prefix\" ], ) + f \"{interface['line_separator']}{prefix_statement}{next_import}\" ) comments = [] output_statement = statement if comments and statement_with_comments : output_statement = statement_with_comments return output_statement","title":"vertical_prefix_from_module_import"},{"location":"reference/isort/wrap_modes/#classes","text":"","title":"Classes"},{"location":"reference/isort/wrap_modes/#wrapmodes","text":"class WrapModes ( / , * args , ** kwargs ) An enumeration.","title":"WrapModes"},{"location":"reference/isort/wrap_modes/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/isort/wrap_modes/#class-variables","text":"BACKSLASH_GRID GRID HANGING_INDENT HANGING_INDENT_WITH_PARENTHESES NOQA VERTICAL VERTICAL_GRID VERTICAL_GRID_GROUPED VERTICAL_GRID_GROUPED_NO_COMMA VERTICAL_HANGING_INDENT VERTICAL_HANGING_INDENT_BRACKET VERTICAL_PREFIX_FROM_MODULE_IMPORT name value","title":"Class variables"},{"location":"reference/isort/deprecated/","text":"Module isort.deprecated Sub-modules isort.deprecated.finders","title":"Index"},{"location":"reference/isort/deprecated/#module-isortdeprecated","text":"","title":"Module isort.deprecated"},{"location":"reference/isort/deprecated/#sub-modules","text":"isort.deprecated.finders","title":"Sub-modules"},{"location":"reference/isort/deprecated/finders/","text":"Module isort.deprecated.finders Finders try to find right section for passed module name View Source \"\"\"Finders try to find right section for passed module name\"\"\" import importlib . machinery import inspect import os import os . path import re import sys import sysconfig from abc import ABCMeta , abstractmethod from contextlib import contextmanager from fnmatch import fnmatch from functools import lru_cache from glob import glob from pathlib import Path from typing import Dict , Iterable , Iterator , List , Optional , Pattern , Sequence , Tuple , Type from isort import sections from isort . settings import KNOWN_SECTION_MAPPING , Config from isort . utils import exists_case_sensitive try : from pipreqs import pipreqs except ImportError : pipreqs = None try : from pip_api import parse_requirements except ImportError : parse_requirements = None try : from requirementslib import Pipfile except ImportError : Pipfile = None @contextmanager def chdir ( path : str ) -> Iterator [ None ] : \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir ) class BaseFinder ( metaclass = ABCMeta ) : def __ init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name: str ) -> Optional [ str ] : raise NotImplementedError class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate: # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None class LocalFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None class KnownPatternFinder ( BaseFinder ) : def __ init__ ( self , config : Config ) -> None : super (). __ init__ ( config ) self . known_patterns: List [ Tuple [ Pattern [ str ], str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [])) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self . _ parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns: regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) def _ parse_known_pattern ( self , pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os . listdir ( os . path . join ( self . config . directory , pattern )) if os . path . isdir ( os . path . join ( self . config . directory , pattern , filename )) ] else : patterns = [ pattern ] return patterns def find ( self , module_name: str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check: for pattern , placement in self . known_patterns: if pattern . match ( module_name_to_check ) : return placement return None class PathFinder ( BaseFinder ) : def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) # restore the original import path ( i . e . not the path to bin / isort ) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env: self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env: self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ) : if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ) : if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ) : if os . path . isdir ( venv_src_path ) : self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env: self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ) : if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ) : if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case - insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 : ] : if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name: str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package: if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY if os . path . normcase ( prefix ) == self . stdlib_lib_prefix: return sections . STDLIB if self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths: if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _ get_files_from_dir_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements*/*. { txt , in } if os . path . isdir ( full_path ) : for subfile_name in os . listdir ( full_path ) : for ext in cls . exts : if subfile_name . endswith ( ext ) : results . append ( os . path . join ( full_path , subfile_name )) continue # * requirements*. { txt , in } if os . path . isfile ( full_path ) : for ext in cls . exts : if fname . endswith ( ext ) : results . append ( full_path ) break return results def _ get_names ( self , path : str ) -> Iterator [ str ] : \"\"\"Load required packages from path to requirements file\"\"\" yield from self . _ get_names_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_names_cached ( cls , path : str ) -> List [ str ] : result = [] with chdir ( os . path . dirname ( path )) : requirements = parse_requirements ( path ) for req in requirements . values () : if req . name : result . append ( req . name ) return result class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _ get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path class DefaultFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : return self . config . default_section class FindersManager : _ default_finders_classes: Sequence [ Type [ BaseFinder ]] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __ init__ ( self , config : Config , finder_classes: Optional [ Iterable [ Type [ BaseFinder ]]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _ default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes: try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder , ...] = tuple ( finders ) def find ( self , module_name: str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None Variables KNOWN_SECTION_MAPPING Functions chdir def chdir ( path : str ) -> Iterator [ NoneType ] Context manager for changing dir and restoring previous workdir after exit. View Source @contextmanager def chdir ( path : str ) -> Iterator [ None ] : \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir ) Classes BaseFinder class BaseFinder ( config : isort . settings . Config ) View Source class BaseFinder ( metaclass = ABCMeta ) : def __init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError Descendants isort.deprecated.finders.ForcedSeparateFinder isort.deprecated.finders.LocalFinder isort.deprecated.finders.KnownPatternFinder isort.deprecated.finders.PathFinder isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.DefaultFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError DefaultFinder class DefaultFinder ( config : isort . settings . Config ) View Source class DefaultFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section FindersManager class FindersManager ( config : isort . settings . Config , finder_classes : Union [ Iterable [ Type [ isort . deprecated . finders . BaseFinder ]], NoneType ] = None ) View Source class FindersManager : _default_finders_classes : Sequence [ Type[BaseFinder ] ] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __init__ ( self , config : Config , finder_classes : Optional [ Iterable[Type[BaseFinder ] ]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes : try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder, ... ] = tuple ( finders ) def find ( self , module_name : str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ]: for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None ForcedSeparateFinder class ForcedSeparateFinder ( config : isort . settings . Config ) View Source class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None KnownPatternFinder class KnownPatternFinder ( config : isort . settings . Config ) View Source class KnownPatternFinder ( BaseFinder ) : def __init__ ( self , config : Config ) -> None : super (). __init__ ( config ) self . known_patterns : List [ Tuple[Pattern[str ] , str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [] )) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self._parse_known_pattern(known_pattern) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) def _parse_known_pattern ( self , pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os.listdir(os.path.join(self.config.directory, pattern)) if os.path.isdir(os.path.join(self.config.directory, pattern, filename)) ] else : patterns = [ pattern ] return patterns def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None LocalFinder class LocalFinder ( config : isort . settings . Config ) View Source class LocalFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None PathFinder class PathFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PathFinder ( BaseFinder ): def __init__ ( self , config : Config , path : str = \".\" ) -> None : super () . __init__ ( config ) # restore the original import path (i.e. not the path to bin/isort) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env : self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env : self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ): if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ): if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ): if os . path . isdir ( venv_src_path ): self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env : self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ): if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ): if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case-insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 :]: if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name : str ) -> Optional [ str ]: for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ) . resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ): return sections . THIRDPARTY if os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB if self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ): return sections . FIRSTPARTY if os . path . normcase ( prefix ) . startswith ( self . stdlib_lib_prefix ): return sections . STDLIB # pragma: no cover - edge case for one OS. Hard to test. return self . config . default_section return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" ) [ 0 ] )) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY if os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB if self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None PipfileFinder class PipfileFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path Ancestors (in MRO) isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder Class variables enabled Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None ReqsBaseFinder class ReqsBaseFinder ( config : isort . settings . Config , path : str = '.' ) View Source class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None Ancestors (in MRO) isort.deprecated.finders.BaseFinder Descendants isort.deprecated.finders.RequirementsFinder isort.deprecated.finders.PipfileFinder Class variables enabled Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None RequirementsFinder class RequirementsFinder ( config : isort . settings . Config , path : str = '.' ) View Source class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _get_files_from_dir_cached ( path ) @classmethod @lru_cache ( maxsize = 16 ) def _get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements * /*.{txt,in} if os.path.isdir(full_path): for subfile_name in os.listdir(full_path): for ext in cls.exts: if subfile_name.endswith(ext): results.append(os.path.join(full_path, subfile_name)) continue # *requirements*.{txt,in} if os.path.isfile(full_path): for ext in cls.exts: if fname.endswith(ext): results.append(full_path) break return results def _get_names(self, path: str) -> Iterator[str]: \"\"\"Load required packages from path to requirements file\"\"\" yield from self._get_names_cached(path) @classmethod @lru_cache(maxsize=16) def _get_names_cached(cls, path: str) -> List[str]: result = [] with chdir(os.path.dirname(path)): requirements = parse_requirements(path) for req in requirements.values(): if req.name: result.append(req.name) return result Ancestors (in MRO) isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder Class variables enabled exts Methods find def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"Finders"},{"location":"reference/isort/deprecated/finders/#module-isortdeprecatedfinders","text":"Finders try to find right section for passed module name View Source \"\"\"Finders try to find right section for passed module name\"\"\" import importlib . machinery import inspect import os import os . path import re import sys import sysconfig from abc import ABCMeta , abstractmethod from contextlib import contextmanager from fnmatch import fnmatch from functools import lru_cache from glob import glob from pathlib import Path from typing import Dict , Iterable , Iterator , List , Optional , Pattern , Sequence , Tuple , Type from isort import sections from isort . settings import KNOWN_SECTION_MAPPING , Config from isort . utils import exists_case_sensitive try : from pipreqs import pipreqs except ImportError : pipreqs = None try : from pip_api import parse_requirements except ImportError : parse_requirements = None try : from requirementslib import Pipfile except ImportError : Pipfile = None @contextmanager def chdir ( path : str ) -> Iterator [ None ] : \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir ) class BaseFinder ( metaclass = ABCMeta ) : def __ init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name: str ) -> Optional [ str ] : raise NotImplementedError class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate: # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None class LocalFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None class KnownPatternFinder ( BaseFinder ) : def __ init__ ( self , config : Config ) -> None : super (). __ init__ ( config ) self . known_patterns: List [ Tuple [ Pattern [ str ], str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [])) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self . _ parse_known_pattern ( known_pattern ) ] for known_pattern in known_patterns: regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) def _ parse_known_pattern ( self , pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os . listdir ( os . path . join ( self . config . directory , pattern )) if os . path . isdir ( os . path . join ( self . config . directory , pattern , filename )) ] else : patterns = [ pattern ] return patterns def find ( self , module_name: str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ]) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check: for pattern , placement in self . known_patterns: if pattern . match ( module_name_to_check ) : return placement return None class PathFinder ( BaseFinder ) : def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) # restore the original import path ( i . e . not the path to bin / isort ) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env: self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env: self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ) : if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ) : if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ) : if os . path . isdir ( venv_src_path ) : self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env: self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ) : if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ) : if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case - insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 : ] : if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name: str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package: if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY if os . path . normcase ( prefix ) == self . stdlib_lib_prefix: return sections . STDLIB if self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths: if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _ get_files_from_dir_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements*/*. { txt , in } if os . path . isdir ( full_path ) : for subfile_name in os . listdir ( full_path ) : for ext in cls . exts : if subfile_name . endswith ( ext ) : results . append ( os . path . join ( full_path , subfile_name )) continue # * requirements*. { txt , in } if os . path . isfile ( full_path ) : for ext in cls . exts : if fname . endswith ( ext ) : results . append ( full_path ) break return results def _ get_names ( self , path : str ) -> Iterator [ str ] : \"\"\"Load required packages from path to requirements file\"\"\" yield from self . _ get_names_cached ( path ) @classmethod @ lru_cache ( maxsize = 16 ) def _ get_names_cached ( cls , path : str ) -> List [ str ] : result = [] with chdir ( os . path . dirname ( path )) : requirements = parse_requirements ( path ) for req in requirements . values () : if req . name : result . append ( req . name ) return result class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _ get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path class DefaultFinder ( BaseFinder ) : def find ( self , module_name: str ) -> Optional [ str ] : return self . config . default_section class FindersManager : _ default_finders_classes: Sequence [ Type [ BaseFinder ]] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __ init__ ( self , config : Config , finder_classes: Optional [ Iterable [ Type [ BaseFinder ]]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _ default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes: try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder , ...] = tuple ( finders ) def find ( self , module_name: str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None","title":"Module isort.deprecated.finders"},{"location":"reference/isort/deprecated/finders/#variables","text":"KNOWN_SECTION_MAPPING","title":"Variables"},{"location":"reference/isort/deprecated/finders/#functions","text":"","title":"Functions"},{"location":"reference/isort/deprecated/finders/#chdir","text":"def chdir ( path : str ) -> Iterator [ NoneType ] Context manager for changing dir and restoring previous workdir after exit. View Source @contextmanager def chdir ( path : str ) -> Iterator [ None ] : \"\"\"Context manager for changing dir and restoring previous workdir after exit.\"\"\" curdir = os . getcwd () os . chdir ( path ) try : yield finally : os . chdir ( curdir )","title":"chdir"},{"location":"reference/isort/deprecated/finders/#classes","text":"","title":"Classes"},{"location":"reference/isort/deprecated/finders/#basefinder","text":"class BaseFinder ( config : isort . settings . Config ) View Source class BaseFinder ( metaclass = ABCMeta ) : def __init__ ( self , config : Config ) -> None : self . config = config @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError","title":"BaseFinder"},{"location":"reference/isort/deprecated/finders/#descendants","text":"isort.deprecated.finders.ForcedSeparateFinder isort.deprecated.finders.LocalFinder isort.deprecated.finders.KnownPatternFinder isort.deprecated.finders.PathFinder isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.DefaultFinder","title":"Descendants"},{"location":"reference/isort/deprecated/finders/#methods","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source @abstractmethod def find ( self , module_name : str ) -> Optional [ str ] : raise NotImplementedError","title":"find"},{"location":"reference/isort/deprecated/finders/#defaultfinder","text":"class DefaultFinder ( config : isort . settings . Config ) View Source class DefaultFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section","title":"DefaultFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_1","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_1","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : return self . config . default_section","title":"find"},{"location":"reference/isort/deprecated/finders/#findersmanager","text":"class FindersManager ( config : isort . settings . Config , finder_classes : Union [ Iterable [ Type [ isort . deprecated . finders . BaseFinder ]], NoneType ] = None ) View Source class FindersManager : _default_finders_classes : Sequence [ Type[BaseFinder ] ] = ( ForcedSeparateFinder , LocalFinder , KnownPatternFinder , PathFinder , PipfileFinder , RequirementsFinder , DefaultFinder , ) def __init__ ( self , config : Config , finder_classes : Optional [ Iterable[Type[BaseFinder ] ]] = None ) -> None : self . verbose : bool = config . verbose if finder_classes is None : finder_classes = self . _default_finders_classes finders : List [ BaseFinder ] = [] for finder_cls in finder_classes : try : finders . append ( finder_cls ( config )) except Exception as exception : # if one finder fails to instantiate isort can continue using the rest if self . verbose : print ( ( f \"{finder_cls.__name__} encountered an error ({exception}) during \" \"instantiation and cannot be used\" ) ) self . finders : Tuple [ BaseFinder, ... ] = tuple ( finders ) def find ( self , module_name : str ) -> Optional [ str ] : for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None","title":"FindersManager"},{"location":"reference/isort/deprecated/finders/#methods_2","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_2","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ]: for finder in self . finders : try : section = finder . find ( module_name ) if section is not None : return section except Exception as exception : # isort has to be able to keep trying to identify the correct # import section even if one approach fails if self . verbose : print ( f \"{finder.__class__.__name__} encountered an error ({exception}) while \" f \"trying to identify the {module_name} module\" ) return None","title":"find"},{"location":"reference/isort/deprecated/finders/#forcedseparatefinder","text":"class ForcedSeparateFinder ( config : isort . settings . Config ) View Source class ForcedSeparateFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None","title":"ForcedSeparateFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_1","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_3","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_3","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for forced_separate in self . config . forced_separate : # Ensure all forced_separate patterns will match to end of string path_glob = forced_separate if not forced_separate . endswith ( \"*\" ) : path_glob = \"%s*\" % forced_separate if fnmatch ( module_name , path_glob ) or fnmatch ( module_name , \".\" + path_glob ) : return forced_separate return None","title":"find"},{"location":"reference/isort/deprecated/finders/#knownpatternfinder","text":"class KnownPatternFinder ( config : isort . settings . Config ) View Source class KnownPatternFinder ( BaseFinder ) : def __init__ ( self , config : Config ) -> None : super (). __init__ ( config ) self . known_patterns : List [ Tuple[Pattern[str ] , str ]] = [] for placement in reversed ( config . sections ) : known_placement = KNOWN_SECTION_MAPPING . get ( placement , placement ). lower () config_key = f \"known_{known_placement}\" known_patterns = list ( getattr ( self . config , config_key , self . config . known_other . get ( known_placement , [] )) ) known_patterns = [ pattern for known_pattern in known_patterns for pattern in self._parse_known_pattern(known_pattern) ] for known_pattern in known_patterns : regexp = \"^\" + known_pattern . replace ( \"*\" , \".*\" ). replace ( \"?\" , \".?\" ) + \"$\" self . known_patterns . append (( re . compile ( regexp ), placement )) def _parse_known_pattern ( self , pattern : str ) -> List [ str ] : \"\"\"Expand pattern if identified as a directory and return found sub packages\"\"\" if pattern . endswith ( os . path . sep ) : patterns = [ filename for filename in os.listdir(os.path.join(self.config.directory, pattern)) if os.path.isdir(os.path.join(self.config.directory, pattern, filename)) ] else : patterns = [ pattern ] return patterns def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None","title":"KnownPatternFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_2","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_4","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_4","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # Try to find most specific placement instruction match ( if any ) parts = module_name . split ( \".\" ) module_names_to_check = ( \".\" . join ( parts [ :first_k ] ) for first_k in range ( len ( parts ), 0 , - 1 )) for module_name_to_check in module_names_to_check : for pattern , placement in self . known_patterns : if pattern . match ( module_name_to_check ) : return placement return None","title":"find"},{"location":"reference/isort/deprecated/finders/#localfinder","text":"class LocalFinder ( config : isort . settings . Config ) View Source class LocalFinder ( BaseFinder ) : def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None","title":"LocalFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_3","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_5","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_5","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : if module_name . startswith ( \".\" ) : return \"LOCALFOLDER\" return None","title":"find"},{"location":"reference/isort/deprecated/finders/#pathfinder","text":"class PathFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PathFinder ( BaseFinder ): def __init__ ( self , config : Config , path : str = \".\" ) -> None : super () . __init__ ( config ) # restore the original import path (i.e. not the path to bin/isort) root_dir = os . path . abspath ( path ) src_dir = f \"{root_dir}/src\" self . paths = [ root_dir , src_dir ] # virtual env self . virtual_env = self . config . virtual_env or os . environ . get ( \"VIRTUAL_ENV\" ) if self . virtual_env : self . virtual_env = os . path . realpath ( self . virtual_env ) self . virtual_env_src = \"\" if self . virtual_env : self . virtual_env_src = f \"{self.virtual_env}/src/\" for venv_path in glob ( f \"{self.virtual_env}/lib/python*/site-packages\" ): if venv_path not in self . paths : self . paths . append ( venv_path ) for nested_venv_path in glob ( f \"{self.virtual_env}/lib/python*/*/site-packages\" ): if nested_venv_path not in self . paths : self . paths . append ( nested_venv_path ) for venv_src_path in glob ( f \"{self.virtual_env}/src/*\" ): if os . path . isdir ( venv_src_path ): self . paths . append ( venv_src_path ) # conda self . conda_env = self . config . conda_env or os . environ . get ( \"CONDA_PREFIX\" ) or \"\" if self . conda_env : self . conda_env = os . path . realpath ( self . conda_env ) for conda_path in glob ( f \"{self.conda_env}/lib/python*/site-packages\" ): if conda_path not in self . paths : self . paths . append ( conda_path ) for nested_conda_path in glob ( f \"{self.conda_env}/lib/python*/*/site-packages\" ): if nested_conda_path not in self . paths : self . paths . append ( nested_conda_path ) # handle case-insensitive paths on windows self . stdlib_lib_prefix = os . path . normcase ( sysconfig . get_paths ()[ \"stdlib\" ]) if self . stdlib_lib_prefix not in self . paths : self . paths . append ( self . stdlib_lib_prefix ) # add system paths for system_path in sys . path [ 1 :]: if system_path not in self . paths : self . paths . append ( system_path ) def find ( self , module_name : str ) -> Optional [ str ]: for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" )[ 0 ])) path_obj = Path ( package_path ) . resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ): return sections . THIRDPARTY if os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB if self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ): return sections . FIRSTPARTY if os . path . normcase ( prefix ) . startswith ( self . stdlib_lib_prefix ): return sections . STDLIB # pragma: no cover - edge case for one OS. Hard to test. return self . config . default_section return None","title":"PathFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_4","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#methods_6","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_6","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : for prefix in self . paths : package_path = \"/\" . join (( prefix , module_name . split ( \".\" ) [ 0 ] )) path_obj = Path ( package_path ). resolve () is_module = ( exists_case_sensitive ( package_path + \".py\" ) or any ( exists_case_sensitive ( package_path + ext_suffix ) for ext_suffix in importlib . machinery . EXTENSION_SUFFIXES ) or exists_case_sensitive ( package_path + \"/__init__.py\" ) ) is_package = exists_case_sensitive ( package_path ) and os . path . isdir ( package_path ) if is_module or is_package : if ( \"site-packages\" in prefix or \"dist-packages\" in prefix or ( self . virtual_env and self . virtual_env_src in prefix ) ) : return sections . THIRDPARTY if os . path . normcase ( prefix ) == self . stdlib_lib_prefix : return sections . STDLIB if self . conda_env and self . conda_env in prefix : return sections . THIRDPARTY for src_path in self . config . src_paths : if src_path in path_obj . parents and not self . config . is_skipped ( path_obj ) : return sections . FIRSTPARTY if os . path . normcase ( prefix ). startswith ( self . stdlib_lib_prefix ) : return sections . STDLIB # pragma : no cover - edge case for one OS . Hard to test . return self . config . default_section return None","title":"find"},{"location":"reference/isort/deprecated/finders/#pipfilefinder","text":"class PipfileFinder ( config : isort . settings . Config , path : str = '.' ) View Source class PipfileFinder ( ReqsBaseFinder ) : enabled = bool ( Pipfile ) def _get_names ( self , path : str ) -> Iterator [ str ] : with chdir ( path ) : project = Pipfile . load ( path ) for req in project . packages : yield req . name def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : if \"Pipfile\" in os . listdir ( path ) : yield path","title":"PipfileFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_5","text":"isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#class-variables","text":"enabled","title":"Class variables"},{"location":"reference/isort/deprecated/finders/#methods_7","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_7","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"find"},{"location":"reference/isort/deprecated/finders/#reqsbasefinder","text":"class ReqsBaseFinder ( config : isort . settings . Config , path : str = '.' ) View Source class ReqsBaseFinder ( BaseFinder ) : enabled = False def __ init__ ( self , config : Config , path : str = \".\" ) -> None : super (). __ init__ ( config ) self . path = path if self . enabled : self . mapping = self . _ load_mapping () self . names = self . _ load_names () @abstractmethod def _ get_names ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @abstractmethod def _ get_files_from_dir ( self , path : str ) -> Iterator [ str ] : raise NotImplementedError @staticmethod def _ load_mapping () -> Optional [ Dict [ str , str ]] : \"\"\"Return list of mappings `package_name -> module_name` Example: django-haystack -> haystack \"\"\" if not pipreqs : return None path = os . path . dirname ( inspect . getfile ( pipreqs )) path = os . path . join ( path , \"mapping\" ) with open ( path ) as f : mappings : Dict [ str , str ] = {} # pypi_name: import_name for line in f : import_name , _ , pypi_name = line . strip (). partition ( \":\" ) mappings [ pypi_name ] = import_name return mappings # return dict ( tuple ( line . strip (). split ( \":\" )[ ::- 1 ]) for line in f ) def _ load_names ( self ) -> List [ str ] : \"\"\"Return list of thirdparty modules from requirements\"\"\" names = [] for path in self . _ get_files () : for name in self . _ get_names ( path ) : names . append ( self . _ normalize_name ( name )) return names @staticmethod def _ get_parents ( path : str ) -> Iterator [ str ] : prev = \"\" while path ! = prev : prev = path yield path path = os . path . dirname ( path ) def _ get_files ( self ) -> Iterator [ str ] : \"\"\"Return paths to all requirements files\"\"\" path = os . path . abspath ( self . path ) if os . path . isfile ( path ) : path = os . path . dirname ( path ) for path in self . _ get_parents ( path ) : yield from self . _ get_files_from_dir ( path ) def _ normalize_name ( self , name : str ) -> str : \"\"\"Convert package name to module name Examples: Django -> django django-haystack -> django_haystack Flask-RESTFul -> flask_restful \"\"\" if self . mapping : name = self . mapping . get ( name . replace ( \"-\" , \"_\" ), name ) return name . lower (). replace ( \"-\" , \"_\" ) def find ( self , module_name: str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _ sep , _ submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name: return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"ReqsBaseFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_6","text":"isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#descendants_1","text":"isort.deprecated.finders.RequirementsFinder isort.deprecated.finders.PipfileFinder","title":"Descendants"},{"location":"reference/isort/deprecated/finders/#class-variables_1","text":"enabled","title":"Class variables"},{"location":"reference/isort/deprecated/finders/#methods_8","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_8","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"find"},{"location":"reference/isort/deprecated/finders/#requirementsfinder","text":"class RequirementsFinder ( config : isort . settings . Config , path : str = '.' ) View Source class RequirementsFinder ( ReqsBaseFinder ) : exts = ( \".txt\" , \".in\" ) enabled = bool ( parse_requirements ) def _get_files_from_dir ( self , path : str ) -> Iterator [ str ] : \"\"\"Return paths to requirements files from passed dir.\"\"\" yield from self . _get_files_from_dir_cached ( path ) @classmethod @lru_cache ( maxsize = 16 ) def _get_files_from_dir_cached ( cls , path : str ) -> List [ str ] : results = [] for fname in os . listdir ( path ) : if \"requirements\" not in fname : continue full_path = os . path . join ( path , fname ) # * requirements * /*.{txt,in} if os.path.isdir(full_path): for subfile_name in os.listdir(full_path): for ext in cls.exts: if subfile_name.endswith(ext): results.append(os.path.join(full_path, subfile_name)) continue # *requirements*.{txt,in} if os.path.isfile(full_path): for ext in cls.exts: if fname.endswith(ext): results.append(full_path) break return results def _get_names(self, path: str) -> Iterator[str]: \"\"\"Load required packages from path to requirements file\"\"\" yield from self._get_names_cached(path) @classmethod @lru_cache(maxsize=16) def _get_names_cached(cls, path: str) -> List[str]: result = [] with chdir(os.path.dirname(path)): requirements = parse_requirements(path) for req in requirements.values(): if req.name: result.append(req.name) return result","title":"RequirementsFinder"},{"location":"reference/isort/deprecated/finders/#ancestors-in-mro_7","text":"isort.deprecated.finders.ReqsBaseFinder isort.deprecated.finders.BaseFinder","title":"Ancestors (in MRO)"},{"location":"reference/isort/deprecated/finders/#class-variables_2","text":"enabled exts","title":"Class variables"},{"location":"reference/isort/deprecated/finders/#methods_9","text":"","title":"Methods"},{"location":"reference/isort/deprecated/finders/#find_9","text":"def find ( self , module_name : str ) -> Union [ str , NoneType ] View Source def find ( self , module_name : str ) -> Optional [ str ] : # required lib not installed yet if not self . enabled : return None module_name , _sep , _submodules = module_name . partition ( \".\" ) module_name = module_name . lower () if not module_name : return None for name in self . names : if module_name == name : return sections . THIRDPARTY return None","title":"find"},{"location":"reference/isort/stdlibs/","text":"Module isort.stdlibs View Source from . import all as _all from . import py2 , py3 , py27 , py35 , py36 , py37 , py38 , py39 Sub-modules isort.stdlibs.all isort.stdlibs.py2 isort.stdlibs.py27 isort.stdlibs.py3 isort.stdlibs.py35 isort.stdlibs.py36 isort.stdlibs.py37 isort.stdlibs.py38 isort.stdlibs.py39","title":"Index"},{"location":"reference/isort/stdlibs/#module-isortstdlibs","text":"View Source from . import all as _all from . import py2 , py3 , py27 , py35 , py36 , py37 , py38 , py39","title":"Module isort.stdlibs"},{"location":"reference/isort/stdlibs/#sub-modules","text":"isort.stdlibs.all isort.stdlibs.py2 isort.stdlibs.py27 isort.stdlibs.py3 isort.stdlibs.py35 isort.stdlibs.py36 isort.stdlibs.py37 isort.stdlibs.py38 isort.stdlibs.py39","title":"Sub-modules"},{"location":"reference/isort/stdlibs/all/","text":"Module isort.stdlibs.all View Source from . import py2 , py3 stdlib = py2 . stdlib | py3 . stdlib Variables stdlib","title":"All"},{"location":"reference/isort/stdlibs/all/#module-isortstdlibsall","text":"View Source from . import py2 , py3 stdlib = py2 . stdlib | py3 . stdlib","title":"Module isort.stdlibs.all"},{"location":"reference/isort/stdlibs/all/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py2/","text":"Module isort.stdlibs.py2 View Source from . import py27 stdlib = py27 . stdlib Variables stdlib","title":"Py2"},{"location":"reference/isort/stdlibs/py2/#module-isortstdlibspy2","text":"View Source from . import py27 stdlib = py27 . stdlib","title":"Module isort.stdlibs.py2"},{"location":"reference/isort/stdlibs/py2/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py27/","text":"Module isort.stdlibs.py27 File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"AL\" , \"BaseHTTPServer\" , \"Bastion\" , \"CGIHTTPServer\" , \"Carbon\" , \"ColorPicker\" , \"ConfigParser\" , \"Cookie\" , \"DEVICE\" , \"DocXMLRPCServer\" , \"EasyDialogs\" , \"FL\" , \"FrameWork\" , \"GL\" , \"HTMLParser\" , \"MacOS\" , \"MimeWriter\" , \"MiniAEFrame\" , \"Nav\" , \"PixMapWrapper\" , \"Queue\" , \"SUNAUDIODEV\" , \"ScrolledText\" , \"SimpleHTTPServer\" , \"SimpleXMLRPCServer\" , \"SocketServer\" , \"StringIO\" , \"Tix\" , \"Tkinter\" , \"UserDict\" , \"UserList\" , \"UserString\" , \"W\" , \"__builtin__\" , \"_winreg\" , \"abc\" , \"aepack\" , \"aetools\" , \"aetypes\" , \"aifc\" , \"al\" , \"anydbm\" , \"applesingle\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"autoGIL\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"bsddb\" , \"buildtools\" , \"bz2\" , \"cPickle\" , \"cProfile\" , \"cStringIO\" , \"calendar\" , \"cd\" , \"cfmfile\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"commands\" , \"compileall\" , \"compiler\" , \"contextlib\" , \"cookielib\" , \"copy\" , \"copy_reg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbhash\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dircache\" , \"dis\" , \"distutils\" , \"dl\" , \"doctest\" , \"dumbdbm\" , \"dummy_thread\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"errno\" , \"exceptions\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"findertools\" , \"fl\" , \"flp\" , \"fm\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fpformat\" , \"fractions\" , \"ftplib\" , \"functools\" , \"future_builtins\" , \"gc\" , \"gdbm\" , \"gensuitemodule\" , \"getopt\" , \"getpass\" , \"gettext\" , \"gl\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"hotshot\" , \"htmlentitydefs\" , \"htmllib\" , \"httplib\" , \"ic\" , \"icopen\" , \"imageop\" , \"imaplib\" , \"imgfile\" , \"imghdr\" , \"imp\" , \"importlib\" , \"imputil\" , \"inspect\" , \"io\" , \"itertools\" , \"jpeg\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"macerrors\" , \"macostools\" , \"macpath\" , \"macresource\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"md5\" , \"mhlib\" , \"mimetools\" , \"mimetypes\" , \"mimify\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multifile\" , \"multiprocessing\" , \"mutex\" , \"netrc\" , \"new\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"popen2\" , \"poplib\" , \"posix\" , \"posixfile\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"resource\" , \"rexec\" , \"rfc822\" , \"rlcompleter\" , \"robotparser\" , \"runpy\" , \"sched\" , \"select\" , \"sets\" , \"sgmllib\" , \"sha\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statvfs\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"sunaudiodev\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"thread\" , \"threading\" , \"time\" , \"timeit\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"ttk\" , \"tty\" , \"turtle\" , \"types\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"urllib2\" , \"urlparse\" , \"user\" , \"uu\" , \"uuid\" , \"videoreader\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"whichdb\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpclib\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py27"},{"location":"reference/isort/stdlibs/py27/#module-isortstdlibspy27","text":"File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 2.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"AL\" , \"BaseHTTPServer\" , \"Bastion\" , \"CGIHTTPServer\" , \"Carbon\" , \"ColorPicker\" , \"ConfigParser\" , \"Cookie\" , \"DEVICE\" , \"DocXMLRPCServer\" , \"EasyDialogs\" , \"FL\" , \"FrameWork\" , \"GL\" , \"HTMLParser\" , \"MacOS\" , \"MimeWriter\" , \"MiniAEFrame\" , \"Nav\" , \"PixMapWrapper\" , \"Queue\" , \"SUNAUDIODEV\" , \"ScrolledText\" , \"SimpleHTTPServer\" , \"SimpleXMLRPCServer\" , \"SocketServer\" , \"StringIO\" , \"Tix\" , \"Tkinter\" , \"UserDict\" , \"UserList\" , \"UserString\" , \"W\" , \"__builtin__\" , \"_winreg\" , \"abc\" , \"aepack\" , \"aetools\" , \"aetypes\" , \"aifc\" , \"al\" , \"anydbm\" , \"applesingle\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"autoGIL\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"bsddb\" , \"buildtools\" , \"bz2\" , \"cPickle\" , \"cProfile\" , \"cStringIO\" , \"calendar\" , \"cd\" , \"cfmfile\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"commands\" , \"compileall\" , \"compiler\" , \"contextlib\" , \"cookielib\" , \"copy\" , \"copy_reg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbhash\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dircache\" , \"dis\" , \"distutils\" , \"dl\" , \"doctest\" , \"dumbdbm\" , \"dummy_thread\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"errno\" , \"exceptions\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"findertools\" , \"fl\" , \"flp\" , \"fm\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fpformat\" , \"fractions\" , \"ftplib\" , \"functools\" , \"future_builtins\" , \"gc\" , \"gdbm\" , \"gensuitemodule\" , \"getopt\" , \"getpass\" , \"gettext\" , \"gl\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"hotshot\" , \"htmlentitydefs\" , \"htmllib\" , \"httplib\" , \"ic\" , \"icopen\" , \"imageop\" , \"imaplib\" , \"imgfile\" , \"imghdr\" , \"imp\" , \"importlib\" , \"imputil\" , \"inspect\" , \"io\" , \"itertools\" , \"jpeg\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"macerrors\" , \"macostools\" , \"macpath\" , \"macresource\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"md5\" , \"mhlib\" , \"mimetools\" , \"mimetypes\" , \"mimify\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multifile\" , \"multiprocessing\" , \"mutex\" , \"netrc\" , \"new\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"popen2\" , \"poplib\" , \"posix\" , \"posixfile\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"resource\" , \"rexec\" , \"rfc822\" , \"rlcompleter\" , \"robotparser\" , \"runpy\" , \"sched\" , \"select\" , \"sets\" , \"sgmllib\" , \"sha\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statvfs\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"sunaudiodev\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"thread\" , \"threading\" , \"time\" , \"timeit\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"ttk\" , \"tty\" , \"turtle\" , \"types\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"urllib2\" , \"urlparse\" , \"user\" , \"uu\" , \"uuid\" , \"videoreader\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"whichdb\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpclib\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py27"},{"location":"reference/isort/stdlibs/py27/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py3/","text":"Module isort.stdlibs.py3 View Source from . import py35 , py36 , py37 , py38 , py39 stdlib = py35 . stdlib | py36 . stdlib | py37 . stdlib | py38 . stdlib | py39 . stdlib Variables stdlib","title":"Py3"},{"location":"reference/isort/stdlibs/py3/#module-isortstdlibspy3","text":"View Source from . import py35 , py36 , py37 , py38 , py39 stdlib = py35 . stdlib | py36 . stdlib | py37 . stdlib | py38 . stdlib | py39 . stdlib","title":"Module isort.stdlibs.py3"},{"location":"reference/isort/stdlibs/py3/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py35/","text":"Module isort.stdlibs.py35 File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py35"},{"location":"reference/isort/stdlibs/py35/#module-isortstdlibspy35","text":"File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.5. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py35"},{"location":"reference/isort/stdlibs/py35/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py36/","text":"Module isort.stdlibs.py36 File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py36"},{"location":"reference/isort/stdlibs/py36/#module-isortstdlibspy36","text":"File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.6. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fpectl\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py36"},{"location":"reference/isort/stdlibs/py36/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py37/","text":"Module isort.stdlibs.py37 File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py37"},{"location":"reference/isort/stdlibs/py37/#module-isortstdlibspy37","text":"File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.7. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"macpath\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py37"},{"location":"reference/isort/stdlibs/py37/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py38/","text":"Module isort.stdlibs.py38 File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , } Variables stdlib","title":"Py38"},{"location":"reference/isort/stdlibs/py38/#module-isortstdlibspy38","text":"File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.8. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_dummy_thread\" , \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"dummy_threading\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , }","title":"Module isort.stdlibs.py38"},{"location":"reference/isort/stdlibs/py38/#variables","text":"stdlib","title":"Variables"},{"location":"reference/isort/stdlibs/py39/","text":"Module isort.stdlibs.py39 File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"graphlib\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , \"zoneinfo\" , } Variables stdlib","title":"Py39"},{"location":"reference/isort/stdlibs/py39/#module-isortstdlibspy39","text":"File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. View Source \"\"\" File contains the standard library of Python 3.9. DO NOT EDIT. If the standard library changes, a new list should be created using the mkstdlibs.py script. \"\"\" stdlib = { \"_thread\" , \"abc\" , \"aifc\" , \"argparse\" , \"array\" , \"ast\" , \"asynchat\" , \"asyncio\" , \"asyncore\" , \"atexit\" , \"audioop\" , \"base64\" , \"bdb\" , \"binascii\" , \"binhex\" , \"bisect\" , \"builtins\" , \"bz2\" , \"cProfile\" , \"calendar\" , \"cgi\" , \"cgitb\" , \"chunk\" , \"cmath\" , \"cmd\" , \"code\" , \"codecs\" , \"codeop\" , \"collections\" , \"colorsys\" , \"compileall\" , \"concurrent\" , \"configparser\" , \"contextlib\" , \"contextvars\" , \"copy\" , \"copyreg\" , \"crypt\" , \"csv\" , \"ctypes\" , \"curses\" , \"dataclasses\" , \"datetime\" , \"dbm\" , \"decimal\" , \"difflib\" , \"dis\" , \"distutils\" , \"doctest\" , \"email\" , \"encodings\" , \"ensurepip\" , \"enum\" , \"errno\" , \"faulthandler\" , \"fcntl\" , \"filecmp\" , \"fileinput\" , \"fnmatch\" , \"formatter\" , \"fractions\" , \"ftplib\" , \"functools\" , \"gc\" , \"getopt\" , \"getpass\" , \"gettext\" , \"glob\" , \"graphlib\" , \"grp\" , \"gzip\" , \"hashlib\" , \"heapq\" , \"hmac\" , \"html\" , \"http\" , \"imaplib\" , \"imghdr\" , \"imp\" , \"importlib\" , \"inspect\" , \"io\" , \"ipaddress\" , \"itertools\" , \"json\" , \"keyword\" , \"lib2to3\" , \"linecache\" , \"locale\" , \"logging\" , \"lzma\" , \"mailbox\" , \"mailcap\" , \"marshal\" , \"math\" , \"mimetypes\" , \"mmap\" , \"modulefinder\" , \"msilib\" , \"msvcrt\" , \"multiprocessing\" , \"netrc\" , \"nis\" , \"nntplib\" , \"ntpath\" , \"numbers\" , \"operator\" , \"optparse\" , \"os\" , \"ossaudiodev\" , \"parser\" , \"pathlib\" , \"pdb\" , \"pickle\" , \"pickletools\" , \"pipes\" , \"pkgutil\" , \"platform\" , \"plistlib\" , \"poplib\" , \"posix\" , \"posixpath\" , \"pprint\" , \"profile\" , \"pstats\" , \"pty\" , \"pwd\" , \"py_compile\" , \"pyclbr\" , \"pydoc\" , \"queue\" , \"quopri\" , \"random\" , \"re\" , \"readline\" , \"reprlib\" , \"resource\" , \"rlcompleter\" , \"runpy\" , \"sched\" , \"secrets\" , \"select\" , \"selectors\" , \"shelve\" , \"shlex\" , \"shutil\" , \"signal\" , \"site\" , \"smtpd\" , \"smtplib\" , \"sndhdr\" , \"socket\" , \"socketserver\" , \"spwd\" , \"sqlite3\" , \"sre\" , \"sre_compile\" , \"sre_constants\" , \"sre_parse\" , \"ssl\" , \"stat\" , \"statistics\" , \"string\" , \"stringprep\" , \"struct\" , \"subprocess\" , \"sunau\" , \"symbol\" , \"symtable\" , \"sys\" , \"sysconfig\" , \"syslog\" , \"tabnanny\" , \"tarfile\" , \"telnetlib\" , \"tempfile\" , \"termios\" , \"test\" , \"textwrap\" , \"threading\" , \"time\" , \"timeit\" , \"tkinter\" , \"token\" , \"tokenize\" , \"trace\" , \"traceback\" , \"tracemalloc\" , \"tty\" , \"turtle\" , \"turtledemo\" , \"types\" , \"typing\" , \"unicodedata\" , \"unittest\" , \"urllib\" , \"uu\" , \"uuid\" , \"venv\" , \"warnings\" , \"wave\" , \"weakref\" , \"webbrowser\" , \"winreg\" , \"winsound\" , \"wsgiref\" , \"xdrlib\" , \"xml\" , \"xmlrpc\" , \"zipapp\" , \"zipfile\" , \"zipimport\" , \"zlib\" , \"zoneinfo\" , }","title":"Module isort.stdlibs.py39"},{"location":"reference/isort/stdlibs/py39/#variables","text":"stdlib","title":"Variables"}]}